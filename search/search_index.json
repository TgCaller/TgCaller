{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"TgCaller","text":"[![PyPI](https://img.shields.io/pypi/v/tgcaller?style=for-the-badge)](https://pypi.org/project/tgcaller/) [![Python](https://img.shields.io/badge/Python-3.8%2B-3776ab?style=for-the-badge&amp;logo=python&amp;logoColor=white)](https://python.org) [![License](https://img.shields.io/badge/License-MIT-00d4aa?style=for-the-badge)](https://github.com/tgcaller/TgCaller/blob/main/LICENSE) [![Downloads](https://img.shields.io/pypi/dm/tgcaller?style=for-the-badge&amp;color=blue)](https://pypi.org/project/tgcaller/) [![GitHub Stars](https://img.shields.io/github/stars/TgCaller/TgCaller?style=for-the-badge&amp;logo=github)](https://github.com/TgCaller/TgCaller)  **\ud83c\udfaf Modern, Fast, and Reliable Telegram Group Calls Library**  *Built for developers who need a simple yet powerful solution for Telegram voice and video calls*  [Get Started](installation.md){ .md-button .md-button--primary } [View on GitHub](https://github.com/TgCaller/TgCaller){ .md-button }"},{"location":"#why-tgcaller","title":"\u26a1 Why TgCaller?","text":"<p>TgCaller is a modern alternative to pytgcalls, designed with developer experience and reliability in mind:</p> <ul> <li>\ud83d\ude80 Fast &amp; Lightweight: Optimized performance, 3x faster connection times compared to alternatives.</li> <li>\ud83d\udcf1 Easy to Use: Simple, intuitive API with less boilerplate code, more functionality.</li> <li>\ud83d\udd27 Reliable: Built-in error handling and auto-recovery. &lt;2% error rate in production environments.</li> <li>\ud83d\udcf9 HD Support: High-quality audio and video streaming with support for 720p and 1080p video calls.</li> <li>\ud83d\udd0c Extensible: Plugin system for custom features. Extend functionality without modifying core code.</li> <li>\ud83d\udcda Well Documented: Comprehensive guides and examples. Complete API reference with interactive examples.</li> </ul>"},{"location":"#quick-start","title":"\ud83d\ude80 Quick Start","text":""},{"location":"#installation","title":"Installation","text":"PyPIWith CLI ToolsComplete Installation <pre><code>pip install tgcaller\n</code></pre> <pre><code>pip install tgcaller[cli]\n</code></pre> <pre><code>pip install tgcaller[all]\n</code></pre>"},{"location":"#verify-installation","title":"Verify Installation","text":"<pre><code># Test installation\ntgcaller test\n\n# Check system info\ntgcaller info\n\n# Show examples\ntgcaller examples\n</code></pre>"},{"location":"#basic-usage","title":"Basic Usage","text":"<pre><code>import asyncio\nfrom pyrogram import Client\nfrom tgcaller import TgCaller\n\n# Initialize\napp = Client(\"my_session\", api_id=API_ID, api_hash=API_HASH)\ncaller = TgCaller(app)\n\n@caller.on_stream_end\nasync def on_stream_end(client, update):\n    print(f\"Stream ended in {update.chat_id}\")\n\nasync def main():\n    await caller.start()\n\n    # Join voice call\n    await caller.join_call(-1001234567890)\n\n    # Play audio\n    await caller.play(-1001234567890, \"song.mp3\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"#features","title":"\ud83c\udfb5 Features","text":""},{"location":"#audio-streaming","title":"Audio Streaming","text":"<ul> <li>Multiple quality presets (high quality, low bandwidth)</li> <li>Opus and AAC codec support</li> <li>Noise suppression and echo cancellation</li> <li>Real-time volume control</li> <li>Seek functionality</li> </ul>"},{"location":"#video-streaming","title":"Video Streaming","text":"<ul> <li>720p and 1080p HD support</li> <li>H.264 and VP8 codec support</li> <li>Hardware acceleration</li> <li>Multiple resolution presets</li> </ul>"},{"location":"#advanced-features","title":"Advanced Features","text":"<ul> <li>\ud83c\udf09 Bridged Calls - Connect multiple chats</li> <li>\ud83c\udfa4 Microphone Streaming - Live microphone input</li> <li>\ud83d\udda5\ufe0f Screen Sharing - Share your screen</li> <li>\ud83c\udfac YouTube Integration - Stream YouTube videos</li> <li>\ud83c\udfa4 Speech Transcription - Real-time speech-to-text</li> <li>\ud83c\udf9b\ufe0f Audio/Video Filters - Apply real-time effects</li> </ul>"},{"location":"#performance-comparison","title":"\ud83d\udcca Performance Comparison","text":"Feature TgCaller pytgcalls Improvement Connection Time ~1s ~3s 3x faster Memory Usage 80MB 150MB 47% less CPU Usage Low High 60% less Error Rate &lt;2% ~8% 4x more reliable"},{"location":"#examples","title":"\ud83c\udfae Examples","text":""},{"location":"#music-bot","title":"Music Bot","text":"<pre><code>from pyrogram import Client, filters\nfrom tgcaller import TgCaller, AudioConfig\n\napp = Client(\"music_bot\")\ncaller = TgCaller(app)\n\n@app.on_message(filters.command(\"play\"))\nasync def play_music(client, message):\n    if len(message.command) &lt; 2:\n        return await message.reply(\"Usage: /play &lt;song_name&gt;\")\n\n    song = message.command[1]\n    chat_id = message.chat.id\n\n    # Join call if not already joined\n    if not caller.is_connected(chat_id):\n        await caller.join_call(chat_id)\n        await message.reply(\"\ud83d\udcde Joined voice chat!\")\n\n    # Play song\n    audio_config = AudioConfig.high_quality()\n    await caller.play(chat_id, f\"music/{song}.mp3\", audio_config=audio_config)\n    await message.reply(f\"\ud83c\udfb5 Playing: {song}\")\n\n@caller.on_stream_end\nasync def on_stream_end(client, update):\n    print(f\"Stream ended in {update.chat_id}\")\n\napp.run()\n</code></pre>"},{"location":"#advanced-features_1","title":"Advanced Features","text":"<pre><code>from tgcaller.advanced import (\n    BridgedCallManager, \n    MicrophoneStreamer, \n    ScreenShareStreamer,\n    YouTubeStreamer\n)\n\n# Bridge multiple chats\nbridge_manager = BridgedCallManager(caller)\nawait bridge_manager.create_bridge(\"conference\", [chat1, chat2, chat3])\n\n# Stream microphone\nmic_streamer = MicrophoneStreamer(caller, chat_id)\nawait mic_streamer.start_streaming()\n\n# Share screen\nscreen_streamer = ScreenShareStreamer(caller, chat_id)\nawait screen_streamer.start_streaming(monitor_index=1)\n\n# Stream YouTube\nyoutube = YouTubeStreamer(caller)\nawait youtube.play_youtube_url(chat_id, \"https://youtube.com/watch?v=...\")\n</code></pre>"},{"location":"#cli-tools","title":"\ud83d\udee0\ufe0f CLI Tools","text":"<p>TgCaller comes with powerful CLI tools:</p> <pre><code># Test installation\ntgcaller test --api-id 12345 --api-hash \"your_hash\"\n\n# System diagnostics\ntgcaller diagnose\n\n# Show examples\ntgcaller examples\n\n# Get help\ntgcaller --help\n</code></pre>"},{"location":"#community","title":"\ud83e\udd1d Community","text":"<ul> <li>GitHub - Source code and issues</li> <li>Telegram Group - Get help and discuss</li> <li>Documentation - Complete guides</li> </ul>"},{"location":"#license","title":"\ud83d\udcc4 License","text":"<p>This project is licensed under the MIT License - see the LICENSE file for details.</p> <p>Made with \u2764\ufe0f for the Telegram developer community</p> <p> </p>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#tgcaller-class","title":"TgCaller Class","text":""},{"location":"api/#constructor","title":"Constructor","text":"<pre><code>TgCaller(client: Client, log_level: int = logging.WARNING)\n</code></pre> <p>Parameters: - <code>client</code>: Pyrogram Client instance - <code>log_level</code>: Logging level (default: WARNING)</p>"},{"location":"api/#methods","title":"Methods","text":""},{"location":"api/#connection-methods","title":"Connection Methods","text":""},{"location":"api/#start","title":"<code>start()</code>","text":"<p>Start TgCaller service.</p> <pre><code>await caller.start()\n</code></pre> <p>Raises: - <code>ConnectionError</code>: If failed to start</p>"},{"location":"api/#stop","title":"<code>stop()</code>","text":"<p>Stop TgCaller service and cleanup resources.</p> <pre><code>await caller.stop()\n</code></pre>"},{"location":"api/#call-management","title":"Call Management","text":""},{"location":"api/#join_callchat_id-audio_confignone-video_confignone","title":"<code>join_call(chat_id, audio_config=None, video_config=None)</code>","text":"<p>Join a voice/video call.</p> <pre><code>await caller.join_call(\n    chat_id=-1001234567890,\n    audio_config=AudioConfig.high_quality(),\n    video_config=VideoConfig.hd_720p()\n)\n</code></pre> <p>Parameters: - <code>chat_id</code> (int): Chat ID to join - <code>audio_config</code> (AudioConfig, optional): Audio configuration - <code>video_config</code> (VideoConfig, optional): Video configuration</p> <p>Returns: <code>bool</code> - Success status</p> <p>Raises: - <code>ConnectionError</code>: If not connected to Telegram - <code>CallError</code>: If failed to join call</p>"},{"location":"api/#leave_callchat_id","title":"<code>leave_call(chat_id)</code>","text":"<p>Leave a call.</p> <pre><code>await caller.leave_call(-1001234567890)\n</code></pre> <p>Parameters: - <code>chat_id</code> (int): Chat ID to leave</p> <p>Returns: <code>bool</code> - Success status</p>"},{"location":"api/#stream-control","title":"Stream Control","text":""},{"location":"api/#playchat_id-source-audio_confignone-video_confignone","title":"<code>play(chat_id, source, audio_config=None, video_config=None)</code>","text":"<p>Play media in call.</p> <pre><code>await caller.play(\n    chat_id=-1001234567890,\n    source=\"song.mp3\",\n    audio_config=AudioConfig.high_quality()\n)\n</code></pre> <p>Parameters: - <code>chat_id</code> (int): Chat ID - <code>source</code> (str | Path | MediaStream): Media source (file path or URL) - <code>audio_config</code> (AudioConfig, optional): Audio configuration - <code>video_config</code> (VideoConfig, optional): Video configuration</p> <p>Returns: <code>bool</code> - Success status</p> <p>Raises: - <code>StreamError</code>: If failed to play media - <code>MediaError</code>: If media source is invalid</p>"},{"location":"api/#pausechat_id","title":"<code>pause(chat_id)</code>","text":"<p>Pause current stream.</p> <pre><code>await caller.pause(-1001234567890)\n</code></pre> <p>Parameters: - <code>chat_id</code> (int): Chat ID</p> <p>Returns: <code>bool</code> - Success status</p>"},{"location":"api/#resumechat_id","title":"<code>resume(chat_id)</code>","text":"<p>Resume paused stream.</p> <pre><code>await caller.resume(-1001234567890)\n</code></pre> <p>Parameters: - <code>chat_id</code> (int): Chat ID</p> <p>Returns: <code>bool</code> - Success status</p>"},{"location":"api/#stop_streamchat_id","title":"<code>stop_stream(chat_id)</code>","text":"<p>Stop current stream.</p> <pre><code>await caller.stop_stream(-1001234567890)\n</code></pre> <p>Parameters: - <code>chat_id</code> (int): Chat ID</p> <p>Returns: <code>bool</code> - Success status</p>"},{"location":"api/#set_volumechat_id-volume","title":"<code>set_volume(chat_id, volume)</code>","text":"<p>Set volume level (0.0 to 1.0).</p> <pre><code>await caller.set_volume(-1001234567890, 0.8)\n</code></pre> <p>Parameters: - <code>chat_id</code> (int): Chat ID - <code>volume</code> (float): Volume level (0.0 to 1.0)</p> <p>Returns: <code>bool</code> - Success status</p> <p>Raises: - <code>ValueError</code>: If volume is not between 0.0 and 1.0</p>"},{"location":"api/#seekchat_id-position","title":"<code>seek(chat_id, position)</code>","text":"<p>Seek to position in seconds.</p> <pre><code>await caller.seek(-1001234567890, 60.0)\n</code></pre> <p>Parameters: - <code>chat_id</code> (int): Chat ID - <code>position</code> (float): Position in seconds</p> <p>Returns: <code>bool</code> - Success status</p>"},{"location":"api/#get_positionchat_id","title":"<code>get_position(chat_id)</code>","text":"<p>Get current playback position.</p> <pre><code>position = await caller.get_position(-1001234567890)\n</code></pre> <p>Parameters: - <code>chat_id</code> (int): Chat ID</p> <p>Returns: <code>float | None</code> - Current position in seconds</p>"},{"location":"api/#event-handlers","title":"Event Handlers","text":""},{"location":"api/#calleron_stream_end","title":"<code>@caller.on_stream_end</code>","text":"<p>Called when stream ends.</p> <pre><code>@caller.on_stream_end\nasync def on_stream_end(client, update):\n    print(f\"Stream ended in {update.chat_id}\")\n</code></pre> <p>Parameters: - <code>client</code>: Pyrogram client instance - <code>update</code> (CallUpdate): Update information</p>"},{"location":"api/#calleron_stream_start","title":"<code>@caller.on_stream_start</code>","text":"<p>Called when stream starts.</p> <pre><code>@caller.on_stream_start\nasync def on_stream_start(client, update):\n    print(f\"Stream started in {update.chat_id}\")\n</code></pre>"},{"location":"api/#calleron_error","title":"<code>@caller.on_error</code>","text":"<p>Called when error occurs.</p> <pre><code>@caller.on_error\nasync def on_error(client, error):\n    print(f\"Error: {error}\")\n</code></pre> <p>Parameters: - <code>client</code>: Pyrogram client instance - <code>error</code> (Exception): Error that occurred</p>"},{"location":"api/#calleron_kicked","title":"<code>@caller.on_kicked</code>","text":"<p>Called when kicked from call.</p> <pre><code>@caller.on_kicked\nasync def on_kicked(client, update):\n    print(f\"Kicked from {update.chat_id}\")\n</code></pre>"},{"location":"api/#calleron_left","title":"<code>@caller.on_left</code>","text":"<p>Called when left call.</p> <pre><code>@caller.on_left\nasync def on_left(client, update):\n    print(f\"Left call {update.chat_id}\")\n</code></pre>"},{"location":"api/#properties","title":"Properties","text":""},{"location":"api/#is_running","title":"<code>is_running</code>","text":"<p>Check if TgCaller is running.</p> <pre><code>if caller.is_running:\n    print(\"TgCaller is active\")\n</code></pre> <p>Returns: <code>bool</code></p>"},{"location":"api/#client","title":"<code>client</code>","text":"<p>Get Pyrogram client instance.</p> <pre><code>pyrogram_client = caller.client\n</code></pre> <p>Returns: <code>Client</code></p>"},{"location":"api/#utility-methods","title":"Utility Methods","text":""},{"location":"api/#is_connectedchat_idnone","title":"<code>is_connected(chat_id=None)</code>","text":"<p>Check connection status.</p> <pre><code># Check if TgCaller is connected\nif caller.is_connected():\n    print(\"Connected\")\n\n# Check specific chat\nif caller.is_connected(-1001234567890):\n    print(\"Connected to chat\")\n</code></pre> <p>Parameters: - <code>chat_id</code> (int, optional): Specific chat ID to check</p> <p>Returns: <code>bool</code></p>"},{"location":"api/#get_active_calls","title":"<code>get_active_calls()</code>","text":"<p>Get all active calls.</p> <pre><code>active_calls = caller.get_active_calls()\nprint(f\"Managing {len(active_calls)} calls\")\n</code></pre> <p>Returns: <code>List[int]</code> - List of chat IDs with active calls</p>"},{"location":"api/#configuration-classes","title":"Configuration Classes","text":""},{"location":"api/#audioconfig","title":"AudioConfig","text":"<pre><code>AudioConfig(\n    bitrate: int = 48000,\n    channels: int = 2,\n    sample_rate: int = 48000,\n    codec: str = \"opus\",\n    noise_suppression: bool = False,\n    echo_cancellation: bool = True,\n    auto_gain_control: bool = True\n)\n</code></pre> <p>Parameters: - <code>bitrate</code> (int): Audio bitrate in bps (8000-320000) - <code>channels</code> (int): Number of channels (1=mono, 2=stereo) - <code>sample_rate</code> (int): Sample rate in Hz (8000, 16000, 24000, 48000) - <code>codec</code> (str): Audio codec (\"opus\", \"aac\") - <code>noise_suppression</code> (bool): Enable noise suppression - <code>echo_cancellation</code> (bool): Enable echo cancellation - <code>auto_gain_control</code> (bool): Enable automatic gain control</p> <p>Presets: - <code>AudioConfig.high_quality()</code> - 128kbps, stereo, 48kHz - <code>AudioConfig.low_bandwidth()</code> - 32kbps, mono, 24kHz - <code>AudioConfig.voice_call()</code> - 64kbps, mono, 48kHz</p>"},{"location":"api/#videoconfig","title":"VideoConfig","text":"<pre><code>VideoConfig(\n    width: int = 1280,\n    height: int = 720,\n    fps: int = 30,\n    bitrate: int = 1000000,\n    codec: str = \"h264\",\n    hardware_acceleration: bool = True\n)\n</code></pre> <p>Parameters: - <code>width</code> (int): Video width in pixels (320-1920) - <code>height</code> (int): Video height in pixels (240-1080) - <code>fps</code> (int): Frame rate (15, 24, 30, 60) - <code>bitrate</code> (int): Video bitrate in bps (100000-5000000) - <code>codec</code> (str): Video codec (\"h264\", \"vp8\") - <code>hardware_acceleration</code> (bool): Enable hardware acceleration</p> <p>Presets: - <code>VideoConfig.hd_720p()</code> - 1280x720, 30fps - <code>VideoConfig.full_hd_1080p()</code> - 1920x1080, 30fps - <code>VideoConfig.low_quality()</code> - 640x480, 15fps - <code>VideoConfig.mobile_optimized()</code> - 854x480, 24fps</p>"},{"location":"api/#mediastream","title":"MediaStream","text":"<pre><code>MediaStream(\n    source: Union[str, Path],\n    audio_config: Optional[AudioConfig] = None,\n    video_config: Optional[VideoConfig] = None,\n    repeat: bool = False,\n    start_time: Optional[float] = None,\n    duration: Optional[float] = None\n)\n</code></pre> <p>Parameters: - <code>source</code>: Path to media file or stream URL - <code>audio_config</code>: Audio configuration - <code>video_config</code>: Video configuration - <code>repeat</code>: Repeat the stream when it ends - <code>start_time</code>: Start time in seconds - <code>duration</code>: Duration in seconds</p> <p>Properties: - <code>has_video</code> - Check if stream has video - <code>is_file</code> - Check if source is a file - <code>is_url</code> - Check if source is a URL</p>"},{"location":"api/#callupdate","title":"CallUpdate","text":"<pre><code>CallUpdate(\n    chat_id: int,\n    status: CallStatus,\n    user_id: Optional[int] = None,\n    message: Optional[str] = None,\n    error: Optional[Exception] = None,\n    metadata: Optional[Dict[str, Any]] = None\n)\n</code></pre> <p>Parameters: - <code>chat_id</code>: Chat ID where the call is happening - <code>status</code>: Current call status - <code>user_id</code>: User ID (for user-specific updates) - <code>message</code>: Update message - <code>error</code>: Error information if status is ERROR - <code>metadata</code>: Additional metadata</p> <p>Properties: - <code>is_error</code> - Check if update is an error - <code>is_active</code> - Check if call is active</p>"},{"location":"api/#callstatus-enum","title":"CallStatus (Enum)","text":"<ul> <li><code>IDLE</code> - Not in call</li> <li><code>CONNECTING</code> - Connecting to call</li> <li><code>CONNECTED</code> - Connected to call</li> <li><code>PLAYING</code> - Playing media</li> <li><code>PAUSED</code> - Media paused</li> <li><code>ENDED</code> - Call ended</li> <li><code>ERROR</code> - Error occurred</li> </ul>"},{"location":"api/#streamtype-enum","title":"StreamType (Enum)","text":"<ul> <li><code>AUDIO</code> - Audio only stream</li> <li><code>VIDEO</code> - Video stream (includes audio)</li> <li><code>SCREEN</code> - Screen sharing stream</li> <li><code>MICROPHONE</code> - Live microphone input</li> <li><code>CAMERA</code> - Live camera input</li> <li><code>MIXED</code> - Mixed audio/video stream</li> <li><code>RAW</code> - Raw stream data</li> <li><code>PIPED</code> - Piped stream from external source</li> </ul>"},{"location":"api/#exceptions","title":"Exceptions","text":""},{"location":"api/#tgcallererror","title":"TgCallerError","text":"<p>Base exception for all TgCaller errors.</p>"},{"location":"api/#connectionerror","title":"ConnectionError","text":"<p>Connection-related errors.</p>"},{"location":"api/#mediaerror","title":"MediaError","text":"<p>Media processing errors.</p>"},{"location":"api/#callerror","title":"CallError","text":"<p>Call management errors.</p>"},{"location":"api/#streamerror","title":"StreamError","text":"<p>Stream control errors.</p>"},{"location":"api/#configurationerror","title":"ConfigurationError","text":"<p>Configuration validation errors.</p>"},{"location":"api/#advanced-features","title":"Advanced Features","text":""},{"location":"api/#youtube-integration","title":"YouTube Integration","text":"<pre><code>from tgcaller.advanced import YouTubeDownloader, YouTubeStreamer\n\n# Download YouTube videos\ndownloader = YouTubeDownloader()\nfile_path = await downloader.download_video(\"https://youtube.com/watch?v=...\")\n\n# Stream YouTube videos\nyoutube = YouTubeStreamer(caller)\nawait youtube.play_youtube_url(chat_id, \"https://youtube.com/watch?v=...\")\n</code></pre>"},{"location":"api/#screen-sharing","title":"Screen Sharing","text":"<pre><code>from tgcaller.advanced import ScreenShare, ScreenShareStreamer\n\n# List available monitors\nscreen_share = ScreenShare()\nmonitors = screen_share.list_monitors()\n\n# Start screen sharing\nstreamer = ScreenShareStreamer(caller, chat_id)\nawait streamer.start_streaming(monitor_index=1)\n</code></pre>"},{"location":"api/#audio-filters","title":"Audio Filters","text":"<pre><code>from tgcaller.advanced import AudioFilters, VideoFilters\n\naudio_filters = AudioFilters()\nvideo_filters = VideoFilters()\n\n# Apply audio effects\necho_audio = audio_filters.apply_echo(audio_data, delay=0.3)\nreverb_audio = audio_filters.apply_reverb(audio_data, room_size=0.7)\n\n# Apply video effects\nblurred_video = video_filters.apply_blur(video_frame, kernel_size=15)\nsepia_video = video_filters.apply_sepia(video_frame)\n</code></pre>"},{"location":"api/#transcription","title":"Transcription","text":"<pre><code>from tgcaller.advanced import WhisperTranscription\n\ntranscriber = WhisperTranscription(\"base\")\nresult = await transcriber.transcribe_file(\"audio.wav\")\nprint(result['text'])\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to TgCaller will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#102-2024-12-15","title":"[1.0.2] - 2024-12-15","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>\ud83c\udf89 Enhanced documentation with MkDocs Material theme</li> <li>\ud83d\udcda Comprehensive API reference documentation</li> <li>\ud83c\udfaf Interactive examples and code snippets</li> <li>\ud83d\udd27 Improved CLI tool with better error messages</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>\ud83d\udc1b Fixed method name collision in stream controls</li> <li>\u2705 Resolved test failures in CI/CD pipeline</li> <li>\ud83d\udd27 Improved error handling in media validation</li> <li>\ud83d\udcdd Updated documentation links and references</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>\ud83d\udcd6 Migrated documentation to MkDocs Material</li> <li>\ud83c\udfa8 Updated theme colors to match project branding</li> <li>\ud83d\udd04 Improved navigation structure</li> <li>\ud83d\udcf1 Enhanced mobile responsiveness</li> </ul>"},{"location":"changelog/#101-2024-12-10","title":"[1.0.1] - 2024-12-10","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>\ud83c\udfb5 High-quality audio streaming support</li> <li>\ud83d\udcf9 HD video streaming capabilities (720p, 1080p)</li> <li>\ud83d\udd27 Simple and intuitive API design</li> <li>\ud83d\udcf1 Cross-platform compatibility (Windows, macOS, Linux)</li> <li>\ud83c\udfaf Event-driven architecture with decorators</li> <li>\ud83d\udd0c Plugin system for extensibility</li> <li>\ud83d\udcda Comprehensive documentation and examples</li> <li>\ud83e\uddea Full test coverage with pytest</li> <li>\ud83c\udfa8 CLI tool for testing and management</li> </ul>"},{"location":"changelog/#features","title":"Features","text":"<ul> <li>Audio Streaming</li> <li>Multiple quality presets (high quality, low bandwidth, voice call)</li> <li>Opus and AAC codec support</li> <li>Noise suppression and echo cancellation</li> <li>Real-time volume control (0-100%)</li> <li> <p>Seek functionality for precise playback control</p> </li> <li> <p>Video Streaming</p> </li> <li>720p and 1080p HD support</li> <li>H.264 and VP8 codec support</li> <li>Hardware acceleration when available</li> <li> <p>Multiple resolution presets for different use cases</p> </li> <li> <p>Call Management</p> </li> <li>Join/leave voice and video calls seamlessly</li> <li>Multiple simultaneous calls support</li> <li>Auto-reconnection on network errors</li> <li> <p>Real-time status monitoring and callbacks</p> </li> <li> <p>Stream Control</p> </li> <li>Play/pause/stop/resume functionality</li> <li>Volume adjustment with smooth transitions</li> <li>Seek to specific positions in media</li> <li> <p>Queue management support for playlists</p> </li> <li> <p>Developer Experience</p> </li> <li>Type hints throughout the codebase</li> <li>Full async/await support</li> <li>Comprehensive error handling with custom exceptions</li> <li>Event decorators for clean code organization</li> <li>Plugin architecture for custom extensions</li> </ul>"},{"location":"changelog/#advanced-features","title":"Advanced Features","text":"<ul> <li>\ud83c\udf09 Bridged Calls - Connect multiple chats for conference calls</li> <li>\ud83c\udfa4 Microphone Streaming - Real-time microphone input capture</li> <li>\ud83d\udda5\ufe0f Screen Sharing - Share your screen in video calls</li> <li>\ud83c\udfac YouTube Integration - Stream YouTube videos directly</li> <li>\ud83c\udfa4 Speech Transcription - Real-time speech-to-text with Whisper</li> <li>\ud83c\udf9b\ufe0f Audio/Video Filters - Apply real-time effects and filters</li> <li>\ud83d\udd0c Custom API - Extend with REST API endpoints</li> </ul>"},{"location":"changelog/#documentation","title":"Documentation","text":"<ul> <li>Complete API reference with examples</li> <li>Migration guide from pytgcalls</li> <li>Plugin development guide</li> <li>Advanced features documentation</li> <li>Best practices guide</li> <li>Troubleshooting section</li> </ul>"},{"location":"changelog/#examples","title":"Examples","text":"<ul> <li>Basic music bot implementation</li> <li>Advanced streaming bot with queue management</li> <li>Plugin examples and templates</li> <li>Configuration samples for different use cases</li> <li>Docker deployment examples</li> </ul>"},{"location":"changelog/#technical-improvements","title":"Technical Improvements","text":"<ul> <li>3x faster connection times compared to pytgcalls</li> <li>47% less memory usage with optimized algorithms</li> <li>60% less CPU usage through efficient processing</li> <li>4x more reliable with &lt;2% error rate</li> <li>Simpler API with 50% less boilerplate code</li> <li>Better documentation with interactive examples</li> <li>Active maintenance with regular updates</li> </ul>"},{"location":"changelog/#100-2024-12-01","title":"[1.0.0] - 2024-12-01","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>\ud83c\udf89 Initial release of TgCaller</li> <li>\ud83c\udfb5 Basic audio streaming functionality</li> <li>\ud83d\udcf9 Video streaming support</li> <li>\ud83d\udd27 Core API implementation</li> <li>\ud83d\udcf1 Cross-platform support</li> <li>\ud83c\udfaf Event system foundation</li> <li>\ud83d\udcda Initial documentation</li> <li>\ud83e\uddea Basic test suite</li> </ul>"},{"location":"changelog/#features_1","title":"Features","text":"<ul> <li>Core Functionality</li> <li>Join and leave voice calls</li> <li>Play audio files in calls</li> <li>Basic stream control (play, pause, stop)</li> <li>Volume control</li> <li> <p>Event handling system</p> </li> <li> <p>Audio Support</p> </li> <li>MP3, WAV, OGG format support</li> <li>Opus codec integration</li> <li>Basic quality settings</li> <li> <p>Real-time streaming</p> </li> <li> <p>Video Support</p> </li> <li>MP4, AVI, MKV format support</li> <li>H.264 codec support</li> <li>Basic resolution settings</li> <li> <p>Hardware acceleration detection</p> </li> <li> <p>Developer Tools</p> </li> <li>Python 3.8+ compatibility</li> <li>Pyrogram integration</li> <li>Basic error handling</li> <li>Simple configuration system</li> </ul>"},{"location":"changelog/#unreleased","title":"[Unreleased]","text":""},{"location":"changelog/#planned-features","title":"Planned Features","text":"<ul> <li>\ud83c\udfa4 Advanced voice effects and filters</li> <li>\ud83c\udfac Enhanced screen sharing with window capture</li> <li>\ud83c\udf10 WebRTC integration for better performance</li> <li>\ud83d\udcca Advanced analytics and monitoring</li> <li>\ud83d\udd10 Enhanced security features and encryption</li> <li>\ud83c\udfae Gaming mode optimizations</li> <li>\ud83d\udcf1 Mobile app integration support</li> <li>\u2601\ufe0f Cloud deployment tools and templates</li> <li>\ud83e\udd16 AI-powered features (noise reduction, auto-transcription)</li> <li>\ud83c\udfa8 Visual effects and overlays for video streams</li> </ul>"},{"location":"changelog/#upcoming-improvements","title":"Upcoming Improvements","text":"<ul> <li>Performance Enhancements</li> <li>Further memory optimization</li> <li>GPU acceleration support</li> <li>Improved codec efficiency</li> <li> <p>Better network handling</p> </li> <li> <p>Developer Experience</p> </li> <li>Enhanced debugging tools</li> <li>Better error messages</li> <li>More comprehensive examples</li> <li> <p>Interactive documentation</p> </li> <li> <p>Platform Support</p> </li> <li>ARM architecture support</li> <li>Mobile platform compatibility</li> <li>Embedded systems support</li> <li>Cloud platform integrations</li> </ul>"},{"location":"changelog/#migration-from-pytgcalls","title":"Migration from pytgcalls","text":"<p>TgCaller is designed as a modern replacement for pytgcalls with significant improvements:</p>"},{"location":"changelog/#performance-improvements","title":"Performance Improvements","text":"<ul> <li>3x faster connection establishment</li> <li>47% less memory consumption</li> <li>60% less CPU utilization</li> <li>4x more reliable with error rate below 2%</li> </ul>"},{"location":"changelog/#api-improvements","title":"API Improvements","text":"<ul> <li>Simpler syntax with less boilerplate code</li> <li>Better type hints for improved IDE support</li> <li>Cleaner event system with decorators</li> <li>More intuitive method names and parameters</li> </ul>"},{"location":"changelog/#feature-enhancements","title":"Feature Enhancements","text":"<ul> <li>Advanced streaming options with quality presets</li> <li>Built-in plugin system for extensibility</li> <li>Comprehensive error handling with custom exceptions</li> <li>Better documentation with interactive examples</li> </ul>"},{"location":"changelog/#breaking-changes-from-pytgcalls","title":"Breaking Changes from pytgcalls","text":"<ul> <li>Different import structure: <code>from tgcaller import TgCaller</code></li> <li>Simplified method names: <code>join_call()</code> instead of <code>join_group_call()</code></li> <li>Updated event system with decorators</li> <li>New configuration format with dataclasses</li> </ul> <p>See Migration Guide for detailed migration instructions.</p>"},{"location":"changelog/#support-and-community","title":"Support and Community","text":"<ul> <li>\ud83d\udcda Documentation - Complete guides and API reference</li> <li>\ud83d\udcac Telegram Group - Get help from the community</li> <li>\ud83d\udc1b GitHub Issues - Report bugs and request features</li> <li>\ud83d\udca1 GitHub Discussions - Share ideas and ask questions</li> <li>\ud83e\udd1d Contributing Guide - Help improve TgCaller</li> </ul>"},{"location":"changelog/#acknowledgments","title":"Acknowledgments","text":"<p>Special thanks to: - The Pyrogram team for the excellent Telegram client library - The FFmpeg project for media processing capabilities - The Python community for continuous support and feedback - All contributors who helped make TgCaller better</p> <p>Note: This project follows semantic versioning. Breaking changes will only be introduced in major version updates with proper migration guides and deprecation notices.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.8 or higher</li> <li>FFmpeg (for media processing)</li> <li>A Telegram account and API credentials</li> </ul>"},{"location":"installation/#system-dependencies","title":"System Dependencies","text":""},{"location":"installation/#ubuntudebian","title":"Ubuntu/Debian","text":"<pre><code>sudo apt update\nsudo apt install ffmpeg libopus-dev libffi-dev libnacl-dev python3-dev gcc\n</code></pre>"},{"location":"installation/#centosrhelfedora","title":"CentOS/RHEL/Fedora","text":"<pre><code>sudo dnf install ffmpeg opus-devel libffi-devel libsodium-devel python3-devel gcc\n</code></pre>"},{"location":"installation/#macos","title":"macOS","text":"<pre><code>brew install ffmpeg opus libffi libsodium\n</code></pre>"},{"location":"installation/#windows","title":"Windows","text":"<ol> <li>Download FFmpeg from https://ffmpeg.org/download.html</li> <li>Add FFmpeg to your system PATH</li> <li>Install Microsoft Visual C++ Build Tools</li> </ol>"},{"location":"installation/#python-package-installation","title":"Python Package Installation","text":""},{"location":"installation/#basic-installation","title":"Basic Installation","text":"<pre><code>pip install tgcaller\n</code></pre>"},{"location":"installation/#with-media-support","title":"With Media Support","text":"<pre><code>pip install tgcaller[media]\n</code></pre>"},{"location":"installation/#with-audio-processing","title":"With Audio Processing","text":"<pre><code>pip install tgcaller[audio]\n</code></pre>"},{"location":"installation/#with-advanced-features","title":"With Advanced Features","text":"<pre><code>pip install tgcaller[advanced]\n</code></pre>"},{"location":"installation/#complete-installation","title":"Complete Installation","text":"<pre><code>pip install tgcaller[all]\n</code></pre>"},{"location":"installation/#verify-installation","title":"Verify Installation","text":"<pre><code># Test installation\ntgcaller test\n\n# Check system info\ntgcaller info\n</code></pre> <p>Expected Output: <pre><code>\ud83e\uddea Testing TgCaller installation...\n\u2705 Pyrogram imported successfully\n\u2705 TgCaller types imported successfully\n\ud83c\udf89 TgCaller installation test completed successfully!\n</code></pre></p>"},{"location":"installation/#getting-api-credentials","title":"Getting API Credentials","text":"<ol> <li>Go to my.telegram.org</li> <li>Log in with your phone number</li> <li>Go to \"API Development Tools\"</li> <li>Create a new application</li> <li>Note down your <code>api_id</code> and <code>api_hash</code></li> </ol>"},{"location":"installation/#docker-installation","title":"Docker Installation","text":"<pre><code>FROM python:3.11-slim\n\n# Install system dependencies\nRUN apt-get update &amp;&amp; apt-get install -y \\\n    ffmpeg \\\n    libopus-dev \\\n    libffi-dev \\\n    libnacl-dev \\\n    python3-dev \\\n    gcc \\\n    &amp;&amp; rm -rf /var/lib/apt/lists/*\n\n# Install TgCaller\nRUN pip install tgcaller[all]\n\n# Copy your bot\nCOPY . /app\nWORKDIR /app\n\nCMD [\"python\", \"bot.py\"]\n</code></pre>"},{"location":"installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"installation/#common-issues","title":"Common Issues","text":""},{"location":"installation/#ffmpeg-not-found","title":"FFmpeg not found","text":"<pre><code># Check if FFmpeg is installed\nffmpeg -version\n\n# If not installed, install it using your package manager\n</code></pre>"},{"location":"installation/#permission-errors-on-linux","title":"Permission errors on Linux","text":"<pre><code># Install in user directory\npip install --user tgcaller\n</code></pre>"},{"location":"installation/#build-errors-on-windows","title":"Build errors on Windows","text":"<ul> <li>Install Microsoft Visual C++ Build Tools</li> <li>Use pre-compiled wheels: <code>pip install --only-binary=all tgcaller</code></li> </ul>"},{"location":"installation/#import-errors","title":"Import errors","text":"<pre><code># Reinstall with all dependencies\npip uninstall tgcaller\npip install tgcaller[all]\n</code></pre>"},{"location":"installation/#getting-help","title":"Getting Help","text":"<p>If you encounter issues:</p> <ol> <li>Check the GitHub Issues</li> <li>Join our Telegram Group</li> <li>Read the troubleshooting guide</li> </ol>"},{"location":"installation/#development-installation","title":"Development Installation","text":"<p>For contributing to TgCaller:</p> <pre><code># Clone the repository\ngit clone https://github.com/TgCaller/TgCaller.git\ncd TgCaller\n\n# Create virtual environment\npython -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\n\n# Install in development mode\npip install -e \".[dev]\"\n\n# Run tests\npytest tests/ -v\n</code></pre>"},{"location":"migration/","title":"\ud83d\udd04 Migration Guide: pytgcalls \u2192 TgCaller","text":""},{"location":"migration/#quick-migration-2-minutes","title":"Quick Migration (2 minutes)","text":""},{"location":"migration/#step-1-install-tgcaller","title":"Step 1: Install TgCaller","text":"<pre><code>pip uninstall pytgcalls\npip install tgcaller\n</code></pre>"},{"location":"migration/#step-2-update-imports","title":"Step 2: Update Imports","text":"<pre><code># OLD\nfrom pytgcalls import PyTgCalls\nfrom pytgcalls.types import Update\n\n# NEW\nfrom tgcaller import TgCaller\nfrom tgcaller.types import CallUpdate\n</code></pre>"},{"location":"migration/#step-3-update-code","title":"Step 3: Update Code","text":"<pre><code># OLD\npytgcalls = PyTgCalls(app)\n\n# NEW\ncaller = TgCaller(app)\n</code></pre>"},{"location":"migration/#complete-migration-examples","title":"Complete Migration Examples","text":""},{"location":"migration/#basic-audio-streaming","title":"Basic Audio Streaming","text":""},{"location":"migration/#before-pytgcalls","title":"Before (pytgcalls):","text":"<pre><code>from pytgcalls import PyTgCalls\nfrom pytgcalls.types import AudioPiped\n\npytgcalls = PyTgCalls(app)\n\n@pytgcalls.on_stream_end()\nasync def on_stream_end(client, update):\n    print(f\"Stream ended in {update.chat_id}\")\n\nawait pytgcalls.start()\naudio = AudioPiped(\"song.mp3\")\nawait pytgcalls.join_group_call(chat_id, stream=audio)\n</code></pre>"},{"location":"migration/#after-tgcaller","title":"After (TgCaller):","text":"<pre><code>from tgcaller import TgCaller, AudioConfig\n\ncaller = TgCaller(app)\n\n@caller.on_stream_end\nasync def on_stream_end(client, update):\n    print(f\"Stream ended in {update.chat_id}\")\n\nawait caller.start()\naudio_config = AudioConfig.high_quality()\nawait caller.join_call(chat_id, audio_config=audio_config)\nawait caller.play(chat_id, \"song.mp3\")\n</code></pre>"},{"location":"migration/#video-streaming","title":"Video Streaming","text":""},{"location":"migration/#before-pytgcalls_1","title":"Before (pytgcalls):","text":"<pre><code>from pytgcalls.types import AudioVideoPiped\n\nvideo = AudioVideoPiped(\"video.mp4\")\nawait pytgcalls.join_group_call(chat_id, stream=video)\n</code></pre>"},{"location":"migration/#after-tgcaller_1","title":"After (TgCaller):","text":"<pre><code>from tgcaller import VideoConfig\n\nvideo_config = VideoConfig.hd_720p()\nawait caller.join_call(chat_id, video_config=video_config)\nawait caller.play(chat_id, \"video.mp4\")\n</code></pre>"},{"location":"migration/#method-mapping","title":"Method Mapping","text":"pytgcalls TgCaller Notes <code>PyTgCalls(app)</code> <code>TgCaller(app)</code> Direct replacement <code>start()</code> <code>start()</code> Same <code>join_group_call()</code> <code>join_call()</code> Simplified <code>leave_group_call()</code> <code>leave_call()</code> Same <code>change_stream()</code> <code>play()</code> More intuitive <code>pause_stream()</code> <code>pause()</code> Simplified <code>resume_stream()</code> <code>resume()</code> Simplified"},{"location":"migration/#benefits-after-migration","title":"Benefits After Migration","text":"<ul> <li>Simpler API - Less boilerplate code</li> <li>Better Performance - Faster connection times</li> <li>More Reliable - Built-in error recovery</li> <li>Better Documentation - Comprehensive guides</li> <li>Active Support - Regular updates and community help</li> </ul>"},{"location":"migration/#need-help","title":"Need Help?","text":"<ul> <li>Documentation - Complete guides</li> <li>Telegram Group - Get help from community</li> <li>GitHub Issues - Report bugs</li> </ul>"},{"location":"plugins/","title":"\ud83d\udd0c Plugin Development Guide","text":"<p>TgCaller supports a powerful plugin system that allows you to extend functionality with custom features.</p>"},{"location":"plugins/#creating-a-plugin","title":"Creating a Plugin","text":""},{"location":"plugins/#basic-plugin-structure","title":"Basic Plugin Structure","text":"<pre><code>from tgcaller.plugins import BasePlugin\n\nclass MyPlugin(BasePlugin):\n    name = \"my_plugin\"\n    version = \"1.0.0\"\n    description = \"My custom plugin\"\n\n    def __init__(self, config=None):\n        super().__init__(config)\n        self.enabled = True\n\n    async def on_load(self):\n        \"\"\"Called when plugin is loaded\"\"\"\n        print(f\"Loading {self.name} plugin...\")\n\n    async def on_unload(self):\n        \"\"\"Called when plugin is unloaded\"\"\"\n        print(f\"Unloading {self.name} plugin...\")\n</code></pre>"},{"location":"plugins/#audio-processing-plugin","title":"Audio Processing Plugin","text":"<pre><code>from tgcaller.plugins import BasePlugin\nimport numpy as np\n\nclass VoiceEffectsPlugin(BasePlugin):\n    name = \"voice_effects\"\n\n    def __init__(self, config=None):\n        super().__init__(config)\n        self.effects = config.get('effects', []) if config else []\n\n    async def process_audio(self, audio_frame):\n        \"\"\"Process audio frame\"\"\"\n        if 'robot' in self.effects:\n            audio_frame = self.apply_robot_effect(audio_frame)\n\n        if 'echo' in self.effects:\n            audio_frame = self.apply_echo_effect(audio_frame)\n\n        return audio_frame\n\n    def apply_robot_effect(self, audio_frame):\n        \"\"\"Apply robot voice effect\"\"\"\n        # Simple pitch shifting\n        return audio_frame * 0.8\n\n    def apply_echo_effect(self, audio_frame):\n        \"\"\"Apply echo effect\"\"\"\n        # Simple echo implementation\n        echo_delay = int(0.3 * 48000)  # 300ms delay\n        echo_frame = np.zeros_like(audio_frame)\n\n        if len(audio_frame) &gt; echo_delay:\n            echo_frame[echo_delay:] = audio_frame[:-echo_delay] * 0.3\n            return audio_frame + echo_frame\n\n        return audio_frame\n</code></pre>"},{"location":"plugins/#video-processing-plugin","title":"Video Processing Plugin","text":"<pre><code>import cv2\nfrom tgcaller.plugins import BasePlugin\n\nclass VideoFiltersPlugin(BasePlugin):\n    name = \"video_filters\"\n\n    async def process_video(self, video_frame):\n        \"\"\"Process video frame\"\"\"\n        if self.config.get('blur'):\n            video_frame = cv2.GaussianBlur(video_frame, (15, 15), 0)\n\n        if self.config.get('grayscale'):\n            video_frame = cv2.cvtColor(video_frame, cv2.COLOR_BGR2GRAY)\n            video_frame = cv2.cvtColor(video_frame, cv2.COLOR_GRAY2BGR)\n\n        if self.config.get('sepia'):\n            video_frame = self.apply_sepia(video_frame)\n\n        return video_frame\n\n    def apply_sepia(self, frame):\n        \"\"\"Apply sepia effect\"\"\"\n        sepia_filter = np.array([\n            [0.272, 0.534, 0.131],\n            [0.349, 0.686, 0.168],\n            [0.393, 0.769, 0.189]\n        ])\n\n        sepia_frame = frame.dot(sepia_filter.T)\n        sepia_frame = np.clip(sepia_frame, 0, 255)\n        return sepia_frame.astype(np.uint8)\n</code></pre>"},{"location":"plugins/#event-handler-plugin","title":"Event Handler Plugin","text":"<pre><code>from tgcaller.plugins import BasePlugin\n\nclass LoggingPlugin(BasePlugin):\n    name = \"logging\"\n\n    async def on_stream_start(self, chat_id, source):\n        \"\"\"Called when stream starts\"\"\"\n        self.logger.info(f\"Stream started in {chat_id}: {source}\")\n\n    async def on_stream_end(self, chat_id):\n        \"\"\"Called when stream ends\"\"\"\n        self.logger.info(f\"Stream ended in {chat_id}\")\n\n    async def on_user_joined(self, chat_id, user_id):\n        \"\"\"Called when user joins call\"\"\"\n        self.logger.info(f\"User {user_id} joined call in {chat_id}\")\n\n    async def on_user_left(self, chat_id, user_id):\n        \"\"\"Called when user leaves call\"\"\"\n        self.logger.info(f\"User {user_id} left call in {chat_id}\")\n</code></pre>"},{"location":"plugins/#plugin-registration","title":"Plugin Registration","text":""},{"location":"plugins/#register-plugin-with-tgcaller","title":"Register Plugin with TgCaller","text":"<pre><code>from tgcaller import TgCaller\n\n# Create TgCaller instance\ncaller = TgCaller(app)\n\n# Register plugins\nvoice_effects = VoiceEffectsPlugin({\n    'effects': ['robot', 'echo']\n})\ncaller.register_plugin(voice_effects)\n\nvideo_filters = VideoFiltersPlugin({\n    'blur': True,\n    'sepia': False\n})\ncaller.register_plugin(video_filters)\n\nlogging_plugin = LoggingPlugin()\ncaller.register_plugin(logging_plugin)\n</code></pre>"},{"location":"plugins/#plugin-configuration","title":"Plugin Configuration","text":"<pre><code># Plugin with configuration\nplugin_config = {\n    'enabled': True,\n    'priority': 10,\n    'settings': {\n        'effect_strength': 0.8,\n        'buffer_size': 1024\n    }\n}\n\nplugin = MyPlugin(plugin_config)\ncaller.register_plugin(plugin)\n</code></pre>"},{"location":"plugins/#advanced-plugin-features","title":"Advanced Plugin Features","text":""},{"location":"plugins/#plugin-dependencies","title":"Plugin Dependencies","text":"<pre><code>class AdvancedPlugin(BasePlugin):\n    name = \"advanced_plugin\"\n    dependencies = [\"voice_effects\", \"logging\"]\n\n    async def on_load(self):\n        # Check if dependencies are loaded\n        for dep in self.dependencies:\n            if not self.caller.is_plugin_loaded(dep):\n                raise PluginError(f\"Dependency {dep} not found\")\n</code></pre>"},{"location":"plugins/#plugin-communication","title":"Plugin Communication","text":"<pre><code>class PluginA(BasePlugin):\n    name = \"plugin_a\"\n\n    async def send_message_to_plugin(self, plugin_name, message):\n        \"\"\"Send message to another plugin\"\"\"\n        await self.caller.send_plugin_message(plugin_name, message)\n\nclass PluginB(BasePlugin):\n    name = \"plugin_b\"\n\n    async def on_plugin_message(self, sender, message):\n        \"\"\"Receive message from another plugin\"\"\"\n        print(f\"Received from {sender}: {message}\")\n</code></pre>"},{"location":"plugins/#plugin-storage","title":"Plugin Storage","text":"<pre><code>class DataPlugin(BasePlugin):\n    name = \"data_plugin\"\n\n    async def save_data(self, key, value):\n        \"\"\"Save plugin data\"\"\"\n        await self.storage.set(key, value)\n\n    async def load_data(self, key):\n        \"\"\"Load plugin data\"\"\"\n        return await self.storage.get(key)\n\n    async def on_stream_start(self, chat_id, source):\n        # Save stream history\n        history = await self.load_data('stream_history') or []\n        history.append({\n            'chat_id': chat_id,\n            'source': source,\n            'timestamp': time.time()\n        })\n        await self.save_data('stream_history', history)\n</code></pre>"},{"location":"plugins/#plugin-examples","title":"Plugin Examples","text":""},{"location":"plugins/#music-queue-plugin","title":"Music Queue Plugin","text":"<pre><code>from collections import deque\nfrom tgcaller.plugins import BasePlugin\n\nclass MusicQueuePlugin(BasePlugin):\n    name = \"music_queue\"\n\n    def __init__(self, config=None):\n        super().__init__(config)\n        self.queues = {}  # chat_id -&gt; deque\n\n    def add_to_queue(self, chat_id, song):\n        \"\"\"Add song to queue\"\"\"\n        if chat_id not in self.queues:\n            self.queues[chat_id] = deque()\n\n        self.queues[chat_id].append(song)\n\n    def get_next_song(self, chat_id):\n        \"\"\"Get next song from queue\"\"\"\n        if chat_id in self.queues and self.queues[chat_id]:\n            return self.queues[chat_id].popleft()\n        return None\n\n    async def on_stream_end(self, chat_id):\n        \"\"\"Auto-play next song\"\"\"\n        next_song = self.get_next_song(chat_id)\n        if next_song:\n            await self.caller.play(chat_id, next_song)\n</code></pre>"},{"location":"plugins/#auto-moderator-plugin","title":"Auto-Moderator Plugin","text":"<pre><code>class AutoModeratorPlugin(BasePlugin):\n    name = \"auto_moderator\"\n\n    def __init__(self, config=None):\n        super().__init__(config)\n        self.max_users = config.get('max_users', 50) if config else 50\n        self.banned_users = set(config.get('banned_users', [])) if config else set()\n\n    async def on_user_joined(self, chat_id, user_id):\n        \"\"\"Check user when they join\"\"\"\n        # Check if user is banned\n        if user_id in self.banned_users:\n            await self.caller.kick_user(chat_id, user_id)\n            return\n\n        # Check user limit\n        active_users = await self.caller.get_call_participants(chat_id)\n        if len(active_users) &gt; self.max_users:\n            await self.caller.kick_user(chat_id, user_id)\n</code></pre>"},{"location":"plugins/#statistics-plugin","title":"Statistics Plugin","text":"<pre><code>import time\nfrom tgcaller.plugins import BasePlugin\n\nclass StatisticsPlugin(BasePlugin):\n    name = \"statistics\"\n\n    def __init__(self, config=None):\n        super().__init__(config)\n        self.stats = {\n            'total_calls': 0,\n            'total_duration': 0,\n            'streams_played': 0,\n            'users_served': set()\n        }\n        self.call_start_times = {}\n\n    async def on_call_start(self, chat_id):\n        \"\"\"Track call start\"\"\"\n        self.stats['total_calls'] += 1\n        self.call_start_times[chat_id] = time.time()\n\n    async def on_call_end(self, chat_id):\n        \"\"\"Track call end\"\"\"\n        if chat_id in self.call_start_times:\n            duration = time.time() - self.call_start_times[chat_id]\n            self.stats['total_duration'] += duration\n            del self.call_start_times[chat_id]\n\n    async def on_stream_start(self, chat_id, source):\n        \"\"\"Track stream\"\"\"\n        self.stats['streams_played'] += 1\n\n    async def on_user_joined(self, chat_id, user_id):\n        \"\"\"Track unique users\"\"\"\n        self.stats['users_served'].add(user_id)\n\n    def get_statistics(self):\n        \"\"\"Get current statistics\"\"\"\n        stats = self.stats.copy()\n        stats['unique_users'] = len(self.stats['users_served'])\n        stats['average_call_duration'] = (\n            self.stats['total_duration'] / max(self.stats['total_calls'], 1)\n        )\n        return stats\n</code></pre>"},{"location":"plugins/#plugin-best-practices","title":"Plugin Best Practices","text":""},{"location":"plugins/#1-error-handling","title":"1. Error Handling","text":"<pre><code>class SafePlugin(BasePlugin):\n    async def process_audio(self, audio_frame):\n        try:\n            # Your processing code\n            return processed_frame\n        except Exception as e:\n            self.logger.error(f\"Audio processing error: {e}\")\n            return audio_frame  # Return original on error\n</code></pre>"},{"location":"plugins/#2-performance-optimization","title":"2. Performance Optimization","text":"<pre><code>class OptimizedPlugin(BasePlugin):\n    def __init__(self, config=None):\n        super().__init__(config)\n        self.buffer_pool = []  # Reuse buffers\n        self.cache = {}  # Cache expensive operations\n\n    async def process_audio(self, audio_frame):\n        # Use object pooling for better performance\n        buffer = self.get_buffer()\n        try:\n            # Process audio\n            return processed_frame\n        finally:\n            self.return_buffer(buffer)\n</code></pre>"},{"location":"plugins/#3-configuration-validation","title":"3. Configuration Validation","text":"<pre><code>class ConfigurablePlugin(BasePlugin):\n    def __init__(self, config=None):\n        super().__init__(config)\n        self.validate_config()\n\n    def validate_config(self):\n        \"\"\"Validate plugin configuration\"\"\"\n        if self.config:\n            if 'required_setting' not in self.config:\n                raise ValueError(\"required_setting is missing\")\n\n            if not isinstance(self.config['required_setting'], int):\n                raise TypeError(\"required_setting must be an integer\")\n</code></pre>"},{"location":"plugins/#4-resource-cleanup","title":"4. Resource Cleanup","text":"<pre><code>class ResourcePlugin(BasePlugin):\n    def __init__(self, config=None):\n        super().__init__(config)\n        self.resources = []\n\n    async def on_load(self):\n        # Initialize resources\n        self.resources.append(SomeResource())\n\n    async def on_unload(self):\n        # Cleanup resources\n        for resource in self.resources:\n            await resource.cleanup()\n        self.resources.clear()\n</code></pre>"},{"location":"plugins/#plugin-testing","title":"Plugin Testing","text":"<pre><code>import pytest\nfrom unittest.mock import Mock\nfrom tgcaller.plugins import BasePlugin\n\nclass TestMyPlugin:\n    @pytest.fixture\n    def plugin(self):\n        config = {'test_setting': True}\n        return MyPlugin(config)\n\n    @pytest.mark.asyncio\n    async def test_audio_processing(self, plugin):\n        # Test audio processing\n        input_frame = np.random.random(1024)\n        output_frame = await plugin.process_audio(input_frame)\n\n        assert output_frame is not None\n        assert len(output_frame) == len(input_frame)\n\n    def test_configuration(self, plugin):\n        # Test configuration\n        assert plugin.config['test_setting'] is True\n</code></pre> <p>This plugin system allows you to extend TgCaller with custom functionality while maintaining clean separation of concerns and easy testing.</p>"},{"location":"usage/","title":"Usage Guide","text":""},{"location":"usage/#basic-usage","title":"Basic Usage","text":""},{"location":"usage/#setting-up-your-first-bot","title":"Setting Up Your First Bot","text":"<pre><code>import asyncio\nfrom pyrogram import Client\nfrom tgcaller import TgCaller\n\n# Your API credentials\nAPI_ID = 12345\nAPI_HASH = \"your_api_hash\"\nBOT_TOKEN = \"your_bot_token\"\n\n# Initialize Pyrogram client\napp = Client(\"my_bot\", api_id=API_ID, api_hash=API_HASH, bot_token=BOT_TOKEN)\n\n# Initialize TgCaller\ncaller = TgCaller(app)\n\nasync def main():\n    # Start TgCaller\n    await caller.start()\n\n    # Your bot logic here\n    chat_id = -1001234567890  # Your group chat ID\n\n    # Join voice call\n    await caller.join_call(chat_id)\n\n    # Play audio file\n    await caller.play(chat_id, \"song.mp3\")\n\n    # Keep running\n    await asyncio.Event().wait()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"usage/#audio-configuration","title":"Audio Configuration","text":""},{"location":"usage/#quality-presets","title":"Quality Presets","text":"<pre><code>from tgcaller import AudioConfig\n\n# High quality audio (128kbps, stereo, 48kHz)\naudio_config = AudioConfig.high_quality()\n\n# Low bandwidth audio (32kbps, mono, 24kHz)\naudio_config = AudioConfig.low_bandwidth()\n\n# Voice call optimized\naudio_config = AudioConfig.voice_call()\n</code></pre>"},{"location":"usage/#custom-audio-configuration","title":"Custom Audio Configuration","text":"<pre><code>audio_config = AudioConfig(\n    bitrate=128000,           # 128 kbps\n    sample_rate=48000,        # 48 kHz\n    channels=2,               # Stereo\n    noise_suppression=True,   # Clean audio\n    echo_cancellation=True    # No echo\n)\n\nawait caller.play(chat_id, \"song.mp3\", audio_config=audio_config)\n</code></pre>"},{"location":"usage/#video-configuration","title":"Video Configuration","text":""},{"location":"usage/#video-presets","title":"Video Presets","text":"<pre><code>from tgcaller import VideoConfig\n\n# HD 720p video\nvideo_config = VideoConfig.hd_720p()\n\n# Full HD 1080p video\nvideo_config = VideoConfig.full_hd_1080p()\n\n# Low quality for poor connections\nvideo_config = VideoConfig.low_quality()\n</code></pre>"},{"location":"usage/#custom-video-configuration","title":"Custom Video Configuration","text":"<pre><code>video_config = VideoConfig(\n    width=1920,\n    height=1080,\n    fps=30,\n    bitrate=2000000,          # 2 Mbps\n    codec=\"h264\"\n)\n\nawait caller.play(chat_id, \"video.mp4\", video_config=video_config)\n</code></pre>"},{"location":"usage/#event-handling","title":"Event Handling","text":""},{"location":"usage/#stream-events","title":"Stream Events","text":"<pre><code>@caller.on_stream_end\nasync def on_stream_end(client, update):\n    print(f\"Stream ended in {update.chat_id}\")\n    # Auto-play next song\n    await caller.play(update.chat_id, \"next_song.mp3\")\n\n@caller.on_stream_start\nasync def on_stream_start(client, update):\n    print(f\"Stream started in {update.chat_id}\")\n\n@caller.on_error\nasync def on_error(client, error):\n    print(f\"Error occurred: {error}\")\n</code></pre>"},{"location":"usage/#call-events","title":"Call Events","text":"<pre><code>@caller.on_kicked\nasync def on_kicked(client, update):\n    print(f\"Kicked from {update.chat_id}\")\n\n@caller.on_left\nasync def on_left(client, update):\n    print(f\"Left call {update.chat_id}\")\n</code></pre>"},{"location":"usage/#stream-control","title":"Stream Control","text":""},{"location":"usage/#basic-controls","title":"Basic Controls","text":"<pre><code># Pause stream\nawait caller.pause(chat_id)\n\n# Resume stream\nawait caller.resume(chat_id)\n\n# Stop stream\nawait caller.stop_stream(chat_id)\n\n# Set volume (0.0 to 1.0)\nawait caller.set_volume(chat_id, 0.8)\n\n# Seek to position (in seconds)\nawait caller.seek(chat_id, 60.0)\n\n# Get current position\nposition = await caller.get_position(chat_id)\n</code></pre>"},{"location":"usage/#music-bot-example","title":"Music Bot Example","text":"<pre><code>from pyrogram import Client, filters\nfrom tgcaller import TgCaller, AudioConfig\n\napp = Client(\"music_bot\")\ncaller = TgCaller(app)\n\n@app.on_message(filters.command(\"play\"))\nasync def play_music(client, message):\n    if len(message.command) &lt; 2:\n        return await message.reply(\"Usage: /play &lt;song_name&gt;\")\n\n    song = message.command[1]\n    chat_id = message.chat.id\n\n    # Join call if not already joined\n    if not caller.is_connected(chat_id):\n        await caller.join_call(chat_id)\n        await message.reply(\"\ud83d\udcde Joined voice chat!\")\n\n    # Play song\n    audio_config = AudioConfig.high_quality()\n    await caller.play(chat_id, f\"music/{song}.mp3\", audio_config=audio_config)\n    await message.reply(f\"\ud83c\udfb5 Playing: {song}\")\n\n@app.on_message(filters.command(\"pause\"))\nasync def pause_music(client, message):\n    if await caller.pause(message.chat.id):\n        await message.reply(\"\u23f8\ufe0f Music paused\")\n\n@app.on_message(filters.command(\"resume\"))\nasync def resume_music(client, message):\n    if await caller.resume(message.chat.id):\n        await message.reply(\"\u25b6\ufe0f Music resumed\")\n\n@app.on_message(filters.command(\"stop\"))\nasync def stop_music(client, message):\n    if await caller.stop_stream(message.chat.id):\n        await message.reply(\"\u23f9\ufe0f Music stopped\")\n\n@app.on_message(filters.command(\"leave\"))\nasync def leave_call(client, message):\n    if await caller.leave_call(message.chat.id):\n        await message.reply(\"\ud83d\udc4b Left voice chat\")\n\n@caller.on_stream_end\nasync def on_stream_end(client, update):\n    print(f\"Stream ended in {update.chat_id}\")\n\napp.run()\n</code></pre>"},{"location":"usage/#advanced-features","title":"Advanced Features","text":""},{"location":"usage/#youtube-streaming","title":"YouTube Streaming","text":"<pre><code>from tgcaller.advanced import YouTubeStreamer\n\nyoutube = YouTubeStreamer(caller)\n\n# Play YouTube video directly\nawait youtube.play_youtube_url(chat_id, \"https://youtube.com/watch?v=...\")\n\n# Search and play\nawait youtube.search_and_play(chat_id, \"relaxing music\", index=0)\n</code></pre>"},{"location":"usage/#screen-sharing","title":"Screen Sharing","text":"<pre><code>from tgcaller.advanced import ScreenShareStreamer\n\nscreen_streamer = ScreenShareStreamer(caller, chat_id)\n\n# Start screen sharing\nawait screen_streamer.start_streaming(monitor_index=1)\n\n# Stop screen sharing\nawait screen_streamer.stop_streaming()\n</code></pre>"},{"location":"usage/#microphone-streaming","title":"Microphone Streaming","text":"<pre><code>from tgcaller.advanced import MicrophoneStreamer\n\nmic_streamer = MicrophoneStreamer(caller, chat_id)\n\n# Start microphone streaming\nawait mic_streamer.start_streaming()\n\n# Stop microphone streaming\nawait mic_streamer.stop_streaming()\n</code></pre>"},{"location":"usage/#audio-filters","title":"Audio Filters","text":"<pre><code>from tgcaller.advanced import AudioFilters, FilterChain\n\n# Create filter chain\nfilter_chain = FilterChain()\naudio_filters = AudioFilters()\n\n# Add echo effect\nfilter_chain.add_audio_filter(\n    audio_filters.apply_echo,\n    delay=0.3,\n    decay=0.5\n)\n\n# Add reverb effect\nfilter_chain.add_audio_filter(\n    audio_filters.apply_reverb,\n    room_size=0.7,\n    damping=0.4\n)\n\n# Process audio through filters\nfiltered_audio = filter_chain.process_audio(audio_data)\n</code></pre>"},{"location":"usage/#error-handling","title":"Error Handling","text":"<pre><code>from tgcaller.exceptions import TgCallerError, ConnectionError, MediaError\n\ntry:\n    await caller.play(chat_id, \"song.mp3\")\nexcept MediaError as e:\n    print(f\"Media error: {e}\")\nexcept ConnectionError as e:\n    print(f\"Connection error: {e}\")\nexcept TgCallerError as e:\n    print(f\"TgCaller error: {e}\")\n</code></pre>"},{"location":"usage/#best-practices","title":"Best Practices","text":""},{"location":"usage/#1-always-handle-errors","title":"1. Always Handle Errors","text":"<pre><code>try:\n    await caller.join_call(chat_id)\nexcept Exception as e:\n    print(f\"Failed to join call: {e}\")\n</code></pre>"},{"location":"usage/#2-check-connection-status","title":"2. Check Connection Status","text":"<pre><code>if not caller.is_connected(chat_id):\n    await caller.join_call(chat_id)\n</code></pre>"},{"location":"usage/#3-cleanup-resources","title":"3. Cleanup Resources","text":"<pre><code>async def cleanup():\n    # Leave all calls\n    for chat_id in caller.get_active_calls():\n        await caller.leave_call(chat_id)\n\n    # Stop TgCaller\n    await caller.stop()\n</code></pre>"},{"location":"usage/#4-use-appropriate-quality-settings","title":"4. Use Appropriate Quality Settings","text":"<pre><code># For music streaming\naudio_config = AudioConfig.high_quality()\n\n# For voice calls\naudio_config = AudioConfig.voice_call()\n\n# For poor connections\naudio_config = AudioConfig.low_bandwidth()\n</code></pre>"},{"location":"c-api/advanced-methods/","title":"Advanced Methods","text":""},{"location":"c-api/advanced-methods/#screen-sharing","title":"Screen Sharing","text":""},{"location":"c-api/advanced-methods/#start-screen-sharing","title":"Start Screen Sharing","text":"<pre><code>#include \"tgcaller.h\"\n\n// Screen sharing configuration\nTgCallerScreenConfig screen_config = {\n    .monitor_index = 0,        // Primary monitor\n    .x = 0,                    // Capture from x=0\n    .y = 0,                    // Capture from y=0\n    .width = 1920,             // Capture width\n    .height = 1080,            // Capture height\n    .fps = 30,                 // 30 FPS\n    .quality = TGCALLER_QUALITY_HIGH\n};\n\n// Start screen sharing\nTgCallerError error = tgcaller_start_screen_share(caller, chat_id, &amp;screen_config);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Screen sharing started\\n\");\n} else {\n    fprintf(stderr, \"Failed to start screen sharing: %s\\n\", tgcaller_error_string(error));\n}\n</code></pre>"},{"location":"c-api/advanced-methods/#stop-screen-sharing","title":"Stop Screen Sharing","text":"<pre><code>// Stop screen sharing\nTgCallerError error = tgcaller_stop_screen_share(caller, chat_id);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Screen sharing stopped\\n\");\n}\n</code></pre>"},{"location":"c-api/advanced-methods/#list-available-monitors","title":"List Available Monitors","text":"<pre><code>// Get available monitors\nTgCallerMonitorInfo* monitors = NULL;\nsize_t monitor_count = 0;\n\nTgCallerError error = tgcaller_get_monitors(&amp;monitors, &amp;monitor_count);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Available monitors (%zu):\\n\", monitor_count);\n\n    for (size_t i = 0; i &lt; monitor_count; i++) {\n        printf(\"  Monitor %zu: %dx%d at (%d, %d)\\n\",\n               i,\n               monitors[i].width,\n               monitors[i].height,\n               monitors[i].x,\n               monitors[i].y);\n    }\n\n    // Free the allocated memory\n    free(monitors);\n} else {\n    fprintf(stderr, \"Failed to get monitors: %s\\n\", tgcaller_error_string(error));\n}\n</code></pre>"},{"location":"c-api/advanced-methods/#microphone-streaming","title":"Microphone Streaming","text":""},{"location":"c-api/advanced-methods/#start-microphone-stream","title":"Start Microphone Stream","text":"<pre><code>// Microphone configuration\nTgCallerMicConfig mic_config = {\n    .device_index = -1,        // Default device\n    .sample_rate = 48000,      // 48 kHz\n    .channels = 1,             // Mono\n    .noise_suppression = true,\n    .echo_cancellation = true,\n    .auto_gain_control = true\n};\n\n// Start microphone streaming\nTgCallerError error = tgcaller_start_microphone(caller, chat_id, &amp;mic_config);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Microphone streaming started\\n\");\n} else {\n    fprintf(stderr, \"Failed to start microphone: %s\\n\", tgcaller_error_string(error));\n}\n</code></pre>"},{"location":"c-api/advanced-methods/#stop-microphone-stream","title":"Stop Microphone Stream","text":"<pre><code>// Stop microphone streaming\nTgCallerError error = tgcaller_stop_microphone(caller, chat_id);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Microphone streaming stopped\\n\");\n}\n</code></pre>"},{"location":"c-api/advanced-methods/#list-audio-devices","title":"List Audio Devices","text":"<pre><code>// Get available audio input devices\nTgCallerAudioDevice* devices = NULL;\nsize_t device_count = 0;\n\nTgCallerError error = tgcaller_get_audio_devices(&amp;devices, &amp;device_count);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Available audio devices (%zu):\\n\", device_count);\n\n    for (size_t i = 0; i &lt; device_count; i++) {\n        printf(\"  Device %d: %s (%d channels, %.0f Hz)\\n\",\n               devices[i].index,\n               devices[i].name,\n               devices[i].max_channels,\n               devices[i].default_sample_rate);\n    }\n\n    // Free the allocated memory\n    free(devices);\n} else {\n    fprintf(stderr, \"Failed to get audio devices: %s\\n\", tgcaller_error_string(error));\n}\n</code></pre>"},{"location":"c-api/advanced-methods/#youtube-integration","title":"YouTube Integration","text":""},{"location":"c-api/advanced-methods/#play-youtube-video","title":"Play YouTube Video","text":"<pre><code>// Play YouTube video directly\nconst char* youtube_url = \"https://www.youtube.com/watch?v=dQw4w9WgXcQ\";\n\nTgCallerError error = tgcaller_play_youtube(caller, chat_id, youtube_url);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Started playing YouTube video\\n\");\n} else {\n    fprintf(stderr, \"Failed to play YouTube video: %s\\n\", tgcaller_error_string(error));\n}\n</code></pre>"},{"location":"c-api/advanced-methods/#search-and-play-youtube","title":"Search and Play YouTube","text":"<pre><code>// Search YouTube and play first result\nconst char* search_query = \"relaxing music\";\n\nTgCallerError error = tgcaller_search_and_play_youtube(caller, chat_id, search_query);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Started playing YouTube search result\\n\");\n} else {\n    fprintf(stderr, \"Failed to search and play: %s\\n\", tgcaller_error_string(error));\n}\n</code></pre>"},{"location":"c-api/advanced-methods/#get-youtube-video-info","title":"Get YouTube Video Info","text":"<pre><code>// Get video information\nTgCallerYouTubeInfo video_info;\nconst char* youtube_url = \"https://www.youtube.com/watch?v=dQw4w9WgXcQ\";\n\nTgCallerError error = tgcaller_get_youtube_info(youtube_url, &amp;video_info);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Video Info:\\n\");\n    printf(\"  Title: %s\\n\", video_info.title);\n    printf(\"  Duration: %d seconds\\n\", video_info.duration);\n    printf(\"  Uploader: %s\\n\", video_info.uploader);\n    printf(\"  Views: %lld\\n\", video_info.view_count);\n\n    // Free allocated strings\n    free(video_info.title);\n    free(video_info.uploader);\n} else {\n    fprintf(stderr, \"Failed to get video info: %s\\n\", tgcaller_error_string(error));\n}\n</code></pre>"},{"location":"c-api/advanced-methods/#speech-transcription","title":"Speech Transcription","text":""},{"location":"c-api/advanced-methods/#start-transcription","title":"Start Transcription","text":"<pre><code>// Transcription configuration\nTgCallerTranscriptionConfig transcription_config = {\n    .model = TGCALLER_WHISPER_BASE,    // Whisper model\n    .language = \"en\",                   // Language (NULL for auto-detect)\n    .real_time = true,                  // Real-time transcription\n    .confidence_threshold = 0.5f        // Minimum confidence\n};\n\n// Transcription callback\nvoid transcription_callback(const char* text, float confidence, void* user_data) {\n    printf(\"Transcription (%.1f%%): %s\\n\", confidence * 100, text);\n}\n\n// Start transcription\nTgCallerError error = tgcaller_start_transcription(\n    caller, \n    chat_id, \n    &amp;transcription_config,\n    transcription_callback,\n    NULL  // user_data\n);\n\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Transcription started\\n\");\n} else {\n    fprintf(stderr, \"Failed to start transcription: %s\\n\", tgcaller_error_string(error));\n}\n</code></pre>"},{"location":"c-api/advanced-methods/#stop-transcription","title":"Stop Transcription","text":"<pre><code>// Stop transcription\nTgCallerError error = tgcaller_stop_transcription(caller, chat_id);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Transcription stopped\\n\");\n}\n</code></pre>"},{"location":"c-api/advanced-methods/#transcribe-audio-file","title":"Transcribe Audio File","text":"<pre><code>// Transcribe audio file\nTgCallerTranscriptionResult result;\nconst char* audio_file = \"speech.wav\";\n\nTgCallerError error = tgcaller_transcribe_file(audio_file, \"en\", &amp;result);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Transcription Result:\\n\");\n    printf(\"  Text: %s\\n\", result.text);\n    printf(\"  Language: %s\\n\", result.language);\n    printf(\"  Confidence: %.1f%%\\n\", result.confidence * 100);\n    printf(\"  Duration: %.1f seconds\\n\", result.duration);\n\n    // Free allocated strings\n    free(result.text);\n    free(result.language);\n} else {\n    fprintf(stderr, \"Failed to transcribe file: %s\\n\", tgcaller_error_string(error));\n}\n</code></pre>"},{"location":"c-api/advanced-methods/#audiovideo-filters","title":"Audio/Video Filters","text":""},{"location":"c-api/advanced-methods/#apply-audio-filters","title":"Apply Audio Filters","text":"<pre><code>// Audio filter configuration\nTgCallerAudioFilter audio_filter = {\n    .type = TGCALLER_FILTER_ECHO,\n    .parameters = {\n        .echo = {\n            .delay = 0.3f,      // 300ms delay\n            .decay = 0.5f       // 50% decay\n        }\n    }\n};\n\n// Apply audio filter\nTgCallerError error = tgcaller_add_audio_filter(caller, chat_id, &amp;audio_filter);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Audio filter applied\\n\");\n} else {\n    fprintf(stderr, \"Failed to apply audio filter: %s\\n\", tgcaller_error_string(error));\n}\n</code></pre>"},{"location":"c-api/advanced-methods/#apply-video-filters","title":"Apply Video Filters","text":"<pre><code>// Video filter configuration\nTgCallerVideoFilter video_filter = {\n    .type = TGCALLER_FILTER_BLUR,\n    .parameters = {\n        .blur = {\n            .kernel_size = 15   // Blur intensity\n        }\n    }\n};\n\n// Apply video filter\nTgCallerError error = tgcaller_add_video_filter(caller, chat_id, &amp;video_filter);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Video filter applied\\n\");\n} else {\n    fprintf(stderr, \"Failed to apply video filter: %s\\n\", tgcaller_error_string(error));\n}\n</code></pre>"},{"location":"c-api/advanced-methods/#remove-filters","title":"Remove Filters","text":"<pre><code>// Remove all audio filters\nTgCallerError error = tgcaller_clear_audio_filters(caller, chat_id);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Audio filters cleared\\n\");\n}\n\n// Remove all video filters\nerror = tgcaller_clear_video_filters(caller, chat_id);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Video filters cleared\\n\");\n}\n</code></pre>"},{"location":"c-api/advanced-methods/#bridged-calls","title":"Bridged Calls","text":""},{"location":"c-api/advanced-methods/#create-bridge","title":"Create Bridge","text":"<pre><code>// Create bridge between multiple chats\nint64_t chat_ids[] = {-1001234567890, -1009876543210, -1001122334455};\nsize_t chat_count = 3;\n\nTgCallerError error = tgcaller_create_bridge(caller, \"conference\", chat_ids, chat_count);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Bridge created successfully\\n\");\n} else {\n    fprintf(stderr, \"Failed to create bridge: %s\\n\", tgcaller_error_string(error));\n}\n</code></pre>"},{"location":"c-api/advanced-methods/#destroy-bridge","title":"Destroy Bridge","text":"<pre><code>// Destroy bridge\nTgCallerError error = tgcaller_destroy_bridge(caller, \"conference\");\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Bridge destroyed\\n\");\n}\n</code></pre>"},{"location":"c-api/advanced-methods/#add-chat-to-bridge","title":"Add Chat to Bridge","text":"<pre><code>// Add chat to existing bridge\nint64_t new_chat_id = -1005566778899;\n\nTgCallerError error = tgcaller_bridge_add_chat(caller, \"conference\", new_chat_id);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Chat added to bridge\\n\");\n}\n</code></pre>"},{"location":"c-api/advanced-methods/#plugin-system","title":"Plugin System","text":""},{"location":"c-api/advanced-methods/#load-plugin","title":"Load Plugin","text":"<pre><code>// Load plugin from shared library\nconst char* plugin_path = \"./plugins/echo_plugin.so\";\n\nTgCallerError error = tgcaller_load_plugin(caller, plugin_path);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Plugin loaded successfully\\n\");\n} else {\n    fprintf(stderr, \"Failed to load plugin: %s\\n\", tgcaller_error_string(error));\n}\n</code></pre>"},{"location":"c-api/advanced-methods/#unload-plugin","title":"Unload Plugin","text":"<pre><code>// Unload plugin\nTgCallerError error = tgcaller_unload_plugin(caller, \"echo_plugin\");\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Plugin unloaded\\n\");\n}\n</code></pre>"},{"location":"c-api/advanced-methods/#list-loaded-plugins","title":"List Loaded Plugins","text":"<pre><code>// Get list of loaded plugins\nchar** plugin_names = NULL;\nsize_t plugin_count = 0;\n\nTgCallerError error = tgcaller_get_loaded_plugins(caller, &amp;plugin_names, &amp;plugin_count);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Loaded plugins (%zu):\\n\", plugin_count);\n\n    for (size_t i = 0; i &lt; plugin_count; i++) {\n        printf(\"  %s\\n\", plugin_names[i]);\n        free(plugin_names[i]);  // Free individual strings\n    }\n\n    free(plugin_names);  // Free array\n} else {\n    fprintf(stderr, \"Failed to get loaded plugins: %s\\n\", tgcaller_error_string(error));\n}\n</code></pre>"},{"location":"c-api/advanced-methods/#complete-advanced-example","title":"Complete Advanced Example","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#include \"tgcaller.h\"\n\nvoid transcription_callback(const char* text, float confidence, void* user_data) {\n    printf(\"\ud83c\udfa4 Transcription (%.1f%%): %s\\n\", confidence * 100, text);\n}\n\nint main() {\n    TgCaller* caller = tgcaller_create();\n    if (!caller) return -1;\n\n    // Setup and start\n    tgcaller_set_credentials(caller, 12345, \"api_hash\");\n    tgcaller_start(caller);\n\n    int64_t chat_id = -1001234567890;\n\n    // Join call\n    tgcaller_join_call(caller, chat_id);\n\n    // Start screen sharing\n    TgCallerScreenConfig screen_config = {\n        .monitor_index = 0,\n        .fps = 30,\n        .quality = TGCALLER_QUALITY_HIGH\n    };\n    tgcaller_start_screen_share(caller, chat_id, &amp;screen_config);\n\n    // Start transcription\n    TgCallerTranscriptionConfig transcription_config = {\n        .model = TGCALLER_WHISPER_BASE,\n        .language = \"en\",\n        .real_time = true,\n        .confidence_threshold = 0.7f\n    };\n    tgcaller_start_transcription(caller, chat_id, &amp;transcription_config, transcription_callback, NULL);\n\n    // Apply audio filter\n    TgCallerAudioFilter echo_filter = {\n        .type = TGCALLER_FILTER_ECHO,\n        .parameters.echo = { .delay = 0.3f, .decay = 0.4f }\n    };\n    tgcaller_add_audio_filter(caller, chat_id, &amp;echo_filter);\n\n    // Run for 60 seconds\n    sleep(60);\n\n    // Cleanup\n    tgcaller_stop_screen_share(caller, chat_id);\n    tgcaller_stop_transcription(caller, chat_id);\n    tgcaller_clear_audio_filters(caller, chat_id);\n    tgcaller_leave_call(caller, chat_id);\n    tgcaller_stop(caller);\n    tgcaller_destroy(caller);\n\n    return 0;\n}\n</code></pre>"},{"location":"c-api/async/","title":"Using Async","text":""},{"location":"c-api/async/#asynchronous-operations","title":"Asynchronous Operations","text":"<p>TgCaller C API supports asynchronous operations for non-blocking execution.</p>"},{"location":"c-api/async/#async-callbacks","title":"Async Callbacks","text":"<pre><code>#include \"tgcaller.h\"\n\n// Async callback for stream operations\nvoid stream_callback(TgCallerResult result, void* user_data) {\n    if (result.success) {\n        printf(\"Stream operation completed successfully\\n\");\n    } else {\n        printf(\"Stream operation failed: %s\\n\", result.error_message);\n    }\n}\n\n// Start async stream\nTgCallerError error = tgcaller_play_async(\n    caller,\n    chat_id,\n    \"audio.mp3\",\n    stream_callback,\n    NULL  // user_data\n);\n</code></pre>"},{"location":"c-api/async/#event-loop-integration","title":"Event Loop Integration","text":"<pre><code>// Run event loop\nwhile (tgcaller_is_running(caller)) {\n    tgcaller_process_events(caller);\n    usleep(1000);  // 1ms delay\n}\n</code></pre>"},{"location":"c-api/async/#thread-safety","title":"Thread Safety","text":"<pre><code>#include &lt;pthread.h&gt;\n\npthread_mutex_t tgcaller_mutex = PTHREAD_MUTEX_INITIALIZER;\n\nvoid thread_safe_operation() {\n    pthread_mutex_lock(&amp;tgcaller_mutex);\n\n    // TgCaller operations here\n    tgcaller_join_call(caller, chat_id);\n\n    pthread_mutex_unlock(&amp;tgcaller_mutex);\n}\n</code></pre>"},{"location":"c-api/async/#async-examples","title":"Async Examples","text":""},{"location":"c-api/async/#async-file-playing","title":"Async File Playing","text":"<pre><code>typedef struct {\n    char* filename;\n    int chat_id;\n} PlayContext;\n\nvoid play_complete_callback(TgCallerResult result, void* user_data) {\n    PlayContext* ctx = (PlayContext*)user_data;\n\n    if (result.success) {\n        printf(\"Finished playing: %s in chat %d\\n\", ctx-&gt;filename, ctx-&gt;chat_id);\n    }\n\n    free(ctx-&gt;filename);\n    free(ctx);\n}\n\nvoid play_file_async(TgCaller* caller, int chat_id, const char* filename) {\n    PlayContext* ctx = malloc(sizeof(PlayContext));\n    ctx-&gt;filename = strdup(filename);\n    ctx-&gt;chat_id = chat_id;\n\n    tgcaller_play_async(caller, chat_id, filename, play_complete_callback, ctx);\n}\n</code></pre>"},{"location":"c-api/async/#async-queue-management","title":"Async Queue Management","text":"<pre><code>typedef struct {\n    char** queue;\n    int count;\n    int current;\n} PlayQueue;\n\nvoid queue_next_callback(TgCallerResult result, void* user_data) {\n    PlayQueue* queue = (PlayQueue*)user_data;\n\n    if (result.success &amp;&amp; queue-&gt;current &lt; queue-&gt;count - 1) {\n        queue-&gt;current++;\n        tgcaller_play_async(\n            caller, \n            chat_id, \n            queue-&gt;queue[queue-&gt;current],\n            queue_next_callback,\n            queue\n        );\n    }\n}\n</code></pre>"},{"location":"c-api/basic-methods/","title":"Basic Methods","text":""},{"location":"c-api/basic-methods/#core-functions","title":"Core Functions","text":""},{"location":"c-api/basic-methods/#initialize-tgcaller","title":"Initialize TgCaller","text":"<pre><code>#include \"tgcaller.h\"\n\nTgCaller* caller = tgcaller_create();\nif (!caller) {\n    fprintf(stderr, \"Failed to create TgCaller instance\\n\");\n    return -1;\n}\n\n// Set API credentials\nTgCallerError error = tgcaller_set_credentials(caller, api_id, \"api_hash\");\nif (error != TGCALLER_SUCCESS) {\n    fprintf(stderr, \"Failed to set credentials: %s\\n\", tgcaller_error_string(error));\n    tgcaller_destroy(caller);\n    return -1;\n}\n</code></pre>"},{"location":"c-api/basic-methods/#start-tgcaller","title":"Start TgCaller","text":"<pre><code>// Start the service\nTgCallerError error = tgcaller_start(caller);\nif (error != TGCALLER_SUCCESS) {\n    fprintf(stderr, \"Failed to start TgCaller: %s\\n\", tgcaller_error_string(error));\n    return -1;\n}\n\nprintf(\"TgCaller started successfully\\n\");\n</code></pre>"},{"location":"c-api/basic-methods/#stop-tgcaller","title":"Stop TgCaller","text":"<pre><code>// Stop the service\nTgCallerError error = tgcaller_stop(caller);\nif (error != TGCALLER_SUCCESS) {\n    fprintf(stderr, \"Failed to stop TgCaller: %s\\n\", tgcaller_error_string(error));\n}\n\n// Cleanup\ntgcaller_destroy(caller);\n</code></pre>"},{"location":"c-api/basic-methods/#call-management","title":"Call Management","text":""},{"location":"c-api/basic-methods/#join-call","title":"Join Call","text":"<pre><code>// Join a voice call\nint64_t chat_id = -1001234567890;\nTgCallerError error = tgcaller_join_call(caller, chat_id);\n\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Successfully joined call in chat %lld\\n\", chat_id);\n} else {\n    fprintf(stderr, \"Failed to join call: %s\\n\", tgcaller_error_string(error));\n}\n</code></pre>"},{"location":"c-api/basic-methods/#leave-call","title":"Leave Call","text":"<pre><code>// Leave the call\nTgCallerError error = tgcaller_leave_call(caller, chat_id);\n\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Successfully left call in chat %lld\\n\", chat_id);\n} else {\n    fprintf(stderr, \"Failed to leave call: %s\\n\", tgcaller_error_string(error));\n}\n</code></pre>"},{"location":"c-api/basic-methods/#check-connection-status","title":"Check Connection Status","text":"<pre><code>// Check if connected to a specific call\nbool is_connected = tgcaller_is_connected(caller, chat_id);\nif (is_connected) {\n    printf(\"Connected to call in chat %lld\\n\", chat_id);\n} else {\n    printf(\"Not connected to call in chat %lld\\n\", chat_id);\n}\n\n// Check if TgCaller service is running\nbool is_running = tgcaller_is_running(caller);\nif (is_running) {\n    printf(\"TgCaller service is running\\n\");\n} else {\n    printf(\"TgCaller service is not running\\n\");\n}\n</code></pre>"},{"location":"c-api/basic-methods/#configuration","title":"Configuration","text":""},{"location":"c-api/basic-methods/#audio-configuration","title":"Audio Configuration","text":"<pre><code>// Create audio configuration\nTgCallerAudioConfig audio_config = {\n    .bitrate = 128000,        // 128 kbps\n    .sample_rate = 48000,     // 48 kHz\n    .channels = 2,            // Stereo\n    .codec = TGCALLER_CODEC_OPUS,\n    .noise_suppression = true,\n    .echo_cancellation = true\n};\n\n// Apply configuration\nTgCallerError error = tgcaller_set_audio_config(caller, &amp;audio_config);\nif (error != TGCALLER_SUCCESS) {\n    fprintf(stderr, \"Failed to set audio config: %s\\n\", tgcaller_error_string(error));\n}\n</code></pre>"},{"location":"c-api/basic-methods/#video-configuration","title":"Video Configuration","text":"<pre><code>// Create video configuration\nTgCallerVideoConfig video_config = {\n    .width = 1280,\n    .height = 720,\n    .fps = 30,\n    .bitrate = 1500000,       // 1.5 Mbps\n    .codec = TGCALLER_CODEC_H264,\n    .hardware_acceleration = true\n};\n\n// Apply configuration\nTgCallerError error = tgcaller_set_video_config(caller, &amp;video_config);\nif (error != TGCALLER_SUCCESS) {\n    fprintf(stderr, \"Failed to set video config: %s\\n\", tgcaller_error_string(error));\n}\n</code></pre>"},{"location":"c-api/basic-methods/#error-handling","title":"Error Handling","text":""},{"location":"c-api/basic-methods/#error-codes","title":"Error Codes","text":"<pre><code>// Check specific error types\nTgCallerError error = tgcaller_join_call(caller, chat_id);\n\nswitch (error) {\n    case TGCALLER_SUCCESS:\n        printf(\"Operation successful\\n\");\n        break;\n    case TGCALLER_ERROR_NOT_CONNECTED:\n        fprintf(stderr, \"Not connected to Telegram\\n\");\n        break;\n    case TGCALLER_ERROR_INVALID_CHAT:\n        fprintf(stderr, \"Invalid chat ID\\n\");\n        break;\n    case TGCALLER_ERROR_ALREADY_IN_CALL:\n        fprintf(stderr, \"Already in call\\n\");\n        break;\n    default:\n        fprintf(stderr, \"Unknown error: %s\\n\", tgcaller_error_string(error));\n        break;\n}\n</code></pre>"},{"location":"c-api/basic-methods/#error-messages","title":"Error Messages","text":"<pre><code>// Get human-readable error message\nconst char* error_message = tgcaller_error_string(error);\nprintf(\"Error: %s\\n\", error_message);\n\n// Get last error\nTgCallerError last_error = tgcaller_get_last_error(caller);\nif (last_error != TGCALLER_SUCCESS) {\n    fprintf(stderr, \"Last error: %s\\n\", tgcaller_error_string(last_error));\n}\n</code></pre>"},{"location":"c-api/basic-methods/#utility-functions","title":"Utility Functions","text":""},{"location":"c-api/basic-methods/#get-active-calls","title":"Get Active Calls","text":"<pre><code>// Get list of active calls\nint64_t* active_calls = NULL;\nsize_t count = 0;\n\nTgCallerError error = tgcaller_get_active_calls(caller, &amp;active_calls, &amp;count);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Active calls (%zu):\\n\", count);\n    for (size_t i = 0; i &lt; count; i++) {\n        printf(\"  Chat ID: %lld\\n\", active_calls[i]);\n    }\n\n    // Free the allocated memory\n    free(active_calls);\n} else {\n    fprintf(stderr, \"Failed to get active calls: %s\\n\", tgcaller_error_string(error));\n}\n</code></pre>"},{"location":"c-api/basic-methods/#get-version","title":"Get Version","text":"<pre><code>// Get TgCaller version\nconst char* version = tgcaller_get_version();\nprintf(\"TgCaller version: %s\\n\", version);\n\n// Get build information\nconst char* build_info = tgcaller_get_build_info();\nprintf(\"Build info: %s\\n\", build_info);\n</code></pre>"},{"location":"c-api/basic-methods/#complete-example","title":"Complete Example","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#include \"tgcaller.h\"\n\nint main() {\n    // Create TgCaller instance\n    TgCaller* caller = tgcaller_create();\n    if (!caller) {\n        fprintf(stderr, \"Failed to create TgCaller\\n\");\n        return -1;\n    }\n\n    // Set credentials\n    int api_id = 12345;\n    const char* api_hash = \"your_api_hash\";\n\n    TgCallerError error = tgcaller_set_credentials(caller, api_id, api_hash);\n    if (error != TGCALLER_SUCCESS) {\n        fprintf(stderr, \"Failed to set credentials\\n\");\n        tgcaller_destroy(caller);\n        return -1;\n    }\n\n    // Start TgCaller\n    error = tgcaller_start(caller);\n    if (error != TGCALLER_SUCCESS) {\n        fprintf(stderr, \"Failed to start TgCaller\\n\");\n        tgcaller_destroy(caller);\n        return -1;\n    }\n\n    // Join call\n    int64_t chat_id = -1001234567890;\n    error = tgcaller_join_call(caller, chat_id);\n    if (error == TGCALLER_SUCCESS) {\n        printf(\"Joined call successfully\\n\");\n\n        // Wait for 10 seconds\n        sleep(10);\n\n        // Leave call\n        tgcaller_leave_call(caller, chat_id);\n        printf(\"Left call\\n\");\n    }\n\n    // Stop and cleanup\n    tgcaller_stop(caller);\n    tgcaller_destroy(caller);\n\n    return 0;\n}\n</code></pre>"},{"location":"c-api/enums/","title":"Available Enums","text":""},{"location":"c-api/enums/#error-codes","title":"Error Codes","text":""},{"location":"c-api/enums/#tgcallererror","title":"TgCallerError","text":"<pre><code>typedef enum {\n    TGCALLER_SUCCESS = 0,                    // Operation successful\n    TGCALLER_ERROR_INVALID_PARAMETER,       // Invalid parameter passed\n    TGCALLER_ERROR_NOT_INITIALIZED,         // TgCaller not initialized\n    TGCALLER_ERROR_NOT_CONNECTED,           // Not connected to Telegram\n    TGCALLER_ERROR_ALREADY_CONNECTED,       // Already connected\n    TGCALLER_ERROR_CONNECTION_FAILED,       // Connection failed\n    TGCALLER_ERROR_INVALID_CHAT,            // Invalid chat ID\n    TGCALLER_ERROR_ALREADY_IN_CALL,         // Already in call\n    TGCALLER_ERROR_NOT_IN_CALL,             // Not in call\n    TGCALLER_ERROR_CALL_FAILED,             // Call operation failed\n    TGCALLER_ERROR_STREAM_FAILED,           // Stream operation failed\n    TGCALLER_ERROR_FILE_NOT_FOUND,          // Media file not found\n    TGCALLER_ERROR_INVALID_FORMAT,          // Invalid media format\n    TGCALLER_ERROR_CODEC_ERROR,             // Codec error\n    TGCALLER_ERROR_DEVICE_ERROR,            // Audio/video device error\n    TGCALLER_ERROR_PERMISSION_DENIED,       // Permission denied\n    TGCALLER_ERROR_NETWORK_ERROR,           // Network error\n    TGCALLER_ERROR_TIMEOUT,                 // Operation timeout\n    TGCALLER_ERROR_OUT_OF_MEMORY,           // Out of memory\n    TGCALLER_ERROR_UNKNOWN                  // Unknown error\n} TgCallerError;\n\n// Get error string\nconst char* tgcaller_error_string(TgCallerError error);\n</code></pre>"},{"location":"c-api/enums/#stream-status","title":"Stream Status","text":""},{"location":"c-api/enums/#tgcallerstreamstatus","title":"TgCallerStreamStatus","text":"<pre><code>typedef enum {\n    TGCALLER_STREAM_IDLE,           // No active stream\n    TGCALLER_STREAM_LOADING,        // Loading stream\n    TGCALLER_STREAM_PLAYING,        // Stream is playing\n    TGCALLER_STREAM_PAUSED,         // Stream is paused\n    TGCALLER_STREAM_STOPPED,        // Stream is stopped\n    TGCALLER_STREAM_ERROR           // Stream error\n} TgCallerStreamStatus;\n\n// Get stream status\nTgCallerError tgcaller_get_stream_status(TgCaller* caller, int64_t chat_id, TgCallerStreamStatus* status);\n</code></pre>"},{"location":"c-api/enums/#call-status","title":"Call Status","text":""},{"location":"c-api/enums/#tgcallercallstatus","title":"TgCallerCallStatus","text":"<pre><code>typedef enum {\n    TGCALLER_CALL_IDLE,             // Not in call\n    TGCALLER_CALL_CONNECTING,       // Connecting to call\n    TGCALLER_CALL_CONNECTED,        // Connected to call\n    TGCALLER_CALL_DISCONNECTING,    // Disconnecting from call\n    TGCALLER_CALL_ERROR             // Call error\n} TgCallerCallStatus;\n\n// Get call status\nTgCallerError tgcaller_get_call_status(TgCaller* caller, int64_t chat_id, TgCallerCallStatus* status);\n</code></pre>"},{"location":"c-api/enums/#codecs","title":"Codecs","text":""},{"location":"c-api/enums/#tgcallercodec","title":"TgCallerCodec","text":"<pre><code>typedef enum {\n    // Audio codecs\n    TGCALLER_CODEC_OPUS,            // Opus codec (recommended for audio)\n    TGCALLER_CODEC_AAC,             // AAC codec\n    TGCALLER_CODEC_MP3,             // MP3 codec\n    TGCALLER_CODEC_PCM,             // Raw PCM\n\n    // Video codecs\n    TGCALLER_CODEC_H264,            // H.264 codec (recommended for video)\n    TGCALLER_CODEC_VP8,             // VP8 codec\n    TGCALLER_CODEC_VP9,             // VP9 codec\n    TGCALLER_CODEC_AV1              // AV1 codec\n} TgCallerCodec;\n</code></pre>"},{"location":"c-api/enums/#media-formats","title":"Media Formats","text":""},{"location":"c-api/enums/#tgcallerformat","title":"TgCallerFormat","text":"<pre><code>typedef enum {\n    TGCALLER_FORMAT_PCM,            // Raw PCM audio\n    TGCALLER_FORMAT_MP3,            // MP3 audio\n    TGCALLER_FORMAT_WAV,            // WAV audio\n    TGCALLER_FORMAT_OGG,            // OGG audio\n    TGCALLER_FORMAT_FLAC,           // FLAC audio\n    TGCALLER_FORMAT_AAC,            // AAC audio\n    TGCALLER_FORMAT_MP4,            // MP4 video\n    TGCALLER_FORMAT_AVI,            // AVI video\n    TGCALLER_FORMAT_MKV,            // MKV video\n    TGCALLER_FORMAT_WEBM,           // WebM video\n    TGCALLER_FORMAT_MOV             // MOV video\n} TgCallerFormat;\n</code></pre>"},{"location":"c-api/enums/#quality-presets","title":"Quality Presets","text":""},{"location":"c-api/enums/#tgcallerquality","title":"TgCallerQuality","text":"<pre><code>typedef enum {\n    TGCALLER_QUALITY_LOW,           // Low quality (bandwidth optimized)\n    TGCALLER_QUALITY_MEDIUM,        // Medium quality (balanced)\n    TGCALLER_QUALITY_HIGH,          // High quality (quality optimized)\n    TGCALLER_QUALITY_ULTRA,         // Ultra quality (maximum quality)\n    TGCALLER_QUALITY_CUSTOM         // Custom quality (use specific config)\n} TgCallerQuality;\n</code></pre>"},{"location":"c-api/enums/#repeat-modes","title":"Repeat Modes","text":""},{"location":"c-api/enums/#tgcallerrepeatmode","title":"TgCallerRepeatMode","text":"<pre><code>typedef enum {\n    TGCALLER_REPEAT_NONE,           // No repeat\n    TGCALLER_REPEAT_ONE,            // Repeat current track\n    TGCALLER_REPEAT_ALL             // Repeat all tracks in queue\n} TgCallerRepeatMode;\n\n// Set repeat mode\nTgCallerError tgcaller_set_repeat_mode(TgCaller* caller, int64_t chat_id, TgCallerRepeatMode mode);\n\n// Get repeat mode\nTgCallerError tgcaller_get_repeat_mode(TgCaller* caller, int64_t chat_id, TgCallerRepeatMode* mode);\n</code></pre>"},{"location":"c-api/enums/#event-types","title":"Event Types","text":""},{"location":"c-api/enums/#tgcallerstreameventtype","title":"TgCallerStreamEventType","text":"<pre><code>typedef enum {\n    TGCALLER_STREAM_STARTED,        // Stream started\n    TGCALLER_STREAM_ENDED,          // Stream ended\n    TGCALLER_STREAM_PAUSED,         // Stream paused\n    TGCALLER_STREAM_RESUMED,        // Stream resumed\n    TGCALLER_STREAM_POSITION,       // Position changed\n    TGCALLER_STREAM_ERROR           // Stream error\n} TgCallerStreamEventType;\n</code></pre>"},{"location":"c-api/enums/#tgcallercalleventtype","title":"TgCallerCallEventType","text":"<pre><code>typedef enum {\n    TGCALLER_CALL_JOINED,           // Joined call\n    TGCALLER_CALL_LEFT,             // Left call\n    TGCALLER_CALL_USER_JOINED,      // User joined call\n    TGCALLER_CALL_USER_LEFT,        // User left call\n    TGCALLER_CALL_KICKED,           // Kicked from call\n    TGCALLER_CALL_ERROR             // Call error\n} TgCallerCallEventType;\n</code></pre>"},{"location":"c-api/enums/#filter-types","title":"Filter Types","text":""},{"location":"c-api/enums/#tgcallerfiltertype","title":"TgCallerFilterType","text":"<pre><code>typedef enum {\n    // Audio filters\n    TGCALLER_FILTER_ECHO,           // Echo effect\n    TGCALLER_FILTER_REVERB,         // Reverb effect\n    TGCALLER_FILTER_PITCH_SHIFT,    // Pitch shifting\n    TGCALLER_FILTER_DISTORTION,     // Distortion effect\n    TGCALLER_FILTER_NOISE_GATE,     // Noise gate\n    TGCALLER_FILTER_COMPRESSOR,     // Audio compressor\n    TGCALLER_FILTER_EQUALIZER,      // Equalizer\n\n    // Video filters\n    TGCALLER_FILTER_BLUR,           // Blur effect\n    TGCALLER_FILTER_SHARPEN,        // Sharpen effect\n    TGCALLER_FILTER_SEPIA,          // Sepia effect\n    TGCALLER_FILTER_GRAYSCALE,      // Grayscale effect\n    TGCALLER_FILTER_COLOR_ADJUST,   // Color adjustment\n    TGCALLER_FILTER_COLOR_BALANCE,  // Color balance\n    TGCALLER_FILTER_EDGE_DETECT,    // Edge detection\n    TGCALLER_FILTER_CARTOON         // Cartoon effect\n} TgCallerFilterType;\n</code></pre>"},{"location":"c-api/enums/#whisper-models","title":"Whisper Models","text":""},{"location":"c-api/enums/#tgcallerwhispermodel","title":"TgCallerWhisperModel","text":"<pre><code>typedef enum {\n    TGCALLER_WHISPER_TINY,          // Tiny model (~39 MB)\n    TGCALLER_WHISPER_BASE,          // Base model (~74 MB)\n    TGCALLER_WHISPER_SMALL,         // Small model (~244 MB)\n    TGCALLER_WHISPER_MEDIUM,        // Medium model (~769 MB)\n    TGCALLER_WHISPER_LARGE,         // Large model (~1550 MB)\n    TGCALLER_WHISPER_LARGE_V2,      // Large v2 model (~1550 MB)\n    TGCALLER_WHISPER_LARGE_V3       // Large v3 model (~1550 MB)\n} TgCallerWhisperModel;\n</code></pre>"},{"location":"c-api/enums/#log-levels","title":"Log Levels","text":""},{"location":"c-api/enums/#tgcallerloglevel","title":"TgCallerLogLevel","text":"<pre><code>typedef enum {\n    TGCALLER_LOG_TRACE,             // Trace level (most verbose)\n    TGCALLER_LOG_DEBUG,             // Debug level\n    TGCALLER_LOG_INFO,              // Info level\n    TGCALLER_LOG_WARNING,           // Warning level\n    TGCALLER_LOG_ERROR,             // Error level\n    TGCALLER_LOG_CRITICAL,          // Critical level\n    TGCALLER_LOG_OFF                // Logging disabled\n} TgCallerLogLevel;\n\n// Set log level\nTgCallerError tgcaller_set_log_level(TgCallerLogLevel level);\n\n// Get current log level\nTgCallerLogLevel tgcaller_get_log_level(void);\n</code></pre>"},{"location":"c-api/enums/#device-types","title":"Device Types","text":""},{"location":"c-api/enums/#tgcallerdevicetype","title":"TgCallerDeviceType","text":"<pre><code>typedef enum {\n    TGCALLER_DEVICE_AUDIO_INPUT,    // Audio input device (microphone)\n    TGCALLER_DEVICE_AUDIO_OUTPUT,   // Audio output device (speakers)\n    TGCALLER_DEVICE_VIDEO_INPUT,    // Video input device (camera)\n    TGCALLER_DEVICE_MONITOR         // Monitor/display device\n} TgCallerDeviceType;\n</code></pre>"},{"location":"c-api/enums/#connection-types","title":"Connection Types","text":""},{"location":"c-api/enums/#tgcallerconnectiontype","title":"TgCallerConnectionType","text":"<pre><code>typedef enum {\n    TGCALLER_CONNECTION_UDP,        // UDP connection (default)\n    TGCALLER_CONNECTION_TCP,        // TCP connection\n    TGCALLER_CONNECTION_TLS         // TLS connection\n} TgCallerConnectionType;\n\n// Set connection type\nTgCallerError tgcaller_set_connection_type(TgCaller* caller, TgCallerConnectionType type);\n</code></pre>"},{"location":"c-api/enums/#stream-types","title":"Stream Types","text":""},{"location":"c-api/enums/#tgcallerstreamtype","title":"TgCallerStreamType","text":"<pre><code>typedef enum {\n    TGCALLER_STREAM_AUDIO,          // Audio only stream\n    TGCALLER_STREAM_VIDEO,          // Video stream (includes audio)\n    TGCALLER_STREAM_SCREEN,         // Screen sharing stream\n    TGCALLER_STREAM_MICROPHONE,     // Live microphone input\n    TGCALLER_STREAM_CAMERA,         // Live camera input\n    TGCALLER_STREAM_MIXED           // Mixed audio/video stream\n} TgCallerStreamType;\n</code></pre>"},{"location":"c-api/enums/#usage-examples","title":"Usage Examples","text":""},{"location":"c-api/enums/#error-handling","title":"Error Handling","text":"<pre><code>TgCallerError error = tgcaller_join_call(caller, chat_id);\n\nswitch (error) {\n    case TGCALLER_SUCCESS:\n        printf(\"Successfully joined call\\n\");\n        break;\n    case TGCALLER_ERROR_NOT_CONNECTED:\n        fprintf(stderr, \"Not connected to Telegram\\n\");\n        break;\n    case TGCALLER_ERROR_INVALID_CHAT:\n        fprintf(stderr, \"Invalid chat ID\\n\");\n        break;\n    case TGCALLER_ERROR_ALREADY_IN_CALL:\n        fprintf(stderr, \"Already in call\\n\");\n        break;\n    default:\n        fprintf(stderr, \"Error: %s\\n\", tgcaller_error_string(error));\n        break;\n}\n</code></pre>"},{"location":"c-api/enums/#status-checking","title":"Status Checking","text":"<pre><code>TgCallerStreamStatus status;\nTgCallerError error = tgcaller_get_stream_status(caller, chat_id, &amp;status);\n\nif (error == TGCALLER_SUCCESS) {\n    switch (status) {\n        case TGCALLER_STREAM_PLAYING:\n            printf(\"Stream is currently playing\\n\");\n            break;\n        case TGCALLER_STREAM_PAUSED:\n            printf(\"Stream is paused\\n\");\n            break;\n        case TGCALLER_STREAM_IDLE:\n            printf(\"No active stream\\n\");\n            break;\n        default:\n            printf(\"Stream status: %d\\n\", status);\n            break;\n    }\n}\n</code></pre>"},{"location":"c-api/enums/#quality-configuration","title":"Quality Configuration","text":"<pre><code>// Use quality preset\nTgCallerVideoConfig config = tgcaller_video_config_default();\nconfig.quality = TGCALLER_QUALITY_HIGH;\n\n// Or use specific codec\nconfig.codec = TGCALLER_CODEC_H264;\nconfig.quality = TGCALLER_QUALITY_CUSTOM;\nconfig.bitrate = 2000000;  // 2 Mbps\n\nTgCallerError error = tgcaller_set_video_config(caller, &amp;config);\n</code></pre> <p>All enums provide meaningful values that can be used for configuration, status checking, and error handling throughout the TgCaller C API.</p>"},{"location":"c-api/stream-methods/","title":"Stream Methods","text":""},{"location":"c-api/stream-methods/#audio-streaming","title":"Audio Streaming","text":""},{"location":"c-api/stream-methods/#play-audio-file","title":"Play Audio File","text":"<pre><code>#include \"tgcaller.h\"\n\n// Play audio file\nint64_t chat_id = -1001234567890;\nconst char* audio_file = \"song.mp3\";\n\nTgCallerError error = tgcaller_play(caller, chat_id, audio_file);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Started playing: %s\\n\", audio_file);\n} else {\n    fprintf(stderr, \"Failed to play audio: %s\\n\", tgcaller_error_string(error));\n}\n</code></pre>"},{"location":"c-api/stream-methods/#play-with-configuration","title":"Play with Configuration","text":"<pre><code>// Create audio configuration\nTgCallerAudioConfig audio_config = {\n    .bitrate = 128000,\n    .sample_rate = 48000,\n    .channels = 2,\n    .codec = TGCALLER_CODEC_OPUS,\n    .noise_suppression = true,\n    .echo_cancellation = true\n};\n\n// Play with specific configuration\nTgCallerError error = tgcaller_play_with_config(\n    caller, \n    chat_id, \n    \"high_quality_song.flac\",\n    &amp;audio_config,\n    NULL  // No video config\n);\n</code></pre>"},{"location":"c-api/stream-methods/#stream-from-url","title":"Stream from URL","text":"<pre><code>// Stream from HTTP URL\nconst char* stream_url = \"https://example.com/stream.mp3\";\n\nTgCallerError error = tgcaller_play(caller, chat_id, stream_url);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Started streaming from URL\\n\");\n} else {\n    fprintf(stderr, \"Failed to stream from URL: %s\\n\", tgcaller_error_string(error));\n}\n</code></pre>"},{"location":"c-api/stream-methods/#video-streaming","title":"Video Streaming","text":""},{"location":"c-api/stream-methods/#play-video-file","title":"Play Video File","text":"<pre><code>// Create video configuration\nTgCallerVideoConfig video_config = {\n    .width = 1280,\n    .height = 720,\n    .fps = 30,\n    .bitrate = 1500000,\n    .codec = TGCALLER_CODEC_H264,\n    .hardware_acceleration = true\n};\n\n// Create audio configuration for video\nTgCallerAudioConfig audio_config = {\n    .bitrate = 128000,\n    .sample_rate = 48000,\n    .channels = 2,\n    .codec = TGCALLER_CODEC_OPUS\n};\n\n// Play video file\nTgCallerError error = tgcaller_play_with_config(\n    caller,\n    chat_id,\n    \"video.mp4\",\n    &amp;audio_config,\n    &amp;video_config\n);\n\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Started playing video\\n\");\n} else {\n    fprintf(stderr, \"Failed to play video: %s\\n\", tgcaller_error_string(error));\n}\n</code></pre>"},{"location":"c-api/stream-methods/#stream-control","title":"Stream Control","text":""},{"location":"c-api/stream-methods/#pause-stream","title":"Pause Stream","text":"<pre><code>// Pause current stream\nTgCallerError error = tgcaller_pause(caller, chat_id);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Stream paused\\n\");\n} else {\n    fprintf(stderr, \"Failed to pause stream: %s\\n\", tgcaller_error_string(error));\n}\n</code></pre>"},{"location":"c-api/stream-methods/#resume-stream","title":"Resume Stream","text":"<pre><code>// Resume paused stream\nTgCallerError error = tgcaller_resume(caller, chat_id);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Stream resumed\\n\");\n} else {\n    fprintf(stderr, \"Failed to resume stream: %s\\n\", tgcaller_error_string(error));\n}\n</code></pre>"},{"location":"c-api/stream-methods/#stop-stream","title":"Stop Stream","text":"<pre><code>// Stop current stream\nTgCallerError error = tgcaller_stop_stream(caller, chat_id);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Stream stopped\\n\");\n} else {\n    fprintf(stderr, \"Failed to stop stream: %s\\n\", tgcaller_error_string(error));\n}\n</code></pre>"},{"location":"c-api/stream-methods/#volume-control","title":"Volume Control","text":"<pre><code>// Set volume (0.0 to 1.0)\nfloat volume = 0.8f;  // 80%\n\nTgCallerError error = tgcaller_set_volume(caller, chat_id, volume);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Volume set to %.0f%%\\n\", volume * 100);\n} else {\n    fprintf(stderr, \"Failed to set volume: %s\\n\", tgcaller_error_string(error));\n}\n\n// Get current volume\nfloat current_volume;\nerror = tgcaller_get_volume(caller, chat_id, &amp;current_volume);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Current volume: %.0f%%\\n\", current_volume * 100);\n}\n</code></pre>"},{"location":"c-api/stream-methods/#seek-control","title":"Seek Control","text":"<pre><code>// Seek to position (in seconds)\ndouble position = 60.0;  // 1 minute\n\nTgCallerError error = tgcaller_seek(caller, chat_id, position);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Seeked to %.1f seconds\\n\", position);\n} else {\n    fprintf(stderr, \"Failed to seek: %s\\n\", tgcaller_error_string(error));\n}\n\n// Get current position\ndouble current_position;\nerror = tgcaller_get_position(caller, chat_id, &amp;current_position);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Current position: %.1f seconds\\n\", current_position);\n}\n</code></pre>"},{"location":"c-api/stream-methods/#stream-information","title":"Stream Information","text":""},{"location":"c-api/stream-methods/#get-stream-status","title":"Get Stream Status","text":"<pre><code>// Get current stream status\nTgCallerStreamStatus status;\nTgCallerError error = tgcaller_get_stream_status(caller, chat_id, &amp;status);\n\nif (error == TGCALLER_SUCCESS) {\n    switch (status) {\n        case TGCALLER_STREAM_IDLE:\n            printf(\"No active stream\\n\");\n            break;\n        case TGCALLER_STREAM_PLAYING:\n            printf(\"Stream is playing\\n\");\n            break;\n        case TGCALLER_STREAM_PAUSED:\n            printf(\"Stream is paused\\n\");\n            break;\n        case TGCALLER_STREAM_STOPPED:\n            printf(\"Stream is stopped\\n\");\n            break;\n        default:\n            printf(\"Unknown stream status\\n\");\n            break;\n    }\n} else {\n    fprintf(stderr, \"Failed to get stream status: %s\\n\", tgcaller_error_string(error));\n}\n</code></pre>"},{"location":"c-api/stream-methods/#get-stream-information","title":"Get Stream Information","text":"<pre><code>// Get detailed stream information\nTgCallerStreamInfo stream_info;\nTgCallerError error = tgcaller_get_stream_info(caller, chat_id, &amp;stream_info);\n\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Stream Information:\\n\");\n    printf(\"  Source: %s\\n\", stream_info.source);\n    printf(\"  Duration: %.1f seconds\\n\", stream_info.duration);\n    printf(\"  Position: %.1f seconds\\n\", stream_info.position);\n    printf(\"  Volume: %.0f%%\\n\", stream_info.volume * 100);\n    printf(\"  Has Video: %s\\n\", stream_info.has_video ? \"Yes\" : \"No\");\n\n    if (stream_info.has_video) {\n        printf(\"  Video: %dx%d @ %d fps\\n\", \n               stream_info.video_width, \n               stream_info.video_height, \n               stream_info.video_fps);\n    }\n\n    printf(\"  Audio: %d Hz, %d channels, %d kbps\\n\",\n           stream_info.audio_sample_rate,\n           stream_info.audio_channels,\n           stream_info.audio_bitrate / 1000);\n} else {\n    fprintf(stderr, \"Failed to get stream info: %s\\n\", tgcaller_error_string(error));\n}\n</code></pre>"},{"location":"c-api/stream-methods/#advanced-streaming","title":"Advanced Streaming","text":""},{"location":"c-api/stream-methods/#queue-management","title":"Queue Management","text":"<pre><code>// Add to queue\nTgCallerError error = tgcaller_queue_add(caller, chat_id, \"song1.mp3\");\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Added to queue\\n\");\n}\n\n// Get queue size\nsize_t queue_size;\nerror = tgcaller_queue_size(caller, chat_id, &amp;queue_size);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Queue size: %zu\\n\", queue_size);\n}\n\n// Skip to next in queue\nerror = tgcaller_queue_next(caller, chat_id);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Skipped to next in queue\\n\");\n}\n\n// Clear queue\nerror = tgcaller_queue_clear(caller, chat_id);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Queue cleared\\n\");\n}\n</code></pre>"},{"location":"c-api/stream-methods/#repeat-mode","title":"Repeat Mode","text":"<pre><code>// Set repeat mode\nTgCallerRepeatMode repeat_mode = TGCALLER_REPEAT_ONE;\n\nTgCallerError error = tgcaller_set_repeat_mode(caller, chat_id, repeat_mode);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Repeat mode set\\n\");\n}\n\n// Available repeat modes:\n// TGCALLER_REPEAT_NONE - No repeat\n// TGCALLER_REPEAT_ONE  - Repeat current track\n// TGCALLER_REPEAT_ALL  - Repeat all tracks in queue\n</code></pre>"},{"location":"c-api/stream-methods/#stream-from-memory","title":"Stream from Memory","text":"<pre><code>// Stream from memory buffer\nconst uint8_t* audio_data = /* your audio data */;\nsize_t data_size = /* size of audio data */;\n\nTgCallerMemoryStream memory_stream = {\n    .data = audio_data,\n    .size = data_size,\n    .format = TGCALLER_FORMAT_PCM,\n    .sample_rate = 48000,\n    .channels = 2,\n    .bits_per_sample = 16\n};\n\nTgCallerError error = tgcaller_play_memory(caller, chat_id, &amp;memory_stream);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Started playing from memory\\n\");\n} else {\n    fprintf(stderr, \"Failed to play from memory: %s\\n\", tgcaller_error_string(error));\n}\n</code></pre>"},{"location":"c-api/stream-methods/#complete-streaming-example","title":"Complete Streaming Example","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#include \"tgcaller.h\"\n\nvoid stream_callback(TgCallerStreamEvent event, void* user_data) {\n    int64_t chat_id = *(int64_t*)user_data;\n\n    switch (event.type) {\n        case TGCALLER_STREAM_STARTED:\n            printf(\"Stream started in chat %lld\\n\", chat_id);\n            break;\n        case TGCALLER_STREAM_ENDED:\n            printf(\"Stream ended in chat %lld\\n\", chat_id);\n            break;\n        case TGCALLER_STREAM_ERROR:\n            printf(\"Stream error in chat %lld: %s\\n\", chat_id, event.error_message);\n            break;\n    }\n}\n\nint main() {\n    TgCaller* caller = tgcaller_create();\n    if (!caller) return -1;\n\n    // Setup credentials and start\n    tgcaller_set_credentials(caller, 12345, \"api_hash\");\n    tgcaller_start(caller);\n\n    int64_t chat_id = -1001234567890;\n\n    // Register stream callback\n    tgcaller_set_stream_callback(caller, stream_callback, &amp;chat_id);\n\n    // Join call\n    tgcaller_join_call(caller, chat_id);\n\n    // Play audio file\n    tgcaller_play(caller, chat_id, \"song.mp3\");\n\n    // Wait for stream to finish\n    sleep(30);\n\n    // Control stream\n    tgcaller_set_volume(caller, chat_id, 0.5f);  // 50% volume\n    tgcaller_pause(caller, chat_id);\n    sleep(2);\n    tgcaller_resume(caller, chat_id);\n\n    // Cleanup\n    tgcaller_leave_call(caller, chat_id);\n    tgcaller_stop(caller);\n    tgcaller_destroy(caller);\n\n    return 0;\n}\n</code></pre>"},{"location":"c-api/structs/","title":"Available Structs","text":""},{"location":"c-api/structs/#core-structures","title":"Core Structures","text":""},{"location":"c-api/structs/#tgcaller","title":"TgCaller","text":"<pre><code>// Opaque structure for TgCaller instance\ntypedef struct TgCaller TgCaller;\n\n// Create and destroy\nTgCaller* tgcaller_create(void);\nvoid tgcaller_destroy(TgCaller* caller);\n</code></pre>"},{"location":"c-api/structs/#tgcalleraudioconfig","title":"TgCallerAudioConfig","text":"<pre><code>typedef struct {\n    int bitrate;                    // Audio bitrate in bps (8000-320000)\n    int sample_rate;                // Sample rate in Hz (8000, 16000, 24000, 48000)\n    int channels;                   // Number of channels (1=mono, 2=stereo)\n    TgCallerCodec codec;            // Audio codec (OPUS, AAC)\n    bool noise_suppression;         // Enable noise suppression\n    bool echo_cancellation;         // Enable echo cancellation\n    bool auto_gain_control;         // Enable automatic gain control\n} TgCallerAudioConfig;\n\n// Default configurations\nTgCallerAudioConfig tgcaller_audio_config_default(void);\nTgCallerAudioConfig tgcaller_audio_config_high_quality(void);\nTgCallerAudioConfig tgcaller_audio_config_low_bandwidth(void);\n</code></pre>"},{"location":"c-api/structs/#tgcallervideoconfig","title":"TgCallerVideoConfig","text":"<pre><code>typedef struct {\n    int width;                      // Video width in pixels (320-1920)\n    int height;                     // Video height in pixels (240-1080)\n    int fps;                        // Frame rate (15, 24, 30, 60)\n    int bitrate;                    // Video bitrate in bps (100000-5000000)\n    TgCallerCodec codec;            // Video codec (H264, VP8)\n    bool hardware_acceleration;     // Enable hardware acceleration\n} TgCallerVideoConfig;\n\n// Default configurations\nTgCallerVideoConfig tgcaller_video_config_default(void);\nTgCallerVideoConfig tgcaller_video_config_hd_720p(void);\nTgCallerVideoConfig tgcaller_video_config_full_hd_1080p(void);\nTgCallerVideoConfig tgcaller_video_config_low_quality(void);\n</code></pre>"},{"location":"c-api/structs/#stream-information","title":"Stream Information","text":""},{"location":"c-api/structs/#tgcallerstreaminfo","title":"TgCallerStreamInfo","text":"<pre><code>typedef struct {\n    char* source;                   // Stream source (file path or URL)\n    double duration;                // Total duration in seconds\n    double position;                // Current position in seconds\n    float volume;                   // Current volume (0.0 to 1.0)\n    bool has_video;                 // Whether stream has video\n\n    // Audio information\n    int audio_sample_rate;          // Audio sample rate\n    int audio_channels;             // Number of audio channels\n    int audio_bitrate;              // Audio bitrate in bps\n\n    // Video information (if has_video is true)\n    int video_width;                // Video width\n    int video_height;               // Video height\n    int video_fps;                  // Video frame rate\n    int video_bitrate;              // Video bitrate in bps\n} TgCallerStreamInfo;\n\n// Get stream information\nTgCallerError tgcaller_get_stream_info(TgCaller* caller, int64_t chat_id, TgCallerStreamInfo* info);\n\n// Free allocated strings in stream info\nvoid tgcaller_stream_info_free(TgCallerStreamInfo* info);\n</code></pre>"},{"location":"c-api/structs/#tgcallermemorystream","title":"TgCallerMemoryStream","text":"<pre><code>typedef struct {\n    const uint8_t* data;            // Pointer to audio data\n    size_t size;                    // Size of data in bytes\n    TgCallerFormat format;          // Audio format (PCM, etc.)\n    int sample_rate;                // Sample rate in Hz\n    int channels;                   // Number of channels\n    int bits_per_sample;            // Bits per sample (8, 16, 24, 32)\n} TgCallerMemoryStream;\n\n// Play from memory\nTgCallerError tgcaller_play_memory(TgCaller* caller, int64_t chat_id, const TgCallerMemoryStream* stream);\n</code></pre>"},{"location":"c-api/structs/#device-information","title":"Device Information","text":""},{"location":"c-api/structs/#tgcallermonitorinfo","title":"TgCallerMonitorInfo","text":"<pre><code>typedef struct {\n    int index;                      // Monitor index\n    int x;                          // X position\n    int y;                          // Y position\n    int width;                      // Monitor width\n    int height;                     // Monitor height\n    bool is_primary;                // Whether this is the primary monitor\n    char* name;                     // Monitor name\n} TgCallerMonitorInfo;\n\n// Get available monitors\nTgCallerError tgcaller_get_monitors(TgCallerMonitorInfo** monitors, size_t* count);\n\n// Free monitor info array\nvoid tgcaller_monitors_free(TgCallerMonitorInfo* monitors, size_t count);\n</code></pre>"},{"location":"c-api/structs/#tgcalleraudiodevice","title":"TgCallerAudioDevice","text":"<pre><code>typedef struct {\n    int index;                      // Device index\n    char* name;                     // Device name\n    int max_channels;               // Maximum number of channels\n    double default_sample_rate;     // Default sample rate\n    bool is_default;                // Whether this is the default device\n} TgCallerAudioDevice;\n\n// Get available audio devices\nTgCallerError tgcaller_get_audio_devices(TgCallerAudioDevice** devices, size_t* count);\n\n// Free audio device array\nvoid tgcaller_audio_devices_free(TgCallerAudioDevice* devices, size_t count);\n</code></pre>"},{"location":"c-api/structs/#advanced-configurations","title":"Advanced Configurations","text":""},{"location":"c-api/structs/#tgcallerscreenconfig","title":"TgCallerScreenConfig","text":"<pre><code>typedef struct {\n    int monitor_index;              // Monitor to capture (-1 for all)\n    int x;                          // Capture region X (0 for full monitor)\n    int y;                          // Capture region Y (0 for full monitor)\n    int width;                      // Capture width (0 for full monitor)\n    int height;                     // Capture height (0 for full monitor)\n    int fps;                        // Frame rate (15, 24, 30, 60)\n    TgCallerQuality quality;        // Quality preset\n} TgCallerScreenConfig;\n\n// Default screen configuration\nTgCallerScreenConfig tgcaller_screen_config_default(void);\n</code></pre>"},{"location":"c-api/structs/#tgcallermicconfig","title":"TgCallerMicConfig","text":"<pre><code>typedef struct {\n    int device_index;               // Audio device index (-1 for default)\n    int sample_rate;                // Sample rate in Hz\n    int channels;                   // Number of channels\n    bool noise_suppression;         // Enable noise suppression\n    bool echo_cancellation;         // Enable echo cancellation\n    bool auto_gain_control;         // Enable automatic gain control\n    float gain;                     // Microphone gain (0.0 to 2.0)\n} TgCallerMicConfig;\n\n// Default microphone configuration\nTgCallerMicConfig tgcaller_mic_config_default(void);\n</code></pre>"},{"location":"c-api/structs/#tgcallertranscriptionconfig","title":"TgCallerTranscriptionConfig","text":"<pre><code>typedef struct {\n    TgCallerWhisperModel model;     // Whisper model to use\n    char* language;                 // Language code (NULL for auto-detect)\n    bool real_time;                 // Enable real-time transcription\n    float confidence_threshold;     // Minimum confidence (0.0 to 1.0)\n    bool translate;                 // Translate to English\n} TgCallerTranscriptionConfig;\n\n// Default transcription configuration\nTgCallerTranscriptionConfig tgcaller_transcription_config_default(void);\n</code></pre>"},{"location":"c-api/structs/#filter-structures","title":"Filter Structures","text":""},{"location":"c-api/structs/#tgcalleraudiofilter","title":"TgCallerAudioFilter","text":"<pre><code>typedef struct {\n    TgCallerFilterType type;        // Filter type\n    union {\n        struct {\n            float delay;            // Echo delay in seconds\n            float decay;            // Echo decay factor\n        } echo;\n\n        struct {\n            float room_size;        // Room size (0.0 to 1.0)\n            float damping;          // Damping factor (0.0 to 1.0)\n        } reverb;\n\n        struct {\n            float semitones;        // Pitch shift in semitones\n        } pitch_shift;\n\n        struct {\n            float gain;             // Distortion gain\n            float threshold;        // Distortion threshold\n        } distortion;\n\n        struct {\n            float threshold;        // Gate threshold\n            float ratio;            // Gate ratio\n        } noise_gate;\n    } parameters;\n} TgCallerAudioFilter;\n</code></pre>"},{"location":"c-api/structs/#tgcallervideofilter","title":"TgCallerVideoFilter","text":"<pre><code>typedef struct {\n    TgCallerFilterType type;        // Filter type\n    union {\n        struct {\n            int kernel_size;        // Blur kernel size (odd number)\n        } blur;\n\n        struct {\n            float brightness;       // Brightness adjustment (-1.0 to 1.0)\n            float contrast;         // Contrast adjustment (-1.0 to 1.0)\n            float saturation;       // Saturation adjustment (-1.0 to 1.0)\n        } color_adjust;\n\n        struct {\n            float red_gain;         // Red channel gain\n            float green_gain;       // Green channel gain\n            float blue_gain;        // Blue channel gain\n        } color_balance;\n    } parameters;\n} TgCallerVideoFilter;\n</code></pre>"},{"location":"c-api/structs/#event-structures","title":"Event Structures","text":""},{"location":"c-api/structs/#tgcallerstreamevent","title":"TgCallerStreamEvent","text":"<pre><code>typedef struct {\n    TgCallerStreamEventType type;   // Event type\n    int64_t chat_id;                // Chat ID where event occurred\n    char* source;                   // Stream source (for started events)\n    char* error_message;            // Error message (for error events)\n    double position;                // Current position (for position events)\n    double duration;                // Total duration (for started events)\n} TgCallerStreamEvent;\n\n// Stream event callback\ntypedef void (*TgCallerStreamCallback)(TgCallerStreamEvent event, void* user_data);\n\n// Set stream event callback\nTgCallerError tgcaller_set_stream_callback(TgCaller* caller, TgCallerStreamCallback callback, void* user_data);\n</code></pre>"},{"location":"c-api/structs/#tgcallercallevent","title":"TgCallerCallEvent","text":"<pre><code>typedef struct {\n    TgCallerCallEventType type;     // Event type\n    int64_t chat_id;                // Chat ID\n    int64_t user_id;                // User ID (for user events)\n    char* error_message;            // Error message (for error events)\n} TgCallerCallEvent;\n\n// Call event callback\ntypedef void (*TgCallerCallCallback)(TgCallerCallEvent event, void* user_data);\n\n// Set call event callback\nTgCallerError tgcaller_set_call_callback(TgCaller* caller, TgCallerCallCallback callback, void* user_data);\n</code></pre>"},{"location":"c-api/structs/#youtube-integration","title":"YouTube Integration","text":""},{"location":"c-api/structs/#tgcalleryoutubeinfo","title":"TgCallerYouTubeInfo","text":"<pre><code>typedef struct {\n    char* title;                    // Video title\n    char* uploader;                 // Uploader name\n    int duration;                   // Duration in seconds\n    int64_t view_count;             // View count\n    char* description;              // Video description\n    char* thumbnail_url;            // Thumbnail URL\n} TgCallerYouTubeInfo;\n\n// Get YouTube video information\nTgCallerError tgcaller_get_youtube_info(const char* url, TgCallerYouTubeInfo* info);\n\n// Free YouTube info\nvoid tgcaller_youtube_info_free(TgCallerYouTubeInfo* info);\n</code></pre>"},{"location":"c-api/structs/#transcription-results","title":"Transcription Results","text":""},{"location":"c-api/structs/#tgcallertranscriptionresult","title":"TgCallerTranscriptionResult","text":"<pre><code>typedef struct {\n    char* text;                     // Transcribed text\n    char* language;                 // Detected language\n    float confidence;               // Confidence score (0.0 to 1.0)\n    double duration;                // Audio duration in seconds\n    TgCallerTranscriptionSegment* segments;  // Detailed segments\n    size_t segment_count;           // Number of segments\n} TgCallerTranscriptionResult;\n\ntypedef struct {\n    double start;                   // Segment start time\n    double end;                     // Segment end time\n    char* text;                     // Segment text\n    float confidence;               // Segment confidence\n} TgCallerTranscriptionSegment;\n\n// Transcribe audio file\nTgCallerError tgcaller_transcribe_file(const char* file_path, const char* language, TgCallerTranscriptionResult* result);\n\n// Free transcription result\nvoid tgcaller_transcription_result_free(TgCallerTranscriptionResult* result);\n</code></pre>"},{"location":"c-api/structs/#memory-management","title":"Memory Management","text":"<p>All structures that contain allocated strings or arrays provide corresponding free functions:</p> <pre><code>// Free functions for structures with allocated memory\nvoid tgcaller_stream_info_free(TgCallerStreamInfo* info);\nvoid tgcaller_monitors_free(TgCallerMonitorInfo* monitors, size_t count);\nvoid tgcaller_audio_devices_free(TgCallerAudioDevice* devices, size_t count);\nvoid tgcaller_youtube_info_free(TgCallerYouTubeInfo* info);\nvoid tgcaller_transcription_result_free(TgCallerTranscriptionResult* result);\n</code></pre> <p>Always call the appropriate free function to avoid memory leaks when working with structures that contain allocated memory.</p>"}]}