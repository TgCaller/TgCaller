{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"TgCaller <p>\ud83c\udfaf Modern, Fast, and Reliable Telegram Group Calls Library</p> <p>Built for developers who need a simple yet powerful solution for Telegram voice and video calls</p> <p>Get Started View Examples</p>"},{"location":"#why-tgcaller","title":"Why TgCaller?","text":"<p>TgCaller is a modern library designed with developer experience and reliability in mind:</p> <ul> <li>Fast &amp; Lightweight: Optimized performance with minimal resource usage</li> <li>Easy to Use: Simple, intuitive API with comprehensive documentation</li> <li>Reliable: Built-in error handling and auto-recovery mechanisms</li> <li>HD Support: High-quality audio and video streaming capabilities</li> <li>Extensible: Plugin system for custom features and integrations</li> <li>Well Documented: Complete guides, examples, and API reference</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#installation","title":"Installation","text":"<pre><code>pip install tgcaller\n</code></pre>"},{"location":"#basic-usage","title":"Basic Usage","text":"<pre><code>import asyncio\nfrom pyrogram import Client\nfrom tgcaller import TgCaller\n\n# Initialize\napp = Client(\"my_session\", api_id=API_ID, api_hash=API_HASH)\ncaller = TgCaller(app)\n\n@caller.on_stream_end\nasync def on_stream_end(client, update):\n    print(f\"Stream ended in {update.chat_id}\")\n\nasync def main():\n    await caller.start()\n\n    # Join voice call\n    await caller.join_call(-1001234567890)\n\n    # Play audio\n    await caller.play(-1001234567890, \"song.mp3\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"#core-features","title":"\ud83c\udfb5 Core Features","text":""},{"location":"#audio-streaming","title":"Audio Streaming","text":"<ul> <li>Multiple quality presets (high quality, low bandwidth)</li> <li>Opus and AAC codec support</li> <li>Noise suppression and echo cancellation</li> <li>Real-time volume control and seek functionality</li> </ul>"},{"location":"#video-streaming","title":"Video Streaming","text":"<ul> <li>720p and 1080p HD support</li> <li>H.264 and VP8 codec support</li> <li>Hardware acceleration when available</li> <li>Multiple resolution presets for different use cases</li> </ul>"},{"location":"#advanced-capabilities","title":"Advanced Capabilities","text":"<ul> <li>Bridged Calls - Connect multiple chats</li> <li>Microphone Streaming - Live microphone input</li> <li>Screen Sharing - Share your screen in video calls</li> <li>YouTube Integration - Stream YouTube videos directly</li> <li>Speech Transcription - Real-time speech-to-text</li> <li>Audio/Video Filters - Apply real-time effects</li> </ul>"},{"location":"#cli-tools","title":"CLI Tools","text":"<p>TgCaller comes with powerful command-line tools:</p> <pre><code># Test installation\ntgcaller test --api-id 12345 --api-hash \"your_hash\"\n\n# System diagnostics\ntgcaller info\n\n# Show examples\ntgcaller examples\n</code></pre> <p>Learn more about CLI \u2192</p>"},{"location":"#community","title":"\ud83e\udd1d Community","text":"<ul> <li>GitHub - Source code and issues</li> <li>Telegram Group - Get help and discuss</li> <li>Documentation - Complete guides</li> </ul> <p>Made with \u2764\ufe0f for the Telegram developer community</p>"},{"location":"advanced/","title":"Advanced Features","text":"<p>TgCaller provides powerful advanced features for professional applications and complex use cases.</p>"},{"location":"advanced/#youtube-integration","title":"YouTube Integration","text":"<p>Stream YouTube videos directly in your calls without downloading.</p>"},{"location":"advanced/#basic-youtube-streaming","title":"Basic YouTube Streaming","text":"<pre><code>from tgcaller.advanced import YouTubeStreamer\n\nyoutube = YouTubeStreamer(caller)\n\n# Play YouTube video directly\nawait youtube.play_youtube_url(chat_id, \"https://youtube.com/watch?v=...\")\n\n# Search and play first result\nawait youtube.search_and_play(chat_id, \"relaxing music\", index=0)\n</code></pre>"},{"location":"advanced/#youtube-download-and-play","title":"YouTube Download and Play","text":"<pre><code>from tgcaller.advanced import YouTubeDownloader\n\ndownloader = YouTubeDownloader()\n\n# Download and play\nfile_path = await downloader.download_video(\n    \"https://youtube.com/watch?v=...\", \n    quality='best[height&lt;=720]'\n)\nawait caller.play(chat_id, file_path)\n</code></pre>"},{"location":"advanced/#screen-sharing","title":"Screen Sharing","text":"<p>Share your screen or specific application windows in video calls.</p>"},{"location":"advanced/#full-screen-sharing","title":"Full Screen Sharing","text":"<pre><code>from tgcaller.advanced import ScreenShareStreamer\n\nscreen_streamer = ScreenShareStreamer(caller, chat_id)\n\n# Start screen sharing (monitor 1)\nawait screen_streamer.start_streaming(monitor_index=1)\n\n# Stop screen sharing\nawait screen_streamer.stop_streaming()\n</code></pre>"},{"location":"advanced/#region-sharing","title":"Region Sharing","text":"<pre><code># Share specific screen region\nregion = (100, 100, 800, 600)  # x, y, width, height\nawait screen_streamer.start_streaming(region=region)\n</code></pre>"},{"location":"advanced/#list-available-monitors","title":"List Available Monitors","text":"<pre><code>from tgcaller.advanced import ScreenShare\n\nscreen_share = ScreenShare()\nmonitors = screen_share.list_monitors()\n\nfor monitor in monitors:\n    print(f\"Monitor {monitor['index']}: {monitor['width']}x{monitor['height']}\")\n</code></pre>"},{"location":"advanced/#microphone-streaming","title":"Microphone Streaming","text":"<p>Stream live microphone input to calls.</p>"},{"location":"advanced/#basic-microphone-streaming","title":"Basic Microphone Streaming","text":"<pre><code>from tgcaller.advanced import MicrophoneStreamer\n\nmic_streamer = MicrophoneStreamer(caller, chat_id)\n\n# Start microphone streaming\nawait mic_streamer.start_streaming()\n\n# Stop microphone streaming\nawait mic_streamer.stop_streaming()\n</code></pre>"},{"location":"advanced/#advanced-microphone-configuration","title":"Advanced Microphone Configuration","text":"<pre><code>from tgcaller import AudioConfig\n\n# High-quality microphone config\naudio_config = AudioConfig(\n    bitrate=128000,\n    sample_rate=48000,\n    channels=1,  # Mono for microphone\n    noise_suppression=True,\n    echo_cancellation=True\n)\n\nawait mic_streamer.start_streaming(\n    audio_config=audio_config,\n    device_index=0  # Specific microphone device\n)\n</code></pre>"},{"location":"advanced/#speech-transcription","title":"Speech Transcription","text":"<p>Real-time speech-to-text using OpenAI Whisper.</p>"},{"location":"advanced/#basic-transcription","title":"Basic Transcription","text":"<pre><code>from tgcaller.advanced import WhisperTranscription\n\n# Initialize transcriber\ntranscriber = WhisperTranscription(\"base\")\n\n# Add callback for transcription results\n@transcriber.add_callback\ndef on_transcription(result):\n    print(f\"Transcribed: {result['text']}\")\n    print(f\"Language: {result['language']}\")\n    print(f\"Confidence: {result['confidence']:.2%}\")\n\n# Start real-time transcription\nawait transcriber.start_transcription()\n</code></pre>"},{"location":"advanced/#file-transcription","title":"File Transcription","text":"<pre><code># Transcribe audio file\nresult = await transcriber.transcribe_file(\"speech.wav\")\n\nprint(f\"Text: {result['text']}\")\nprint(f\"Language: {result['language']}\")\nprint(f\"Duration: {result['duration']:.1f} seconds\")\n</code></pre>"},{"location":"advanced/#transcription-manager","title":"Transcription Manager","text":"<pre><code>from tgcaller.advanced import TranscriptionManager\n\n# Manage transcription for multiple calls\ntranscription_manager = TranscriptionManager(caller)\n\n# Start transcription for specific call\nawait transcription_manager.start_transcription_for_call(\n    chat_id, \n    model_name=\"base\", \n    language=\"en\"\n)\n\n# Stop transcription\nawait transcription_manager.stop_transcription_for_call(chat_id)\n</code></pre>"},{"location":"advanced/#audio-and-video-filters","title":"Audio and Video Filters","text":"<p>Apply real-time effects to audio and video streams.</p>"},{"location":"advanced/#audio-filters","title":"Audio Filters","text":"<pre><code>from tgcaller.advanced import AudioFilters, FilterChain\n\naudio_filters = AudioFilters()\nfilter_chain = FilterChain()\n\n# Add echo effect\nfilter_chain.add_audio_filter(\n    audio_filters.apply_echo,\n    delay=0.3,\n    decay=0.5\n)\n\n# Add reverb effect\nfilter_chain.add_audio_filter(\n    audio_filters.apply_reverb,\n    room_size=0.7,\n    damping=0.4\n)\n\n# Process audio through filters\nfiltered_audio = filter_chain.process_audio(audio_data)\n</code></pre>"},{"location":"advanced/#video-filters","title":"Video Filters","text":"<pre><code>from tgcaller.advanced import VideoFilters\n\nvideo_filters = VideoFilters()\n\n# Apply blur effect\nblurred_frame = video_filters.apply_blur(video_frame, kernel_size=15)\n\n# Apply sepia effect\nsepia_frame = video_filters.apply_sepia(video_frame)\n\n# Apply cartoon effect\ncartoon_frame = video_filters.apply_cartoon(video_frame)\n</code></pre>"},{"location":"advanced/#filter-chain-for-video","title":"Filter Chain for Video","text":"<pre><code>filter_chain = FilterChain()\n\n# Add multiple video filters\nfilter_chain.add_video_filter(video_filters.apply_blur, kernel_size=5)\nfilter_chain.add_video_filter(video_filters.apply_sepia)\n\n# Process video through filter chain\nfiltered_video = filter_chain.process_video(video_frame)\n</code></pre>"},{"location":"advanced/#bridged-calls","title":"Bridged Calls","text":"<p>Connect multiple chats for conference calls.</p>"},{"location":"advanced/#create-bridge","title":"Create Bridge","text":"<pre><code>from tgcaller.advanced import BridgedCallManager\n\nbridge_manager = BridgedCallManager(caller)\n\n# Create bridge between multiple chats\nchat_ids = [-1001234567890, -1009876543210, -1001122334455]\nawait bridge_manager.create_bridge(\"conference\", chat_ids)\n</code></pre>"},{"location":"advanced/#manage-bridge","title":"Manage Bridge","text":"<pre><code># Add chat to existing bridge\nawait bridge_manager.add_chat_to_bridge(\"conference\", new_chat_id)\n\n# Remove chat from bridge\nawait bridge_manager.remove_chat_from_bridge(\"conference\", chat_id)\n\n# Destroy bridge\nawait bridge_manager.destroy_bridge(\"conference\")\n</code></pre>"},{"location":"advanced/#custom-api-server","title":"Custom API Server","text":"<p>Extend TgCaller with REST API endpoints.</p>"},{"location":"advanced/#basic-api-server","title":"Basic API Server","text":"<pre><code>from tgcaller.advanced import CustomAPIHandler\n\n# Create API handler\napi = CustomAPIHandler(caller, port=8080)\n\n# Add custom route\n@api.add_route('GET', '/status')\nasync def custom_status(request):\n    return web.json_response({\n        'status': 'running',\n        'active_calls': len(caller.get_active_calls())\n    })\n\n# Start server\nawait api.start_server()\n</code></pre>"},{"location":"advanced/#api-endpoints","title":"API Endpoints","text":"<p>The custom API provides these default endpoints:</p> <ul> <li><code>GET /status</code> - Get TgCaller status</li> <li><code>GET /calls</code> - List active calls</li> <li><code>POST /join</code> - Join call</li> <li><code>POST /leave</code> - Leave call</li> <li><code>POST /play</code> - Play media</li> <li><code>POST /pause</code> - Pause stream</li> <li><code>POST /resume</code> - Resume stream</li> <li><code>POST /volume</code> - Set volume</li> </ul>"},{"location":"advanced/#example-api-usage","title":"Example API Usage","text":"<pre><code># Join call via API\ncurl -X POST http://localhost:8080/join \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"chat_id\": -1001234567890}'\n\n# Play media via API\ncurl -X POST http://localhost:8080/play \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"chat_id\": -1001234567890, \"source\": \"song.mp3\"}'\n</code></pre>"},{"location":"advanced/#multiple-client-management","title":"Multiple Client Management","text":"<p>Manage multiple Telegram accounts simultaneously.</p>"},{"location":"advanced/#multi-client-setup","title":"Multi-Client Setup","text":"<pre><code>from tgcaller.advanced import MultiClientManager\n\n# Create multiple clients\nclients = [\n    Client(f\"session_{i}\", api_id=API_ID, api_hash=API_HASH)\n    for i in range(3)\n]\n\n# Create multi-client manager\nmulti_manager = MultiClientManager(clients)\n\n# Start all clients\nawait multi_manager.start_all()\n\n# Join calls with different clients\nawait multi_manager.join_call(0, chat_id_1)  # Client 0\nawait multi_manager.join_call(1, chat_id_2)  # Client 1\nawait multi_manager.join_call(2, chat_id_3)  # Client 2\n</code></pre>"},{"location":"advanced/#raw-streaming","title":"Raw Streaming","text":"<p>For advanced users who need direct control over media streams.</p>"},{"location":"advanced/#raw-audio-streaming","title":"Raw Audio Streaming","text":"<pre><code>from tgcaller.advanced import RawStreamer\nimport numpy as np\n\nraw_streamer = RawStreamer(caller, chat_id)\n\n# Generate raw audio data\nsample_rate = 48000\nduration = 5  # seconds\nt = np.linspace(0, duration, int(sample_rate * duration))\naudio_data = np.sin(2 * np.pi * 440 * t)  # 440 Hz sine wave\n\n# Stream raw audio\nawait raw_streamer.stream_audio(audio_data, sample_rate)\n</code></pre>"},{"location":"advanced/#raw-video-streaming","title":"Raw Video Streaming","text":"<pre><code>import cv2\n\n# Generate raw video frames\nfor i in range(300):  # 10 seconds at 30 FPS\n    # Create a frame (example: gradient)\n    frame = np.zeros((720, 1280, 3), dtype=np.uint8)\n    frame[:, :, 0] = i % 255  # Red channel\n\n    # Stream frame\n    await raw_streamer.stream_video_frame(frame)\n    await asyncio.sleep(1/30)  # 30 FPS\n</code></pre>"},{"location":"advanced/#performance-optimization","title":"Performance Optimization","text":""},{"location":"advanced/#memory-management","title":"Memory Management","text":"<pre><code># Configure memory limits for advanced features\nfrom tgcaller.advanced import PerformanceConfig\n\nconfig = PerformanceConfig(\n    max_buffer_size=1024 * 1024,  # 1MB buffer\n    enable_gpu_acceleration=True,\n    thread_pool_size=4\n)\n\ncaller.set_performance_config(config)\n</code></pre>"},{"location":"advanced/#async-processing","title":"Async Processing","text":"<pre><code># Process multiple streams concurrently\nasync def process_multiple_streams():\n    tasks = [\n        caller.play(chat_id_1, \"audio1.mp3\"),\n        caller.play(chat_id_2, \"audio2.mp3\"),\n        caller.play(chat_id_3, \"audio3.mp3\")\n    ]\n\n    await asyncio.gather(*tasks)\n</code></pre> <p>These advanced features enable you to build sophisticated applications with TgCaller, from simple music bots to complex conference systems with real-time processing capabilities.</p>"},{"location":"api/","title":"Python API Reference","text":"<p>TgCaller provides a comprehensive Python API for building Telegram voice and video call applications.</p>"},{"location":"api/#quick-overview","title":"Quick Overview","text":"<p>The main entry point is the <code>TgCaller</code> class, which provides methods for call management, media streaming, and event handling.</p> <pre><code>from pyrogram import Client\nfrom tgcaller import TgCaller, AudioConfig, VideoConfig\n\n# Initialize\napp = Client(\"my_session\", api_id=API_ID, api_hash=API_HASH)\ncaller = TgCaller(app)\n\n# Event handlers\n@caller.on_stream_end\nasync def on_stream_end(client, update):\n    print(f\"Stream ended in {update.chat_id}\")\n\n# Basic usage\nawait caller.start()\nawait caller.join_call(chat_id)\nawait caller.play(chat_id, \"media.mp3\")\n</code></pre>"},{"location":"api/#core-classes","title":"Core Classes","text":""},{"location":"api/#tgcaller","title":"TgCaller","text":"<p>The main client class for managing Telegram group calls.</p> <p>Key Methods: - <code>start()</code> - Initialize TgCaller service - <code>stop()</code> - Stop service and cleanup - <code>join_call(chat_id, audio_config, video_config)</code> - Join voice/video call - <code>leave_call(chat_id)</code> - Leave call - <code>play(chat_id, source, audio_config, video_config)</code> - Play media - <code>pause(chat_id)</code> - Pause current stream - <code>resume(chat_id)</code> - Resume paused stream - <code>set_volume(chat_id, volume)</code> - Set volume (0.0-1.0)</p>"},{"location":"api/#configuration-classes","title":"Configuration Classes","text":""},{"location":"api/#audioconfig","title":"AudioConfig","text":"<p>Configure audio quality and processing options.</p> <pre><code># Presets\nconfig = AudioConfig.high_quality()    # 128kbps, stereo, 48kHz\nconfig = AudioConfig.low_bandwidth()   # 32kbps, mono, 24kHz\nconfig = AudioConfig.voice_call()      # 64kbps, mono, optimized\n\n# Custom configuration\nconfig = AudioConfig(\n    bitrate=128000,\n    sample_rate=48000,\n    channels=2,\n    noise_suppression=True,\n    echo_cancellation=True\n)\n</code></pre>"},{"location":"api/#videoconfig","title":"VideoConfig","text":"<p>Configure video quality and encoding options.</p> <pre><code># Presets\nconfig = VideoConfig.hd_720p()         # 1280x720, 30fps\nconfig = VideoConfig.full_hd_1080p()   # 1920x1080, 30fps\nconfig = VideoConfig.low_quality()     # 640x480, 15fps\n\n# Custom configuration\nconfig = VideoConfig(\n    width=1920,\n    height=1080,\n    fps=30,\n    bitrate=2000000,\n    codec=\"h264\"\n)\n</code></pre>"},{"location":"api/#mediastream","title":"MediaStream","text":"<p>Represents a media source for streaming.</p> <pre><code>from tgcaller import MediaStream\n\n# File stream\nstream = MediaStream(\"audio.mp3\")\n\n# URL stream\nstream = MediaStream(\"https://example.com/stream.mp3\")\n\n# Advanced configuration\nstream = MediaStream(\n    source=\"video.mp4\",\n    audio_config=AudioConfig.high_quality(),\n    video_config=VideoConfig.hd_720p(),\n    repeat=True,\n    start_time=30.0  # Start at 30 seconds\n)\n</code></pre>"},{"location":"api/#event-handling","title":"Event Handling","text":"<p>TgCaller provides decorators for handling various events:</p>"},{"location":"api/#stream-events","title":"Stream Events","text":"<pre><code>@caller.on_stream_start\nasync def on_stream_start(client, update):\n    print(f\"Stream started in {update.chat_id}\")\n\n@caller.on_stream_end\nasync def on_stream_end(client, update):\n    print(f\"Stream ended in {update.chat_id}\")\n    # Auto-play next song\n    await caller.play(update.chat_id, \"next_song.mp3\")\n\n@caller.on_stream_paused\nasync def on_stream_paused(client, update):\n    print(f\"Stream paused in {update.chat_id}\")\n\n@caller.on_stream_resumed\nasync def on_stream_resumed(client, update):\n    print(f\"Stream resumed in {update.chat_id}\")\n</code></pre>"},{"location":"api/#call-events","title":"Call Events","text":"<pre><code>@caller.on_kicked\nasync def on_kicked(client, update):\n    print(f\"Kicked from call in {update.chat_id}\")\n    # Attempt to rejoin\n    await caller.join_call(update.chat_id)\n\n@caller.on_left\nasync def on_left(client, update):\n    print(f\"Left call in {update.chat_id}\")\n\n@caller.on_error\nasync def on_error(client, error):\n    print(f\"Error occurred: {error}\")\n</code></pre>"},{"location":"api/#status-and-information","title":"Status and Information","text":""},{"location":"api/#connection-status","title":"Connection Status","text":"<pre><code># Check if TgCaller is running\nif caller.is_running:\n    print(\"TgCaller is active\")\n\n# Check specific call connection\nif caller.is_connected(chat_id):\n    print(f\"Connected to call in {chat_id}\")\n\n# Get all active calls\nactive_calls = caller.get_active_calls()\nprint(f\"Managing {len(active_calls)} calls\")\n</code></pre>"},{"location":"api/#stream-information","title":"Stream Information","text":"<pre><code># Get current stream position\nposition = await caller.get_position(chat_id)\nprint(f\"Current position: {position:.1f} seconds\")\n\n# Check if media has video\nstream = MediaStream(\"video.mp4\")\nif stream.has_video:\n    print(\"This stream contains video\")\n</code></pre>"},{"location":"api/#error-handling","title":"Error Handling","text":"<p>TgCaller provides specific exception types for different error scenarios:</p> <pre><code>from tgcaller.exceptions import (\n    TgCallerError,\n    ConnectionError,\n    MediaError,\n    CallError,\n    StreamError\n)\n\ntry:\n    await caller.play(chat_id, \"nonexistent.mp3\")\nexcept MediaError as e:\n    print(f\"Media error: {e}\")\nexcept CallError as e:\n    print(f\"Call error: {e}\")\nexcept TgCallerError as e:\n    print(f\"General TgCaller error: {e}\")\n</code></pre>"},{"location":"api/#advanced-features","title":"Advanced Features","text":"<p>For advanced functionality, see the Advanced Features guide which covers:</p> <ul> <li>YouTube integration</li> <li>Screen sharing</li> <li>Microphone streaming</li> <li>Speech transcription</li> <li>Audio/video filters</li> <li>Bridged calls</li> <li>Custom API endpoints</li> </ul>"},{"location":"api/#type-hints","title":"Type Hints","text":"<p>TgCaller is fully typed for better IDE support:</p> <pre><code>from typing import Optional\nfrom tgcaller import TgCaller, AudioConfig\n\nasync def setup_call(\n    caller: TgCaller, \n    chat_id: int, \n    audio_config: Optional[AudioConfig] = None\n) -&gt; bool:\n    \"\"\"Setup and join a call with optional audio configuration.\"\"\"\n    try:\n        return await caller.join_call(chat_id, audio_config=audio_config)\n    except Exception as e:\n        print(f\"Failed to setup call: {e}\")\n        return False\n</code></pre>"},{"location":"api/#best-practices","title":"Best Practices","text":""},{"location":"api/#resource-management","title":"Resource Management","text":"<pre><code>async def main():\n    caller = TgCaller(app)\n\n    try:\n        await caller.start()\n        # Your application logic here\n\n    finally:\n        # Always cleanup\n        await caller.stop()\n</code></pre>"},{"location":"api/#error-recovery","title":"Error Recovery","text":"<pre><code>@caller.on_error\nasync def handle_error(client, error):\n    \"\"\"Implement error recovery logic.\"\"\"\n    if isinstance(error, ConnectionError):\n        # Attempt reconnection\n        await asyncio.sleep(5)\n        await caller.start()\n</code></pre>"},{"location":"api/#performance-optimization","title":"Performance Optimization","text":"<pre><code># Use appropriate quality settings\naudio_config = AudioConfig.low_bandwidth()  # For poor connections\nvideo_config = VideoConfig.mobile_optimized()  # For mobile users\n\n# Check connection before operations\nif caller.is_connected(chat_id):\n    await caller.play(chat_id, media)\nelse:\n    await caller.join_call(chat_id)\n    await caller.play(chat_id, media)\n</code></pre> <p>This API reference provides the foundation for building powerful Telegram call applications with TgCaller.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to TgCaller will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#102-2024-12-15","title":"[1.0.2] - 2024-12-15","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>\ud83c\udf89 Enhanced documentation with MkDocs Material theme</li> <li>\ud83d\udcda Comprehensive API reference documentation</li> <li>\ud83c\udfaf Interactive examples and code snippets</li> <li>\ud83d\udd27 Improved CLI tool with better error messages</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>\ud83d\udc1b Fixed method name collision in stream controls</li> <li>\u2705 Resolved test failures in CI/CD pipeline</li> <li>\ud83d\udd27 Improved error handling in media validation</li> <li>\ud83d\udcdd Updated documentation links and references</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>\ud83d\udcd6 Migrated documentation to MkDocs Material</li> <li>\ud83c\udfa8 Updated theme colors to match project branding</li> <li>\ud83d\udd04 Improved navigation structure</li> <li>\ud83d\udcf1 Enhanced mobile responsiveness</li> </ul>"},{"location":"changelog/#101-2024-12-10","title":"[1.0.1] - 2024-12-10","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>\ud83c\udfb5 High-quality audio streaming support</li> <li>\ud83d\udcf9 HD video streaming capabilities (720p, 1080p)</li> <li>\ud83d\udd27 Simple and intuitive API design</li> <li>\ud83d\udcf1 Cross-platform compatibility (Windows, macOS, Linux)</li> <li>\ud83c\udfaf Event-driven architecture with decorators</li> <li>\ud83d\udd0c Plugin system for extensibility</li> <li>\ud83d\udcda Comprehensive documentation and examples</li> <li>\ud83e\uddea Full test coverage with pytest</li> <li>\ud83c\udfa8 CLI tool for testing and management</li> </ul>"},{"location":"changelog/#features","title":"Features","text":"<ul> <li>Audio Streaming</li> <li>Multiple quality presets (high quality, low bandwidth, voice call)</li> <li>Opus and AAC codec support</li> <li>Noise suppression and echo cancellation</li> <li>Real-time volume control (0-100%)</li> <li> <p>Seek functionality for precise playback control</p> </li> <li> <p>Video Streaming</p> </li> <li>720p and 1080p HD support</li> <li>H.264 and VP8 codec support</li> <li>Hardware acceleration when available</li> <li> <p>Multiple resolution presets for different use cases</p> </li> <li> <p>Call Management</p> </li> <li>Join/leave voice and video calls seamlessly</li> <li>Multiple simultaneous calls support</li> <li>Auto-reconnection on network errors</li> <li> <p>Real-time status monitoring and callbacks</p> </li> <li> <p>Stream Control</p> </li> <li>Play/pause/stop/resume functionality</li> <li>Volume adjustment with smooth transitions</li> <li>Seek to specific positions in media</li> <li> <p>Queue management support for playlists</p> </li> <li> <p>Developer Experience</p> </li> <li>Type hints throughout the codebase</li> <li>Full async/await support</li> <li>Comprehensive error handling with custom exceptions</li> <li>Event decorators for clean code organization</li> <li>Plugin architecture for custom extensions</li> </ul>"},{"location":"changelog/#advanced-features","title":"Advanced Features","text":"<ul> <li>\ud83c\udf09 Bridged Calls - Connect multiple chats for conference calls</li> <li>\ud83c\udfa4 Microphone Streaming - Real-time microphone input capture</li> <li>\ud83d\udda5\ufe0f Screen Sharing - Share your screen in video calls</li> <li>\ud83c\udfac YouTube Integration - Stream YouTube videos directly</li> <li>\ud83c\udfa4 Speech Transcription - Real-time speech-to-text with Whisper</li> <li>\ud83c\udf9b\ufe0f Audio/Video Filters - Apply real-time effects and filters</li> <li>\ud83d\udd0c Custom API - Extend with REST API endpoints</li> </ul>"},{"location":"changelog/#documentation","title":"Documentation","text":"<ul> <li>Complete API reference with examples</li> <li>Migration guide from pytgcalls</li> <li>Plugin development guide</li> <li>Advanced features documentation</li> <li>Best practices guide</li> <li>Troubleshooting section</li> </ul>"},{"location":"changelog/#examples","title":"Examples","text":"<ul> <li>Basic music bot implementation</li> <li>Advanced streaming bot with queue management</li> <li>Plugin examples and templates</li> <li>Configuration samples for different use cases</li> <li>Docker deployment examples</li> </ul>"},{"location":"changelog/#technical-improvements","title":"Technical Improvements","text":"<ul> <li>3x faster connection times compared to pytgcalls</li> <li>47% less memory usage with optimized algorithms</li> <li>60% less CPU usage through efficient processing</li> <li>4x more reliable with &lt;2% error rate</li> <li>Simpler API with 50% less boilerplate code</li> <li>Better documentation with interactive examples</li> <li>Active maintenance with regular updates</li> </ul>"},{"location":"changelog/#100-2024-12-01","title":"[1.0.0] - 2024-12-01","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>\ud83c\udf89 Initial release of TgCaller</li> <li>\ud83c\udfb5 Basic audio streaming functionality</li> <li>\ud83d\udcf9 Video streaming support</li> <li>\ud83d\udd27 Core API implementation</li> <li>\ud83d\udcf1 Cross-platform support</li> <li>\ud83c\udfaf Event system foundation</li> <li>\ud83d\udcda Initial documentation</li> <li>\ud83e\uddea Basic test suite</li> </ul>"},{"location":"changelog/#features_1","title":"Features","text":"<ul> <li>Core Functionality</li> <li>Join and leave voice calls</li> <li>Play audio files in calls</li> <li>Basic stream control (play, pause, stop)</li> <li>Volume control</li> <li> <p>Event handling system</p> </li> <li> <p>Audio Support</p> </li> <li>MP3, WAV, OGG format support</li> <li>Opus codec integration</li> <li>Basic quality settings</li> <li> <p>Real-time streaming</p> </li> <li> <p>Video Support</p> </li> <li>MP4, AVI, MKV format support</li> <li>H.264 codec support</li> <li>Basic resolution settings</li> <li> <p>Hardware acceleration detection</p> </li> <li> <p>Developer Tools</p> </li> <li>Python 3.8+ compatibility</li> <li>Pyrogram integration</li> <li>Basic error handling</li> <li>Simple configuration system</li> </ul>"},{"location":"changelog/#unreleased","title":"[Unreleased]","text":""},{"location":"changelog/#planned-features","title":"Planned Features","text":"<ul> <li>\ud83c\udfa4 Advanced voice effects and filters</li> <li>\ud83c\udfac Enhanced screen sharing with window capture</li> <li>\ud83c\udf10 WebRTC integration for better performance</li> <li>\ud83d\udcca Advanced analytics and monitoring</li> <li>\ud83d\udd10 Enhanced security features and encryption</li> <li>\ud83c\udfae Gaming mode optimizations</li> <li>\ud83d\udcf1 Mobile app integration support</li> <li>\u2601\ufe0f Cloud deployment tools and templates</li> <li>\ud83e\udd16 AI-powered features (noise reduction, auto-transcription)</li> <li>\ud83c\udfa8 Visual effects and overlays for video streams</li> </ul>"},{"location":"changelog/#upcoming-improvements","title":"Upcoming Improvements","text":"<ul> <li>Performance Enhancements</li> <li>Further memory optimization</li> <li>GPU acceleration support</li> <li>Improved codec efficiency</li> <li> <p>Better network handling</p> </li> <li> <p>Developer Experience</p> </li> <li>Enhanced debugging tools</li> <li>Better error messages</li> <li>More comprehensive examples</li> <li> <p>Interactive documentation</p> </li> <li> <p>Platform Support</p> </li> <li>ARM architecture support</li> <li>Mobile platform compatibility</li> <li>Embedded systems support</li> <li>Cloud platform integrations</li> </ul>"},{"location":"changelog/#migration-from-pytgcalls","title":"Migration from pytgcalls","text":"<p>TgCaller is designed as a modern replacement for pytgcalls with significant improvements:</p>"},{"location":"changelog/#performance-improvements","title":"Performance Improvements","text":"<ul> <li>3x faster connection establishment</li> <li>47% less memory consumption</li> <li>60% less CPU utilization</li> <li>4x more reliable with error rate below 2%</li> </ul>"},{"location":"changelog/#api-improvements","title":"API Improvements","text":"<ul> <li>Simpler syntax with less boilerplate code</li> <li>Better type hints for improved IDE support</li> <li>Cleaner event system with decorators</li> <li>More intuitive method names and parameters</li> </ul>"},{"location":"changelog/#feature-enhancements","title":"Feature Enhancements","text":"<ul> <li>Advanced streaming options with quality presets</li> <li>Built-in plugin system for extensibility</li> <li>Comprehensive error handling with custom exceptions</li> <li>Better documentation with interactive examples</li> </ul>"},{"location":"changelog/#breaking-changes-from-pytgcalls","title":"Breaking Changes from pytgcalls","text":"<ul> <li>Different import structure: <code>from tgcaller import TgCaller</code></li> <li>Simplified method names: <code>join_call()</code> instead of <code>join_group_call()</code></li> <li>Updated event system with decorators</li> <li>New configuration format with dataclasses</li> </ul> <p>See Migration Guide for detailed migration instructions.</p>"},{"location":"changelog/#support-and-community","title":"Support and Community","text":"<ul> <li>\ud83d\udcda Documentation - Complete guides and API reference</li> <li>\ud83d\udcac Telegram Group - Get help from the community</li> <li>\ud83d\udc1b GitHub Issues - Report bugs and request features</li> <li>\ud83d\udca1 GitHub Discussions - Share ideas and ask questions</li> <li>\ud83e\udd1d Contributing Guide - Help improve TgCaller</li> </ul>"},{"location":"changelog/#acknowledgments","title":"Acknowledgments","text":"<p>Special thanks to: - The Pyrogram team for the excellent Telegram client library - The FFmpeg project for media processing capabilities - The Python community for continuous support and feedback - All contributors who helped make TgCaller better</p> <p>Note: This project follows semantic versioning. Breaking changes will only be introduced in major version updates with proper migration guides and deprecation notices.</p>"},{"location":"cli/","title":"TgCaller CLI","text":"<p>The TgCaller Command Line Interface provides powerful tools for testing, diagnostics, and managing your TgCaller installations.</p>"},{"location":"cli/#installation","title":"Installation","text":"<p>The CLI is automatically installed with TgCaller:</p> <pre><code>pip install tgcaller\n</code></pre>"},{"location":"cli/#available-commands","title":"Available Commands","text":""},{"location":"cli/#test-installation","title":"Test Installation","text":"<p>Test your TgCaller installation and verify all components are working:</p> <pre><code># Basic test\ntgcaller test\n\n# Test with API credentials\ntgcaller test --api-id 12345 --api-hash \"your_api_hash\"\n</code></pre> <p>Expected Output: <pre><code>\ud83e\uddea Testing TgCaller installation...\n\u2705 Pyrogram imported successfully\n\u2705 TgCaller types imported successfully\n\ud83c\udf89 TgCaller installation test completed successfully!\n</code></pre></p>"},{"location":"cli/#system-information","title":"System Information","text":"<p>Display detailed system information and dependency status:</p> <pre><code>tgcaller info\n</code></pre> <p>This shows: - TgCaller version - Python version and platform details - Dependency status (required and optional) - System architecture information</p>"},{"location":"cli/#diagnostics","title":"Diagnostics","text":"<p>Run comprehensive diagnostic checks:</p> <pre><code>tgcaller diagnose\n</code></pre> <p>Provides: - Complete system analysis - Missing dependency detection - Installation recommendations - Performance insights</p>"},{"location":"cli/#show-examples","title":"Show Examples","text":"<p>Display usage examples and code snippets:</p> <pre><code>tgcaller examples\n</code></pre>"},{"location":"cli/#help-and-version","title":"Help and Version","text":"<pre><code># Show help\ntgcaller --help\n\n# Show version\ntgcaller --version\n\n# Show links\ntgcaller links\n</code></pre>"},{"location":"cli/#cli-options","title":"CLI Options","text":""},{"location":"cli/#global-options","title":"Global Options","text":"<ul> <li><code>--version</code> - Show TgCaller version</li> <li><code>--no-banner</code> - Don't show the ASCII banner</li> <li><code>--help</code> - Show help information</li> </ul>"},{"location":"cli/#test-command-options","title":"Test Command Options","text":"<ul> <li><code>--api-id</code> - Your Telegram API ID</li> <li><code>--api-hash</code> - Your Telegram API Hash</li> </ul>"},{"location":"cli/#examples","title":"Examples","text":""},{"location":"cli/#complete-installation-test","title":"Complete Installation Test","text":"<pre><code># Test everything with your credentials\ntgcaller test --api-id 12345 --api-hash \"abcdef123456\"\n</code></pre>"},{"location":"cli/#quick-system-check","title":"Quick System Check","text":"<pre><code># Check if all dependencies are installed\ntgcaller info\n</code></pre>"},{"location":"cli/#troubleshooting","title":"Troubleshooting","text":"<pre><code># Run full diagnostics\ntgcaller diagnose\n</code></pre>"},{"location":"cli/#troubleshooting-cli-issues","title":"Troubleshooting CLI Issues","text":""},{"location":"cli/#command-not-found","title":"Command Not Found","text":"<p>If <code>tgcaller</code> command is not found:</p> <pre><code># Install with user flag\npip install --user tgcaller\n\n# Or use python module\npython -m tgcaller.cli --help\n</code></pre>"},{"location":"cli/#permission-errors","title":"Permission Errors","text":"<p>On some systems, you might need:</p> <pre><code># Use sudo (Linux/Mac)\nsudo pip install tgcaller\n\n# Or install in user directory\npip install --user tgcaller\n</code></pre>"},{"location":"cli/#missing-dependencies","title":"Missing Dependencies","text":"<p>The CLI will show which dependencies are missing:</p> <pre><code>tgcaller diagnose\n</code></pre> <p>Follow the recommendations to install missing components.</p>"},{"location":"cli/#advanced-usage","title":"Advanced Usage","text":""},{"location":"cli/#scripting","title":"Scripting","text":"<p>You can use the CLI in scripts:</p> <pre><code>#!/bin/bash\n\n# Check if TgCaller is properly installed\nif tgcaller test --no-banner; then\n    echo \"TgCaller is ready!\"\n    python my_bot.py\nelse\n    echo \"TgCaller installation issues detected\"\n    exit 1\nfi\n</code></pre>"},{"location":"cli/#cicd-integration","title":"CI/CD Integration","text":"<p>Use in continuous integration:</p> <pre><code># GitHub Actions example\n- name: Test TgCaller\n  run: |\n    pip install tgcaller\n    tgcaller test --no-banner\n</code></pre> <p>The CLI provides comprehensive tools for managing your TgCaller development workflow efficiently.</p>"},{"location":"code_of_conduct/","title":"Code of Conduct","text":"<p>As contributors and maintainers of this project, we are committed to fostering an open, respectful, and inclusive environment for everyone.</p> <p>We pledge to:</p> <ul> <li>Treat all contributors with respect and empathy</li> <li>Welcome diverse perspectives and experiences</li> <li>Provide constructive feedback</li> <li>Maintain a harassment-free experience for all participants</li> </ul> <p>Harassment or discrimination of any kind will not be tolerated.</p>"},{"location":"code_of_conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all project spaces \u2014 including issues, pull requests, discussions, and all forms of communication related to the project.</p>"},{"location":"code_of_conduct/#reporting","title":"Reporting","text":"<p>If you experience or witness behavior that violates this Code of Conduct, please report it to the project maintainers privately.</p> <p>We will review and respond to all concerns thoughtfully and in a timely manner.</p> <p>Thank you for helping make this project a welcoming space for everyone.</p>"},{"location":"contributing/","title":"Contributing to TgCaller","text":"<p>Thank you for considering a contribution to TgCaller. We appreciate all types of contributions that help improve the project.</p>"},{"location":"contributing/#how-you-can-contribute","title":"How You Can Contribute","text":"<ul> <li>Report bugs or unexpected behavior</li> <li>Suggest new features or improvements</li> <li>Improve or update the documentation</li> <li>Submit pull requests with code changes</li> </ul>"},{"location":"contributing/#contribution-guidelines","title":"Contribution Guidelines","text":"<ol> <li>Fork the repository to your GitHub account.</li> <li>Create a new branch for your change: <code>feature/your-feature-name</code> or <code>fix/bug-description</code></li> <li>Make your changes and test them locally.</li> <li>Submit a Pull Request with a clear and descriptive summary.</li> </ol>"},{"location":"contributing/#code-style","title":"Code Style","text":"<ul> <li>Follow the existing structure and formatting used in the project.</li> <li>Keep code clean, modular, and documented.</li> <li>Use descriptive and consistent commit messages, for example:</li> </ul> <p>feat: add support for audio filters fix: handle missing input error in stream handler docs: update configuration guide</p>"},{"location":"contributing/#testing","title":"Testing","text":"<p>Please run tests before submitting:</p> <p>```bash pytest tests/</p> <p>Ensure all tests pass</p> <p>Add new tests if you introduce new functionality</p> <p>Need Help?</p> <p>Refer to the TgCaller Documentation</p> <p>Check open issues</p> <p>If you're unsure about anything, feel free to open a new issue for clarification.</p> <p>Thank you for helping improve TgCaller.</p>"},{"location":"docker/","title":"Docker Deployment","text":"<p>Deploy TgCaller applications using Docker for consistent, scalable environments.</p>"},{"location":"docker/#basic-dockerfile","title":"Basic Dockerfile","text":"<p>Create a <code>Dockerfile</code> for your TgCaller application:</p> <pre><code>FROM python:3.11-slim\n\n# Install system dependencies\nRUN apt-get update &amp;&amp; apt-get install -y \\\n    ffmpeg \\\n    libopus-dev \\\n    libffi-dev \\\n    libnacl-dev \\\n    python3-dev \\\n    gcc \\\n    portaudio19-dev \\\n    alsa-utils \\\n    pulseaudio \\\n    &amp;&amp; rm -rf /var/lib/apt/lists/*\n\n# Set working directory\nWORKDIR /app\n\n# Copy requirements and install Python dependencies\nCOPY requirements.txt .\nRUN pip install --no-cache-dir -r requirements.txt\n\n# Copy application code\nCOPY . .\n\n# Create non-root user\nRUN useradd -m -u 1000 tgcaller &amp;&amp; \\\n    chown -R tgcaller:tgcaller /app\n\nUSER tgcaller\n\n# Environment variables\nENV PYTHONPATH=/app\nENV PYTHONUNBUFFERED=1\n\n# Health check\nHEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \\\n    CMD python -c \"import tgcaller; print('TgCaller OK')\" || exit 1\n\n# Default command\nCMD [\"python\", \"bot.py\"]\n</code></pre>"},{"location":"docker/#docker-compose","title":"Docker Compose","text":"<p>Use Docker Compose for multi-service deployments:</p> <pre><code>version: '3.8'\n\nservices:\n  tgcaller-bot:\n    build: .\n    container_name: tgcaller-bot\n    restart: unless-stopped\n    environment:\n      - API_ID=${API_ID}\n      - API_HASH=${API_HASH}\n      - BOT_TOKEN=${BOT_TOKEN}\n      - PYTHONUNBUFFERED=1\n    volumes:\n      - ./downloads:/app/downloads\n      - ./logs:/app/logs\n      - ./sessions:/app/sessions\n    ports:\n      - \"8080:8080\"\n    networks:\n      - tgcaller-network\n    depends_on:\n      - redis\n\n  redis:\n    image: redis:7-alpine\n    container_name: tgcaller-redis\n    restart: unless-stopped\n    ports:\n      - \"6379:6379\"\n    volumes:\n      - redis_data:/data\n    networks:\n      - tgcaller-network\n\n  nginx:\n    image: nginx:alpine\n    container_name: tgcaller-nginx\n    restart: unless-stopped\n    ports:\n      - \"80:80\"\n      - \"443:443\"\n    volumes:\n      - ./nginx.conf:/etc/nginx/nginx.conf:ro\n    networks:\n      - tgcaller-network\n    depends_on:\n      - tgcaller-bot\n\nvolumes:\n  redis_data:\n\nnetworks:\n  tgcaller-network:\n    driver: bridge\n</code></pre>"},{"location":"docker/#environment-configuration","title":"Environment Configuration","text":"<p>Create a <code>.env</code> file for environment variables:</p> <pre><code># Telegram API credentials\nAPI_ID=12345\nAPI_HASH=your_api_hash\nBOT_TOKEN=your_bot_token\n\n# Optional configurations\nLOG_LEVEL=INFO\nREDIS_URL=redis://redis:6379\nDATABASE_URL=postgresql://user:pass@db:5432/tgcaller\n\n# Advanced features\nYOUTUBE_API_KEY=your_youtube_key\nWHISPER_MODEL=base\n</code></pre>"},{"location":"docker/#building-and-running","title":"Building and Running","text":""},{"location":"docker/#build-the-image","title":"Build the Image","text":"<pre><code># Build the Docker image\ndocker build -t tgcaller-bot .\n\n# Build with specific tag\ndocker build -t tgcaller-bot:v1.0.0 .\n</code></pre>"},{"location":"docker/#run-single-container","title":"Run Single Container","text":"<pre><code># Run with environment file\ndocker run -d \\\n  --name tgcaller-bot \\\n  --env-file .env \\\n  -v $(pwd)/downloads:/app/downloads \\\n  -p 8080:8080 \\\n  tgcaller-bot\n\n# Run with inline environment variables\ndocker run -d \\\n  --name tgcaller-bot \\\n  -e API_ID=12345 \\\n  -e API_HASH=your_hash \\\n  -e BOT_TOKEN=your_token \\\n  tgcaller-bot\n</code></pre>"},{"location":"docker/#run-with-docker-compose","title":"Run with Docker Compose","text":"<pre><code># Start all services\ndocker-compose up -d\n\n# View logs\ndocker-compose logs -f tgcaller-bot\n\n# Stop services\ndocker-compose down\n\n# Rebuild and restart\ndocker-compose up -d --build\n</code></pre>"},{"location":"docker/#advanced-configuration","title":"Advanced Configuration","text":""},{"location":"docker/#multi-stage-build","title":"Multi-Stage Build","text":"<p>Optimize image size with multi-stage builds:</p> <pre><code># Build stage\nFROM python:3.11-slim as builder\n\nRUN apt-get update &amp;&amp; apt-get install -y \\\n    gcc \\\n    python3-dev \\\n    libffi-dev\n\nCOPY requirements.txt .\nRUN pip install --user -r requirements.txt\n\n# Runtime stage\nFROM python:3.11-slim\n\nRUN apt-get update &amp;&amp; apt-get install -y \\\n    ffmpeg \\\n    libopus0 \\\n    &amp;&amp; rm -rf /var/lib/apt/lists/*\n\nCOPY --from=builder /root/.local /root/.local\nCOPY . /app\n\nWORKDIR /app\nENV PATH=/root/.local/bin:$PATH\n\nCMD [\"python\", \"bot.py\"]\n</code></pre>"},{"location":"docker/#volume-mounts","title":"Volume Mounts","text":"<p>Configure persistent storage:</p> <pre><code>services:\n  tgcaller-bot:\n    volumes:\n      # Session files\n      - ./sessions:/app/sessions\n      # Downloaded media\n      - ./downloads:/app/downloads\n      # Application logs\n      - ./logs:/app/logs\n      # Configuration files\n      - ./config:/app/config:ro\n</code></pre>"},{"location":"docker/#network-configuration","title":"Network Configuration","text":"<pre><code>networks:\n  tgcaller-network:\n    driver: bridge\n    ipam:\n      config:\n        - subnet: 172.20.0.0/16\n</code></pre>"},{"location":"docker/#production-deployment","title":"Production Deployment","text":""},{"location":"docker/#resource-limits","title":"Resource Limits","text":"<pre><code>services:\n  tgcaller-bot:\n    deploy:\n      resources:\n        limits:\n          cpus: '2.0'\n          memory: 1G\n        reservations:\n          cpus: '0.5'\n          memory: 512M\n</code></pre>"},{"location":"docker/#health-checks","title":"Health Checks","text":"<pre><code>services:\n  tgcaller-bot:\n    healthcheck:\n      test: [\"CMD\", \"python\", \"-c\", \"import tgcaller; print('OK')\"]\n      interval: 30s\n      timeout: 10s\n      retries: 3\n      start_period: 40s\n</code></pre>"},{"location":"docker/#logging-configuration","title":"Logging Configuration","text":"<pre><code>services:\n  tgcaller-bot:\n    logging:\n      driver: \"json-file\"\n      options:\n        max-size: \"10m\"\n        max-file: \"3\"\n</code></pre>"},{"location":"docker/#monitoring","title":"Monitoring","text":""},{"location":"docker/#container-monitoring","title":"Container Monitoring","text":"<pre><code># View container stats\ndocker stats tgcaller-bot\n\n# View logs\ndocker logs -f tgcaller-bot\n\n# Execute commands in container\ndocker exec -it tgcaller-bot bash\n</code></pre>"},{"location":"docker/#health-monitoring","title":"Health Monitoring","text":"<pre><code># Check health status\ndocker inspect --format='{{.State.Health.Status}}' tgcaller-bot\n\n# View health check logs\ndocker inspect --format='{{range .State.Health.Log}}{{.Output}}{{end}}' tgcaller-bot\n</code></pre>"},{"location":"docker/#troubleshooting","title":"Troubleshooting","text":""},{"location":"docker/#common-issues","title":"Common Issues","text":"<p>Audio/Video not working: <pre><code># Check if audio devices are available\ndocker run --rm -it --device /dev/snd tgcaller-bot aplay -l\n</code></pre></p> <p>Permission errors: <pre><code># Fix file permissions\nsudo chown -R 1000:1000 ./sessions ./downloads ./logs\n</code></pre></p> <p>Memory issues: <pre><code># Increase memory limits\ndocker run -m 2g tgcaller-bot\n</code></pre></p>"},{"location":"docker/#debug-mode","title":"Debug Mode","text":"<p>Run container in debug mode:</p> <pre><code>docker run -it --rm \\\n  --env-file .env \\\n  tgcaller-bot \\\n  python -c \"\nimport tgcaller\nprint('TgCaller version:', tgcaller.__version__)\nprint('Debug mode active')\n\"\n</code></pre> <p>This Docker setup provides a robust, scalable deployment solution for TgCaller applications.</p>"},{"location":"faq/","title":"Frequently Asked Questions (FAQ)","text":"<p>Q: How do I install TgCaller? A: Refer to installation.md for detailed setup instructions.</p> <p>Q: Where can I report bugs? A: Please open an issue on the GitHub Issues page.</p> <p>Q: Does TgCaller support plugins? A: Yes. Visit plugins.md to learn how to create and use custom plugins.</p> <p>Q: Is there a C API available? A: Yes. Refer to the C API documentation for documentation and usage examples.</p> <p>If your question is not listed here, feel free to open an issue or start a discussion.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.8 or higher</li> <li>FFmpeg (for media processing)</li> <li>A Telegram account and API credentials</li> </ul>"},{"location":"installation/#system-dependencies","title":"System Dependencies","text":""},{"location":"installation/#ubuntudebian","title":"Ubuntu/Debian","text":"<pre><code>sudo apt update\nsudo apt install ffmpeg libopus-dev libffi-dev libnacl-dev python3-dev gcc\n</code></pre>"},{"location":"installation/#centosrhelfedora","title":"CentOS/RHEL/Fedora","text":"<pre><code>sudo dnf install ffmpeg opus-devel libffi-devel libsodium-devel python3-devel gcc\n</code></pre>"},{"location":"installation/#macos","title":"macOS","text":"<pre><code>brew install ffmpeg opus libffi libsodium\n</code></pre>"},{"location":"installation/#windows","title":"Windows","text":"<ol> <li>Download FFmpeg from https://ffmpeg.org/download.html</li> <li>Add FFmpeg to your system PATH</li> <li>Install Microsoft Visual C++ Build Tools</li> </ol>"},{"location":"installation/#python-package-installation","title":"Python Package Installation","text":""},{"location":"installation/#basic-installation","title":"Basic Installation","text":"<pre><code>pip install tgcaller\n</code></pre>"},{"location":"installation/#with-media-support","title":"With Media Support","text":"<pre><code>pip install tgcaller[media]\n</code></pre>"},{"location":"installation/#with-audio-processing","title":"With Audio Processing","text":"<pre><code>pip install tgcaller[audio]\n</code></pre>"},{"location":"installation/#with-advanced-features","title":"With Advanced Features","text":"<pre><code>pip install tgcaller[advanced]\n</code></pre>"},{"location":"installation/#complete-installation","title":"Complete Installation","text":"<pre><code>pip install tgcaller[all]\n</code></pre>"},{"location":"installation/#verify-installation","title":"Verify Installation","text":"<pre><code># Test installation\ntgcaller test\n\n# Check system info\ntgcaller info\n</code></pre> <p>Expected Output: <pre><code>\ud83e\uddea Testing TgCaller installation...\n\u2705 Pyrogram imported successfully\n\u2705 TgCaller types imported successfully\n\ud83c\udf89 TgCaller installation test completed successfully!\n</code></pre></p>"},{"location":"installation/#getting-api-credentials","title":"Getting API Credentials","text":"<ol> <li>Go to my.telegram.org</li> <li>Log in with your phone number</li> <li>Go to \"API Development Tools\"</li> <li>Create a new application</li> <li>Note down your <code>api_id</code> and <code>api_hash</code></li> </ol>"},{"location":"installation/#docker-installation","title":"Docker Installation","text":"<pre><code>FROM python:3.11-slim\n\n# Install system dependencies\nRUN apt-get update &amp;&amp; apt-get install -y \\\n    ffmpeg \\\n    libopus-dev \\\n    libffi-dev \\\n    libnacl-dev \\\n    python3-dev \\\n    gcc \\\n    &amp;&amp; rm -rf /var/lib/apt/lists/*\n\n# Install TgCaller\nRUN pip install tgcaller[all]\n\n# Copy your bot\nCOPY . /app\nWORKDIR /app\n\nCMD [\"python\", \"bot.py\"]\n</code></pre>"},{"location":"installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"installation/#common-issues","title":"Common Issues","text":""},{"location":"installation/#ffmpeg-not-found","title":"FFmpeg not found","text":"<pre><code># Check if FFmpeg is installed\nffmpeg -version\n\n# If not installed, install it using your package manager\n</code></pre>"},{"location":"installation/#permission-errors-on-linux","title":"Permission errors on Linux","text":"<pre><code># Install in user directory\npip install --user tgcaller\n</code></pre>"},{"location":"installation/#build-errors-on-windows","title":"Build errors on Windows","text":"<ul> <li>Install Microsoft Visual C++ Build Tools</li> <li>Use pre-compiled wheels: <code>pip install --only-binary=all tgcaller</code></li> </ul>"},{"location":"installation/#import-errors","title":"Import errors","text":"<pre><code># Reinstall with all dependencies\npip uninstall tgcaller\npip install tgcaller[all]\n</code></pre>"},{"location":"installation/#getting-help","title":"Getting Help","text":"<p>If you encounter issues:</p> <ol> <li>Check the GitHub Issues</li> <li>Join our Telegram Group</li> <li>Read the troubleshooting guide</li> </ol>"},{"location":"installation/#development-installation","title":"Development Installation","text":"<p>For contributing to TgCaller:</p> <pre><code># Clone the repository\ngit clone https://github.com/TgCaller/TgCaller.git\ncd TgCaller\n\n# Create virtual environment\npython -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\n\n# Install in development mode\npip install -e \".[dev]\"\n\n# Run tests\npytest tests/ -v\n</code></pre>"},{"location":"migration/","title":"\ud83d\udd04 Migration Guide: pytgcalls \u2192 TgCaller","text":""},{"location":"migration/#quick-migration-2-minutes","title":"Quick Migration (2 minutes)","text":""},{"location":"migration/#step-1-install-tgcaller","title":"Step 1: Install TgCaller","text":"<pre><code>pip uninstall pytgcalls\npip install tgcaller\n</code></pre>"},{"location":"migration/#step-2-update-imports","title":"Step 2: Update Imports","text":"<pre><code># OLD\nfrom pytgcalls import PyTgCalls\nfrom pytgcalls.types import Update\n\n# NEW\nfrom tgcaller import TgCaller\nfrom tgcaller.types import CallUpdate\n</code></pre>"},{"location":"migration/#step-3-update-code","title":"Step 3: Update Code","text":"<pre><code># OLD\npytgcalls = PyTgCalls(app)\n\n# NEW\ncaller = TgCaller(app)\n</code></pre>"},{"location":"migration/#complete-migration-examples","title":"Complete Migration Examples","text":""},{"location":"migration/#basic-audio-streaming","title":"Basic Audio Streaming","text":""},{"location":"migration/#before-pytgcalls","title":"Before (pytgcalls):","text":"<pre><code>from pytgcalls import PyTgCalls\nfrom pytgcalls.types import AudioPiped\n\npytgcalls = PyTgCalls(app)\n\n@pytgcalls.on_stream_end()\nasync def on_stream_end(client, update):\n    print(f\"Stream ended in {update.chat_id}\")\n\nawait pytgcalls.start()\naudio = AudioPiped(\"song.mp3\")\nawait pytgcalls.join_group_call(chat_id, stream=audio)\n</code></pre>"},{"location":"migration/#after-tgcaller","title":"After (TgCaller):","text":"<pre><code>from tgcaller import TgCaller, AudioConfig\n\ncaller = TgCaller(app)\n\n@caller.on_stream_end\nasync def on_stream_end(client, update):\n    print(f\"Stream ended in {update.chat_id}\")\n\nawait caller.start()\naudio_config = AudioConfig.high_quality()\nawait caller.join_call(chat_id, audio_config=audio_config)\nawait caller.play(chat_id, \"song.mp3\")\n</code></pre>"},{"location":"migration/#video-streaming","title":"Video Streaming","text":""},{"location":"migration/#before-pytgcalls_1","title":"Before (pytgcalls):","text":"<pre><code>from pytgcalls.types import AudioVideoPiped\n\nvideo = AudioVideoPiped(\"video.mp4\")\nawait pytgcalls.join_group_call(chat_id, stream=video)\n</code></pre>"},{"location":"migration/#after-tgcaller_1","title":"After (TgCaller):","text":"<pre><code>from tgcaller import VideoConfig\n\nvideo_config = VideoConfig.hd_720p()\nawait caller.join_call(chat_id, video_config=video_config)\nawait caller.play(chat_id, \"video.mp4\")\n</code></pre>"},{"location":"migration/#method-mapping","title":"Method Mapping","text":"pytgcalls TgCaller Notes <code>PyTgCalls(app)</code> <code>TgCaller(app)</code> Direct replacement <code>start()</code> <code>start()</code> Same <code>join_group_call()</code> <code>join_call()</code> Simplified <code>leave_group_call()</code> <code>leave_call()</code> Same <code>change_stream()</code> <code>play()</code> More intuitive <code>pause_stream()</code> <code>pause()</code> Simplified <code>resume_stream()</code> <code>resume()</code> Simplified"},{"location":"migration/#benefits-after-migration","title":"Benefits After Migration","text":"<ul> <li>Simpler API - Less boilerplate code</li> <li>Better Performance - Faster connection times</li> <li>More Reliable - Built-in error recovery</li> <li>Better Documentation - Comprehensive guides</li> <li>Active Support - Regular updates and community help</li> </ul>"},{"location":"migration/#need-help","title":"Need Help?","text":"<ul> <li>Documentation - Complete guides</li> <li>Telegram Group - Get help from community</li> <li>GitHub Issues - Report bugs</li> </ul>"},{"location":"plugins/","title":"\ud83d\udd0c Plugin Development Guide","text":"<p>TgCaller supports a powerful plugin system that allows you to extend functionality with custom features.</p>"},{"location":"plugins/#creating-a-plugin","title":"Creating a Plugin","text":""},{"location":"plugins/#basic-plugin-structure","title":"Basic Plugin Structure","text":"<pre><code>from tgcaller.plugins import BasePlugin\n\nclass MyPlugin(BasePlugin):\n    name = \"my_plugin\"\n    version = \"1.0.0\"\n    description = \"My custom plugin\"\n\n    def __init__(self, config=None):\n        super().__init__(config)\n        self.enabled = True\n\n    async def on_load(self):\n        \"\"\"Called when plugin is loaded\"\"\"\n        print(f\"Loading {self.name} plugin...\")\n\n    async def on_unload(self):\n        \"\"\"Called when plugin is unloaded\"\"\"\n        print(f\"Unloading {self.name} plugin...\")\n</code></pre>"},{"location":"plugins/#audio-processing-plugin","title":"Audio Processing Plugin","text":"<pre><code>from tgcaller.plugins import BasePlugin\nimport numpy as np\n\nclass VoiceEffectsPlugin(BasePlugin):\n    name = \"voice_effects\"\n\n    def __init__(self, config=None):\n        super().__init__(config)\n        self.effects = config.get('effects', []) if config else []\n\n    async def process_audio(self, audio_frame):\n        \"\"\"Process audio frame\"\"\"\n        if 'robot' in self.effects:\n            audio_frame = self.apply_robot_effect(audio_frame)\n\n        if 'echo' in self.effects:\n            audio_frame = self.apply_echo_effect(audio_frame)\n\n        return audio_frame\n\n    def apply_robot_effect(self, audio_frame):\n        \"\"\"Apply robot voice effect\"\"\"\n        # Simple pitch shifting\n        return audio_frame * 0.8\n\n    def apply_echo_effect(self, audio_frame):\n        \"\"\"Apply echo effect\"\"\"\n        # Simple echo implementation\n        echo_delay = int(0.3 * 48000)  # 300ms delay\n        echo_frame = np.zeros_like(audio_frame)\n\n        if len(audio_frame) &gt; echo_delay:\n            echo_frame[echo_delay:] = audio_frame[:-echo_delay] * 0.3\n            return audio_frame + echo_frame\n\n        return audio_frame\n</code></pre>"},{"location":"plugins/#video-processing-plugin","title":"Video Processing Plugin","text":"<pre><code>import cv2\nfrom tgcaller.plugins import BasePlugin\n\nclass VideoFiltersPlugin(BasePlugin):\n    name = \"video_filters\"\n\n    async def process_video(self, video_frame):\n        \"\"\"Process video frame\"\"\"\n        if self.config.get('blur'):\n            video_frame = cv2.GaussianBlur(video_frame, (15, 15), 0)\n\n        if self.config.get('grayscale'):\n            video_frame = cv2.cvtColor(video_frame, cv2.COLOR_BGR2GRAY)\n            video_frame = cv2.cvtColor(video_frame, cv2.COLOR_GRAY2BGR)\n\n        if self.config.get('sepia'):\n            video_frame = self.apply_sepia(video_frame)\n\n        return video_frame\n\n    def apply_sepia(self, frame):\n        \"\"\"Apply sepia effect\"\"\"\n        sepia_filter = np.array([\n            [0.272, 0.534, 0.131],\n            [0.349, 0.686, 0.168],\n            [0.393, 0.769, 0.189]\n        ])\n\n        sepia_frame = frame.dot(sepia_filter.T)\n        sepia_frame = np.clip(sepia_frame, 0, 255)\n        return sepia_frame.astype(np.uint8)\n</code></pre>"},{"location":"plugins/#event-handler-plugin","title":"Event Handler Plugin","text":"<pre><code>from tgcaller.plugins import BasePlugin\n\nclass LoggingPlugin(BasePlugin):\n    name = \"logging\"\n\n    async def on_stream_start(self, chat_id, source):\n        \"\"\"Called when stream starts\"\"\"\n        self.logger.info(f\"Stream started in {chat_id}: {source}\")\n\n    async def on_stream_end(self, chat_id):\n        \"\"\"Called when stream ends\"\"\"\n        self.logger.info(f\"Stream ended in {chat_id}\")\n\n    async def on_user_joined(self, chat_id, user_id):\n        \"\"\"Called when user joins call\"\"\"\n        self.logger.info(f\"User {user_id} joined call in {chat_id}\")\n\n    async def on_user_left(self, chat_id, user_id):\n        \"\"\"Called when user leaves call\"\"\"\n        self.logger.info(f\"User {user_id} left call in {chat_id}\")\n</code></pre>"},{"location":"plugins/#plugin-registration","title":"Plugin Registration","text":""},{"location":"plugins/#register-plugin-with-tgcaller","title":"Register Plugin with TgCaller","text":"<pre><code>from tgcaller import TgCaller\n\n# Create TgCaller instance\ncaller = TgCaller(app)\n\n# Register plugins\nvoice_effects = VoiceEffectsPlugin({\n    'effects': ['robot', 'echo']\n})\ncaller.register_plugin(voice_effects)\n\nvideo_filters = VideoFiltersPlugin({\n    'blur': True,\n    'sepia': False\n})\ncaller.register_plugin(video_filters)\n\nlogging_plugin = LoggingPlugin()\ncaller.register_plugin(logging_plugin)\n</code></pre>"},{"location":"plugins/#plugin-configuration","title":"Plugin Configuration","text":"<pre><code># Plugin with configuration\nplugin_config = {\n    'enabled': True,\n    'priority': 10,\n    'settings': {\n        'effect_strength': 0.8,\n        'buffer_size': 1024\n    }\n}\n\nplugin = MyPlugin(plugin_config)\ncaller.register_plugin(plugin)\n</code></pre>"},{"location":"plugins/#advanced-plugin-features","title":"Advanced Plugin Features","text":""},{"location":"plugins/#plugin-dependencies","title":"Plugin Dependencies","text":"<pre><code>class AdvancedPlugin(BasePlugin):\n    name = \"advanced_plugin\"\n    dependencies = [\"voice_effects\", \"logging\"]\n\n    async def on_load(self):\n        # Check if dependencies are loaded\n        for dep in self.dependencies:\n            if not self.caller.is_plugin_loaded(dep):\n                raise PluginError(f\"Dependency {dep} not found\")\n</code></pre>"},{"location":"plugins/#plugin-communication","title":"Plugin Communication","text":"<pre><code>class PluginA(BasePlugin):\n    name = \"plugin_a\"\n\n    async def send_message_to_plugin(self, plugin_name, message):\n        \"\"\"Send message to another plugin\"\"\"\n        await self.caller.send_plugin_message(plugin_name, message)\n\nclass PluginB(BasePlugin):\n    name = \"plugin_b\"\n\n    async def on_plugin_message(self, sender, message):\n        \"\"\"Receive message from another plugin\"\"\"\n        print(f\"Received from {sender}: {message}\")\n</code></pre>"},{"location":"plugins/#plugin-storage","title":"Plugin Storage","text":"<pre><code>class DataPlugin(BasePlugin):\n    name = \"data_plugin\"\n\n    async def save_data(self, key, value):\n        \"\"\"Save plugin data\"\"\"\n        await self.storage.set(key, value)\n\n    async def load_data(self, key):\n        \"\"\"Load plugin data\"\"\"\n        return await self.storage.get(key)\n\n    async def on_stream_start(self, chat_id, source):\n        # Save stream history\n        history = await self.load_data('stream_history') or []\n        history.append({\n            'chat_id': chat_id,\n            'source': source,\n            'timestamp': time.time()\n        })\n        await self.save_data('stream_history', history)\n</code></pre>"},{"location":"plugins/#plugin-examples","title":"Plugin Examples","text":""},{"location":"plugins/#music-queue-plugin","title":"Music Queue Plugin","text":"<pre><code>from collections import deque\nfrom tgcaller.plugins import BasePlugin\n\nclass MusicQueuePlugin(BasePlugin):\n    name = \"music_queue\"\n\n    def __init__(self, config=None):\n        super().__init__(config)\n        self.queues = {}  # chat_id -&gt; deque\n\n    def add_to_queue(self, chat_id, song):\n        \"\"\"Add song to queue\"\"\"\n        if chat_id not in self.queues:\n            self.queues[chat_id] = deque()\n\n        self.queues[chat_id].append(song)\n\n    def get_next_song(self, chat_id):\n        \"\"\"Get next song from queue\"\"\"\n        if chat_id in self.queues and self.queues[chat_id]:\n            return self.queues[chat_id].popleft()\n        return None\n\n    async def on_stream_end(self, chat_id):\n        \"\"\"Auto-play next song\"\"\"\n        next_song = self.get_next_song(chat_id)\n        if next_song:\n            await self.caller.play(chat_id, next_song)\n</code></pre>"},{"location":"plugins/#auto-moderator-plugin","title":"Auto-Moderator Plugin","text":"<pre><code>class AutoModeratorPlugin(BasePlugin):\n    name = \"auto_moderator\"\n\n    def __init__(self, config=None):\n        super().__init__(config)\n        self.max_users = config.get('max_users', 50) if config else 50\n        self.banned_users = set(config.get('banned_users', [])) if config else set()\n\n    async def on_user_joined(self, chat_id, user_id):\n        \"\"\"Check user when they join\"\"\"\n        # Check if user is banned\n        if user_id in self.banned_users:\n            await self.caller.kick_user(chat_id, user_id)\n            return\n\n        # Check user limit\n        active_users = await self.caller.get_call_participants(chat_id)\n        if len(active_users) &gt; self.max_users:\n            await self.caller.kick_user(chat_id, user_id)\n</code></pre>"},{"location":"plugins/#statistics-plugin","title":"Statistics Plugin","text":"<pre><code>import time\nfrom tgcaller.plugins import BasePlugin\n\nclass StatisticsPlugin(BasePlugin):\n    name = \"statistics\"\n\n    def __init__(self, config=None):\n        super().__init__(config)\n        self.stats = {\n            'total_calls': 0,\n            'total_duration': 0,\n            'streams_played': 0,\n            'users_served': set()\n        }\n        self.call_start_times = {}\n\n    async def on_call_start(self, chat_id):\n        \"\"\"Track call start\"\"\"\n        self.stats['total_calls'] += 1\n        self.call_start_times[chat_id] = time.time()\n\n    async def on_call_end(self, chat_id):\n        \"\"\"Track call end\"\"\"\n        if chat_id in self.call_start_times:\n            duration = time.time() - self.call_start_times[chat_id]\n            self.stats['total_duration'] += duration\n            del self.call_start_times[chat_id]\n\n    async def on_stream_start(self, chat_id, source):\n        \"\"\"Track stream\"\"\"\n        self.stats['streams_played'] += 1\n\n    async def on_user_joined(self, chat_id, user_id):\n        \"\"\"Track unique users\"\"\"\n        self.stats['users_served'].add(user_id)\n\n    def get_statistics(self):\n        \"\"\"Get current statistics\"\"\"\n        stats = self.stats.copy()\n        stats['unique_users'] = len(self.stats['users_served'])\n        stats['average_call_duration'] = (\n            self.stats['total_duration'] / max(self.stats['total_calls'], 1)\n        )\n        return stats\n</code></pre>"},{"location":"plugins/#plugin-best-practices","title":"Plugin Best Practices","text":""},{"location":"plugins/#1-error-handling","title":"1. Error Handling","text":"<pre><code>class SafePlugin(BasePlugin):\n    async def process_audio(self, audio_frame):\n        try:\n            # Your processing code\n            return processed_frame\n        except Exception as e:\n            self.logger.error(f\"Audio processing error: {e}\")\n            return audio_frame  # Return original on error\n</code></pre>"},{"location":"plugins/#2-performance-optimization","title":"2. Performance Optimization","text":"<pre><code>class OptimizedPlugin(BasePlugin):\n    def __init__(self, config=None):\n        super().__init__(config)\n        self.buffer_pool = []  # Reuse buffers\n        self.cache = {}  # Cache expensive operations\n\n    async def process_audio(self, audio_frame):\n        # Use object pooling for better performance\n        buffer = self.get_buffer()\n        try:\n            # Process audio\n            return processed_frame\n        finally:\n            self.return_buffer(buffer)\n</code></pre>"},{"location":"plugins/#3-configuration-validation","title":"3. Configuration Validation","text":"<pre><code>class ConfigurablePlugin(BasePlugin):\n    def __init__(self, config=None):\n        super().__init__(config)\n        self.validate_config()\n\n    def validate_config(self):\n        \"\"\"Validate plugin configuration\"\"\"\n        if self.config:\n            if 'required_setting' not in self.config:\n                raise ValueError(\"required_setting is missing\")\n\n            if not isinstance(self.config['required_setting'], int):\n                raise TypeError(\"required_setting must be an integer\")\n</code></pre>"},{"location":"plugins/#4-resource-cleanup","title":"4. Resource Cleanup","text":"<pre><code>class ResourcePlugin(BasePlugin):\n    def __init__(self, config=None):\n        super().__init__(config)\n        self.resources = []\n\n    async def on_load(self):\n        # Initialize resources\n        self.resources.append(SomeResource())\n\n    async def on_unload(self):\n        # Cleanup resources\n        for resource in self.resources:\n            await resource.cleanup()\n        self.resources.clear()\n</code></pre>"},{"location":"plugins/#plugin-testing","title":"Plugin Testing","text":"<pre><code>import pytest\nfrom unittest.mock import Mock\nfrom tgcaller.plugins import BasePlugin\n\nclass TestMyPlugin:\n    @pytest.fixture\n    def plugin(self):\n        config = {'test_setting': True}\n        return MyPlugin(config)\n\n    @pytest.mark.asyncio\n    async def test_audio_processing(self, plugin):\n        # Test audio processing\n        input_frame = np.random.random(1024)\n        output_frame = await plugin.process_audio(input_frame)\n\n        assert output_frame is not None\n        assert len(output_frame) == len(input_frame)\n\n    def test_configuration(self, plugin):\n        # Test configuration\n        assert plugin.config['test_setting'] is True\n</code></pre> <p>This plugin system allows you to extend TgCaller with custom functionality while maintaining clean separation of concerns and easy testing.</p>"},{"location":"troubleshooting/","title":"Troubleshooting","text":"<p>If you're facing issues while installing or running TgCaller, this guide covers common problems and how to resolve them.</p>"},{"location":"troubleshooting/#installation-issues","title":"Installation Issues","text":"<ul> <li>Ensure all required dependencies (Python, FFmpeg, etc.) are properly installed.</li> <li>Follow each step in installation.md carefully.</li> <li>If you're using a virtual environment, activate it before running any commands.</li> <li>Check Python version compatibility (Python 3.8+ recommended).</li> </ul>"},{"location":"troubleshooting/#runtime-errors","title":"Runtime Errors","text":"<ul> <li>Always check the error output or logs for detailed messages.</li> <li>Make sure your system supports all required libraries and codecs.</li> <li>Verify your FFmpeg version is up to date and accessible from the shell.</li> <li>Ensure the bot/token/Telegram client is configured correctly.</li> </ul>"},{"location":"troubleshooting/#unexpected-behavior","title":"Unexpected Behavior","text":"<ul> <li>Restart the process to rule out temporary issues.</li> <li>Clear any cached <code>.pyc</code> files if the behavior is inconsistent.</li> <li>Confirm your code matches the latest version of TgCaller.</li> </ul>"},{"location":"troubleshooting/#still-need-help","title":"Still Need Help?","text":"<ul> <li>Review the FAQ for common questions</li> <li>Open a GitHub Issue with:</li> <li>A description of the problem</li> <li>Exact error output (logs, stack traces)</li> <li>Your system info and Python version</li> </ul> <p>The more details you provide, the easier it is for us to help.</p>"},{"location":"usage/","title":"Usage Guide","text":""},{"location":"usage/#basic-usage","title":"Basic Usage","text":""},{"location":"usage/#setting-up-your-first-bot","title":"Setting Up Your First Bot","text":"<pre><code>import asyncio\nfrom pyrogram import Client\nfrom tgcaller import TgCaller\n\n# Your API credentials\nAPI_ID = 12345\nAPI_HASH = \"your_api_hash\"\nBOT_TOKEN = \"your_bot_token\"\n\n# Initialize Pyrogram client\napp = Client(\"my_bot\", api_id=API_ID, api_hash=API_HASH, bot_token=BOT_TOKEN)\n\n# Initialize TgCaller\ncaller = TgCaller(app)\n\nasync def main():\n    # Start TgCaller\n    await caller.start()\n\n    # Your bot logic here\n    chat_id = -1001234567890  # Your group chat ID\n\n    # Join voice call\n    await caller.join_call(chat_id)\n\n    # Play audio file\n    await caller.play(chat_id, \"song.mp3\")\n\n    # Keep running\n    await asyncio.Event().wait()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"usage/#audio-configuration","title":"Audio Configuration","text":""},{"location":"usage/#quality-presets","title":"Quality Presets","text":"<pre><code>from tgcaller import AudioConfig\n\n# High quality audio (128kbps, stereo, 48kHz)\naudio_config = AudioConfig.high_quality()\n\n# Low bandwidth audio (32kbps, mono, 24kHz)\naudio_config = AudioConfig.low_bandwidth()\n\n# Voice call optimized\naudio_config = AudioConfig.voice_call()\n</code></pre>"},{"location":"usage/#custom-audio-configuration","title":"Custom Audio Configuration","text":"<pre><code>audio_config = AudioConfig(\n    bitrate=128000,           # 128 kbps\n    sample_rate=48000,        # 48 kHz\n    channels=2,               # Stereo\n    noise_suppression=True,   # Clean audio\n    echo_cancellation=True    # No echo\n)\n\nawait caller.play(chat_id, \"song.mp3\", audio_config=audio_config)\n</code></pre>"},{"location":"usage/#video-configuration","title":"Video Configuration","text":""},{"location":"usage/#video-presets","title":"Video Presets","text":"<pre><code>from tgcaller import VideoConfig\n\n# HD 720p video\nvideo_config = VideoConfig.hd_720p()\n\n# Full HD 1080p video\nvideo_config = VideoConfig.full_hd_1080p()\n\n# Low quality for poor connections\nvideo_config = VideoConfig.low_quality()\n</code></pre>"},{"location":"usage/#custom-video-configuration","title":"Custom Video Configuration","text":"<pre><code>video_config = VideoConfig(\n    width=1920,\n    height=1080,\n    fps=30,\n    bitrate=2000000,          # 2 Mbps\n    codec=\"h264\"\n)\n\nawait caller.play(chat_id, \"video.mp4\", video_config=video_config)\n</code></pre>"},{"location":"usage/#event-handling","title":"Event Handling","text":""},{"location":"usage/#stream-events","title":"Stream Events","text":"<pre><code>@caller.on_stream_end\nasync def on_stream_end(client, update):\n    print(f\"Stream ended in {update.chat_id}\")\n    # Auto-play next song\n    await caller.play(update.chat_id, \"next_song.mp3\")\n\n@caller.on_stream_start\nasync def on_stream_start(client, update):\n    print(f\"Stream started in {update.chat_id}\")\n\n@caller.on_error\nasync def on_error(client, error):\n    print(f\"Error occurred: {error}\")\n</code></pre>"},{"location":"usage/#call-events","title":"Call Events","text":"<pre><code>@caller.on_kicked\nasync def on_kicked(client, update):\n    print(f\"Kicked from {update.chat_id}\")\n\n@caller.on_left\nasync def on_left(client, update):\n    print(f\"Left call {update.chat_id}\")\n</code></pre>"},{"location":"usage/#stream-control","title":"Stream Control","text":""},{"location":"usage/#basic-controls","title":"Basic Controls","text":"<pre><code># Pause stream\nawait caller.pause(chat_id)\n\n# Resume stream\nawait caller.resume(chat_id)\n\n# Stop stream\nawait caller.stop_stream(chat_id)\n\n# Set volume (0.0 to 1.0)\nawait caller.set_volume(chat_id, 0.8)\n\n# Seek to position (in seconds)\nawait caller.seek(chat_id, 60.0)\n\n# Get current position\nposition = await caller.get_position(chat_id)\n</code></pre>"},{"location":"usage/#music-bot-example","title":"Music Bot Example","text":"<pre><code>from pyrogram import Client, filters\nfrom tgcaller import TgCaller, AudioConfig\n\napp = Client(\"music_bot\")\ncaller = TgCaller(app)\n\n@app.on_message(filters.command(\"play\"))\nasync def play_music(client, message):\n    if len(message.command) &lt; 2:\n        return await message.reply(\"Usage: /play &lt;song_name&gt;\")\n\n    song = message.command[1]\n    chat_id = message.chat.id\n\n    # Join call if not already joined\n    if not caller.is_connected(chat_id):\n        await caller.join_call(chat_id)\n        await message.reply(\"\ud83d\udcde Joined voice chat!\")\n\n    # Play song\n    audio_config = AudioConfig.high_quality()\n    await caller.play(chat_id, f\"music/{song}.mp3\", audio_config=audio_config)\n    await message.reply(f\"\ud83c\udfb5 Playing: {song}\")\n\n@app.on_message(filters.command(\"pause\"))\nasync def pause_music(client, message):\n    if await caller.pause(message.chat.id):\n        await message.reply(\"\u23f8\ufe0f Music paused\")\n\n@app.on_message(filters.command(\"resume\"))\nasync def resume_music(client, message):\n    if await caller.resume(message.chat.id):\n        await message.reply(\"\u25b6\ufe0f Music resumed\")\n\n@app.on_message(filters.command(\"stop\"))\nasync def stop_music(client, message):\n    if await caller.stop_stream(message.chat.id):\n        await message.reply(\"\u23f9\ufe0f Music stopped\")\n\n@app.on_message(filters.command(\"leave\"))\nasync def leave_call(client, message):\n    if await caller.leave_call(message.chat.id):\n        await message.reply(\"\ud83d\udc4b Left voice chat\")\n\n@caller.on_stream_end\nasync def on_stream_end(client, update):\n    print(f\"Stream ended in {update.chat_id}\")\n\napp.run()\n</code></pre>"},{"location":"usage/#advanced-features","title":"Advanced Features","text":""},{"location":"usage/#youtube-streaming","title":"YouTube Streaming","text":"<pre><code>from tgcaller.advanced import YouTubeStreamer\n\nyoutube = YouTubeStreamer(caller)\n\n# Play YouTube video directly\nawait youtube.play_youtube_url(chat_id, \"https://youtube.com/watch?v=...\")\n\n# Search and play\nawait youtube.search_and_play(chat_id, \"relaxing music\", index=0)\n</code></pre>"},{"location":"usage/#screen-sharing","title":"Screen Sharing","text":"<pre><code>from tgcaller.advanced import ScreenShareStreamer\n\nscreen_streamer = ScreenShareStreamer(caller, chat_id)\n\n# Start screen sharing\nawait screen_streamer.start_streaming(monitor_index=1)\n\n# Stop screen sharing\nawait screen_streamer.stop_streaming()\n</code></pre>"},{"location":"usage/#microphone-streaming","title":"Microphone Streaming","text":"<pre><code>from tgcaller.advanced import MicrophoneStreamer\n\nmic_streamer = MicrophoneStreamer(caller, chat_id)\n\n# Start microphone streaming\nawait mic_streamer.start_streaming()\n\n# Stop microphone streaming\nawait mic_streamer.stop_streaming()\n</code></pre>"},{"location":"usage/#audio-filters","title":"Audio Filters","text":"<pre><code>from tgcaller.advanced import AudioFilters, FilterChain\n\n# Create filter chain\nfilter_chain = FilterChain()\naudio_filters = AudioFilters()\n\n# Add echo effect\nfilter_chain.add_audio_filter(\n    audio_filters.apply_echo,\n    delay=0.3,\n    decay=0.5\n)\n\n# Add reverb effect\nfilter_chain.add_audio_filter(\n    audio_filters.apply_reverb,\n    room_size=0.7,\n    damping=0.4\n)\n\n# Process audio through filters\nfiltered_audio = filter_chain.process_audio(audio_data)\n</code></pre>"},{"location":"usage/#error-handling","title":"Error Handling","text":"<pre><code>from tgcaller.exceptions import TgCallerError, ConnectionError, MediaError\n\ntry:\n    await caller.play(chat_id, \"song.mp3\")\nexcept MediaError as e:\n    print(f\"Media error: {e}\")\nexcept ConnectionError as e:\n    print(f\"Connection error: {e}\")\nexcept TgCallerError as e:\n    print(f\"TgCaller error: {e}\")\n</code></pre>"},{"location":"usage/#best-practices","title":"Best Practices","text":""},{"location":"usage/#1-always-handle-errors","title":"1. Always Handle Errors","text":"<pre><code>try:\n    await caller.join_call(chat_id)\nexcept Exception as e:\n    print(f\"Failed to join call: {e}\")\n</code></pre>"},{"location":"usage/#2-check-connection-status","title":"2. Check Connection Status","text":"<pre><code>if not caller.is_connected(chat_id):\n    await caller.join_call(chat_id)\n</code></pre>"},{"location":"usage/#3-cleanup-resources","title":"3. Cleanup Resources","text":"<pre><code>async def cleanup():\n    # Leave all calls\n    for chat_id in caller.get_active_calls():\n        await caller.leave_call(chat_id)\n\n    # Stop TgCaller\n    await caller.stop()\n</code></pre>"},{"location":"usage/#4-use-appropriate-quality-settings","title":"4. Use Appropriate Quality Settings","text":"<pre><code># For music streaming\naudio_config = AudioConfig.high_quality()\n\n# For voice calls\naudio_config = AudioConfig.voice_call()\n\n# For poor connections\naudio_config = AudioConfig.low_bandwidth()\n</code></pre>"},{"location":"c-api/advanced-methods/","title":"Advanced Methods","text":""},{"location":"c-api/advanced-methods/#screen-sharing","title":"Screen Sharing","text":""},{"location":"c-api/advanced-methods/#start-screen-sharing","title":"Start Screen Sharing","text":"<pre><code>#include \"tgcaller.h\"\n\n// Screen sharing configuration\nTgCallerScreenConfig screen_config = {\n    .monitor_index = 0,        // Primary monitor\n    .x = 0,                    // Capture from x=0\n    .y = 0,                    // Capture from y=0\n    .width = 1920,             // Capture width\n    .height = 1080,            // Capture height\n    .fps = 30,                 // 30 FPS\n    .quality = TGCALLER_QUALITY_HIGH\n};\n\n// Start screen sharing\nTgCallerError error = tgcaller_start_screen_share(caller, chat_id, &amp;screen_config);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Screen sharing started\\n\");\n} else {\n    fprintf(stderr, \"Failed to start screen sharing: %s\\n\", tgcaller_error_string(error));\n}\n</code></pre>"},{"location":"c-api/advanced-methods/#stop-screen-sharing","title":"Stop Screen Sharing","text":"<pre><code>// Stop screen sharing\nTgCallerError error = tgcaller_stop_screen_share(caller, chat_id);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Screen sharing stopped\\n\");\n}\n</code></pre>"},{"location":"c-api/advanced-methods/#list-available-monitors","title":"List Available Monitors","text":"<pre><code>// Get available monitors\nTgCallerMonitorInfo* monitors = NULL;\nsize_t monitor_count = 0;\n\nTgCallerError error = tgcaller_get_monitors(&amp;monitors, &amp;monitor_count);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Available monitors (%zu):\\n\", monitor_count);\n\n    for (size_t i = 0; i &lt; monitor_count; i++) {\n        printf(\"  Monitor %zu: %dx%d at (%d, %d)\\n\",\n               i,\n               monitors[i].width,\n               monitors[i].height,\n               monitors[i].x,\n               monitors[i].y);\n    }\n\n    // Free the allocated memory\n    free(monitors);\n} else {\n    fprintf(stderr, \"Failed to get monitors: %s\\n\", tgcaller_error_string(error));\n}\n</code></pre>"},{"location":"c-api/advanced-methods/#microphone-streaming","title":"Microphone Streaming","text":""},{"location":"c-api/advanced-methods/#start-microphone-stream","title":"Start Microphone Stream","text":"<pre><code>// Microphone configuration\nTgCallerMicConfig mic_config = {\n    .device_index = -1,        // Default device\n    .sample_rate = 48000,      // 48 kHz\n    .channels = 1,             // Mono\n    .noise_suppression = true,\n    .echo_cancellation = true,\n    .auto_gain_control = true\n};\n\n// Start microphone streaming\nTgCallerError error = tgcaller_start_microphone(caller, chat_id, &amp;mic_config);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Microphone streaming started\\n\");\n} else {\n    fprintf(stderr, \"Failed to start microphone: %s\\n\", tgcaller_error_string(error));\n}\n</code></pre>"},{"location":"c-api/advanced-methods/#stop-microphone-stream","title":"Stop Microphone Stream","text":"<pre><code>// Stop microphone streaming\nTgCallerError error = tgcaller_stop_microphone(caller, chat_id);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Microphone streaming stopped\\n\");\n}\n</code></pre>"},{"location":"c-api/advanced-methods/#list-audio-devices","title":"List Audio Devices","text":"<pre><code>// Get available audio input devices\nTgCallerAudioDevice* devices = NULL;\nsize_t device_count = 0;\n\nTgCallerError error = tgcaller_get_audio_devices(&amp;devices, &amp;device_count);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Available audio devices (%zu):\\n\", device_count);\n\n    for (size_t i = 0; i &lt; device_count; i++) {\n        printf(\"  Device %d: %s (%d channels, %.0f Hz)\\n\",\n               devices[i].index,\n               devices[i].name,\n               devices[i].max_channels,\n               devices[i].default_sample_rate);\n    }\n\n    // Free the allocated memory\n    free(devices);\n} else {\n    fprintf(stderr, \"Failed to get audio devices: %s\\n\", tgcaller_error_string(error));\n}\n</code></pre>"},{"location":"c-api/advanced-methods/#youtube-integration","title":"YouTube Integration","text":""},{"location":"c-api/advanced-methods/#play-youtube-video","title":"Play YouTube Video","text":"<pre><code>// Play YouTube video directly\nconst char* youtube_url = \"https://www.youtube.com/watch?v=dQw4w9WgXcQ\";\n\nTgCallerError error = tgcaller_play_youtube(caller, chat_id, youtube_url);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Started playing YouTube video\\n\");\n} else {\n    fprintf(stderr, \"Failed to play YouTube video: %s\\n\", tgcaller_error_string(error));\n}\n</code></pre>"},{"location":"c-api/advanced-methods/#search-and-play-youtube","title":"Search and Play YouTube","text":"<pre><code>// Search YouTube and play first result\nconst char* search_query = \"relaxing music\";\n\nTgCallerError error = tgcaller_search_and_play_youtube(caller, chat_id, search_query);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Started playing YouTube search result\\n\");\n} else {\n    fprintf(stderr, \"Failed to search and play: %s\\n\", tgcaller_error_string(error));\n}\n</code></pre>"},{"location":"c-api/advanced-methods/#get-youtube-video-info","title":"Get YouTube Video Info","text":"<pre><code>// Get video information\nTgCallerYouTubeInfo video_info;\nconst char* youtube_url = \"https://www.youtube.com/watch?v=dQw4w9WgXcQ\";\n\nTgCallerError error = tgcaller_get_youtube_info(youtube_url, &amp;video_info);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Video Info:\\n\");\n    printf(\"  Title: %s\\n\", video_info.title);\n    printf(\"  Duration: %d seconds\\n\", video_info.duration);\n    printf(\"  Uploader: %s\\n\", video_info.uploader);\n    printf(\"  Views: %lld\\n\", video_info.view_count);\n\n    // Free allocated strings\n    free(video_info.title);\n    free(video_info.uploader);\n} else {\n    fprintf(stderr, \"Failed to get video info: %s\\n\", tgcaller_error_string(error));\n}\n</code></pre>"},{"location":"c-api/advanced-methods/#speech-transcription","title":"Speech Transcription","text":""},{"location":"c-api/advanced-methods/#start-transcription","title":"Start Transcription","text":"<pre><code>// Transcription configuration\nTgCallerTranscriptionConfig transcription_config = {\n    .model = TGCALLER_WHISPER_BASE,    // Whisper model\n    .language = \"en\",                   // Language (NULL for auto-detect)\n    .real_time = true,                  // Real-time transcription\n    .confidence_threshold = 0.5f        // Minimum confidence\n};\n\n// Transcription callback\nvoid transcription_callback(const char* text, float confidence, void* user_data) {\n    printf(\"Transcription (%.1f%%): %s\\n\", confidence * 100, text);\n}\n\n// Start transcription\nTgCallerError error = tgcaller_start_transcription(\n    caller, \n    chat_id, \n    &amp;transcription_config,\n    transcription_callback,\n    NULL  // user_data\n);\n\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Transcription started\\n\");\n} else {\n    fprintf(stderr, \"Failed to start transcription: %s\\n\", tgcaller_error_string(error));\n}\n</code></pre>"},{"location":"c-api/advanced-methods/#stop-transcription","title":"Stop Transcription","text":"<pre><code>// Stop transcription\nTgCallerError error = tgcaller_stop_transcription(caller, chat_id);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Transcription stopped\\n\");\n}\n</code></pre>"},{"location":"c-api/advanced-methods/#transcribe-audio-file","title":"Transcribe Audio File","text":"<pre><code>// Transcribe audio file\nTgCallerTranscriptionResult result;\nconst char* audio_file = \"speech.wav\";\n\nTgCallerError error = tgcaller_transcribe_file(audio_file, \"en\", &amp;result);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Transcription Result:\\n\");\n    printf(\"  Text: %s\\n\", result.text);\n    printf(\"  Language: %s\\n\", result.language);\n    printf(\"  Confidence: %.1f%%\\n\", result.confidence * 100);\n    printf(\"  Duration: %.1f seconds\\n\", result.duration);\n\n    // Free allocated strings\n    free(result.text);\n    free(result.language);\n} else {\n    fprintf(stderr, \"Failed to transcribe file: %s\\n\", tgcaller_error_string(error));\n}\n</code></pre>"},{"location":"c-api/advanced-methods/#audiovideo-filters","title":"Audio/Video Filters","text":""},{"location":"c-api/advanced-methods/#apply-audio-filters","title":"Apply Audio Filters","text":"<pre><code>// Audio filter configuration\nTgCallerAudioFilter audio_filter = {\n    .type = TGCALLER_FILTER_ECHO,\n    .parameters = {\n        .echo = {\n            .delay = 0.3f,      // 300ms delay\n            .decay = 0.5f       // 50% decay\n        }\n    }\n};\n\n// Apply audio filter\nTgCallerError error = tgcaller_add_audio_filter(caller, chat_id, &amp;audio_filter);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Audio filter applied\\n\");\n} else {\n    fprintf(stderr, \"Failed to apply audio filter: %s\\n\", tgcaller_error_string(error));\n}\n</code></pre>"},{"location":"c-api/advanced-methods/#apply-video-filters","title":"Apply Video Filters","text":"<pre><code>// Video filter configuration\nTgCallerVideoFilter video_filter = {\n    .type = TGCALLER_FILTER_BLUR,\n    .parameters = {\n        .blur = {\n            .kernel_size = 15   // Blur intensity\n        }\n    }\n};\n\n// Apply video filter\nTgCallerError error = tgcaller_add_video_filter(caller, chat_id, &amp;video_filter);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Video filter applied\\n\");\n} else {\n    fprintf(stderr, \"Failed to apply video filter: %s\\n\", tgcaller_error_string(error));\n}\n</code></pre>"},{"location":"c-api/advanced-methods/#remove-filters","title":"Remove Filters","text":"<pre><code>// Remove all audio filters\nTgCallerError error = tgcaller_clear_audio_filters(caller, chat_id);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Audio filters cleared\\n\");\n}\n\n// Remove all video filters\nerror = tgcaller_clear_video_filters(caller, chat_id);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Video filters cleared\\n\");\n}\n</code></pre>"},{"location":"c-api/advanced-methods/#bridged-calls","title":"Bridged Calls","text":""},{"location":"c-api/advanced-methods/#create-bridge","title":"Create Bridge","text":"<pre><code>// Create bridge between multiple chats\nint64_t chat_ids[] = {-1001234567890, -1009876543210, -1001122334455};\nsize_t chat_count = 3;\n\nTgCallerError error = tgcaller_create_bridge(caller, \"conference\", chat_ids, chat_count);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Bridge created successfully\\n\");\n} else {\n    fprintf(stderr, \"Failed to create bridge: %s\\n\", tgcaller_error_string(error));\n}\n</code></pre>"},{"location":"c-api/advanced-methods/#destroy-bridge","title":"Destroy Bridge","text":"<pre><code>// Destroy bridge\nTgCallerError error = tgcaller_destroy_bridge(caller, \"conference\");\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Bridge destroyed\\n\");\n}\n</code></pre>"},{"location":"c-api/advanced-methods/#add-chat-to-bridge","title":"Add Chat to Bridge","text":"<pre><code>// Add chat to existing bridge\nint64_t new_chat_id = -1005566778899;\n\nTgCallerError error = tgcaller_bridge_add_chat(caller, \"conference\", new_chat_id);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Chat added to bridge\\n\");\n}\n</code></pre>"},{"location":"c-api/advanced-methods/#plugin-system","title":"Plugin System","text":""},{"location":"c-api/advanced-methods/#load-plugin","title":"Load Plugin","text":"<pre><code>// Load plugin from shared library\nconst char* plugin_path = \"./plugins/echo_plugin.so\";\n\nTgCallerError error = tgcaller_load_plugin(caller, plugin_path);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Plugin loaded successfully\\n\");\n} else {\n    fprintf(stderr, \"Failed to load plugin: %s\\n\", tgcaller_error_string(error));\n}\n</code></pre>"},{"location":"c-api/advanced-methods/#unload-plugin","title":"Unload Plugin","text":"<pre><code>// Unload plugin\nTgCallerError error = tgcaller_unload_plugin(caller, \"echo_plugin\");\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Plugin unloaded\\n\");\n}\n</code></pre>"},{"location":"c-api/advanced-methods/#list-loaded-plugins","title":"List Loaded Plugins","text":"<pre><code>// Get list of loaded plugins\nchar** plugin_names = NULL;\nsize_t plugin_count = 0;\n\nTgCallerError error = tgcaller_get_loaded_plugins(caller, &amp;plugin_names, &amp;plugin_count);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Loaded plugins (%zu):\\n\", plugin_count);\n\n    for (size_t i = 0; i &lt; plugin_count; i++) {\n        printf(\"  %s\\n\", plugin_names[i]);\n        free(plugin_names[i]);  // Free individual strings\n    }\n\n    free(plugin_names);  // Free array\n} else {\n    fprintf(stderr, \"Failed to get loaded plugins: %s\\n\", tgcaller_error_string(error));\n}\n</code></pre>"},{"location":"c-api/advanced-methods/#complete-advanced-example","title":"Complete Advanced Example","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#include \"tgcaller.h\"\n\nvoid transcription_callback(const char* text, float confidence, void* user_data) {\n    printf(\"\ud83c\udfa4 Transcription (%.1f%%): %s\\n\", confidence * 100, text);\n}\n\nint main() {\n    TgCaller* caller = tgcaller_create();\n    if (!caller) return -1;\n\n    // Setup and start\n    tgcaller_set_credentials(caller, 12345, \"api_hash\");\n    tgcaller_start(caller);\n\n    int64_t chat_id = -1001234567890;\n\n    // Join call\n    tgcaller_join_call(caller, chat_id);\n\n    // Start screen sharing\n    TgCallerScreenConfig screen_config = {\n        .monitor_index = 0,\n        .fps = 30,\n        .quality = TGCALLER_QUALITY_HIGH\n    };\n    tgcaller_start_screen_share(caller, chat_id, &amp;screen_config);\n\n    // Start transcription\n    TgCallerTranscriptionConfig transcription_config = {\n        .model = TGCALLER_WHISPER_BASE,\n        .language = \"en\",\n        .real_time = true,\n        .confidence_threshold = 0.7f\n    };\n    tgcaller_start_transcription(caller, chat_id, &amp;transcription_config, transcription_callback, NULL);\n\n    // Apply audio filter\n    TgCallerAudioFilter echo_filter = {\n        .type = TGCALLER_FILTER_ECHO,\n        .parameters.echo = { .delay = 0.3f, .decay = 0.4f }\n    };\n    tgcaller_add_audio_filter(caller, chat_id, &amp;echo_filter);\n\n    // Run for 60 seconds\n    sleep(60);\n\n    // Cleanup\n    tgcaller_stop_screen_share(caller, chat_id);\n    tgcaller_stop_transcription(caller, chat_id);\n    tgcaller_clear_audio_filters(caller, chat_id);\n    tgcaller_leave_call(caller, chat_id);\n    tgcaller_stop(caller);\n    tgcaller_destroy(caller);\n\n    return 0;\n}\n</code></pre>"},{"location":"c-api/async/","title":"Using Async","text":""},{"location":"c-api/async/#asynchronous-operations","title":"Asynchronous Operations","text":"<p>TgCaller C API supports asynchronous operations for non-blocking execution.</p>"},{"location":"c-api/async/#async-callbacks","title":"Async Callbacks","text":"<pre><code>#include \"tgcaller.h\"\n\n// Async callback for stream operations\nvoid stream_callback(TgCallerResult result, void* user_data) {\n    if (result.success) {\n        printf(\"Stream operation completed successfully\\n\");\n    } else {\n        printf(\"Stream operation failed: %s\\n\", result.error_message);\n    }\n}\n\n// Start async stream\nTgCallerError error = tgcaller_play_async(\n    caller,\n    chat_id,\n    \"audio.mp3\",\n    stream_callback,\n    NULL  // user_data\n);\n</code></pre>"},{"location":"c-api/async/#event-loop-integration","title":"Event Loop Integration","text":"<pre><code>// Run event loop\nwhile (tgcaller_is_running(caller)) {\n    tgcaller_process_events(caller);\n    usleep(1000);  // 1ms delay\n}\n</code></pre>"},{"location":"c-api/async/#thread-safety","title":"Thread Safety","text":"<pre><code>#include &lt;pthread.h&gt;\n\npthread_mutex_t tgcaller_mutex = PTHREAD_MUTEX_INITIALIZER;\n\nvoid thread_safe_operation() {\n    pthread_mutex_lock(&amp;tgcaller_mutex);\n\n    // TgCaller operations here\n    tgcaller_join_call(caller, chat_id);\n\n    pthread_mutex_unlock(&amp;tgcaller_mutex);\n}\n</code></pre>"},{"location":"c-api/async/#async-examples","title":"Async Examples","text":""},{"location":"c-api/async/#async-file-playing","title":"Async File Playing","text":"<pre><code>typedef struct {\n    char* filename;\n    int chat_id;\n} PlayContext;\n\nvoid play_complete_callback(TgCallerResult result, void* user_data) {\n    PlayContext* ctx = (PlayContext*)user_data;\n\n    if (result.success) {\n        printf(\"Finished playing: %s in chat %d\\n\", ctx-&gt;filename, ctx-&gt;chat_id);\n    }\n\n    free(ctx-&gt;filename);\n    free(ctx);\n}\n\nvoid play_file_async(TgCaller* caller, int chat_id, const char* filename) {\n    PlayContext* ctx = malloc(sizeof(PlayContext));\n    ctx-&gt;filename = strdup(filename);\n    ctx-&gt;chat_id = chat_id;\n\n    tgcaller_play_async(caller, chat_id, filename, play_complete_callback, ctx);\n}\n</code></pre>"},{"location":"c-api/async/#async-queue-management","title":"Async Queue Management","text":"<pre><code>typedef struct {\n    char** queue;\n    int count;\n    int current;\n} PlayQueue;\n\nvoid queue_next_callback(TgCallerResult result, void* user_data) {\n    PlayQueue* queue = (PlayQueue*)user_data;\n\n    if (result.success &amp;&amp; queue-&gt;current &lt; queue-&gt;count - 1) {\n        queue-&gt;current++;\n        tgcaller_play_async(\n            caller, \n            chat_id, \n            queue-&gt;queue[queue-&gt;current],\n            queue_next_callback,\n            queue\n        );\n    }\n}\n</code></pre>"},{"location":"c-api/basic-methods/","title":"Basic Methods","text":""},{"location":"c-api/basic-methods/#core-functions","title":"Core Functions","text":""},{"location":"c-api/basic-methods/#initialize-tgcaller","title":"Initialize TgCaller","text":"<pre><code>#include \"tgcaller.h\"\n\nTgCaller* caller = tgcaller_create();\nif (!caller) {\n    fprintf(stderr, \"Failed to create TgCaller instance\\n\");\n    return -1;\n}\n\n// Set API credentials\nTgCallerError error = tgcaller_set_credentials(caller, api_id, \"api_hash\");\nif (error != TGCALLER_SUCCESS) {\n    fprintf(stderr, \"Failed to set credentials: %s\\n\", tgcaller_error_string(error));\n    tgcaller_destroy(caller);\n    return -1;\n}\n</code></pre>"},{"location":"c-api/basic-methods/#start-tgcaller","title":"Start TgCaller","text":"<pre><code>// Start the service\nTgCallerError error = tgcaller_start(caller);\nif (error != TGCALLER_SUCCESS) {\n    fprintf(stderr, \"Failed to start TgCaller: %s\\n\", tgcaller_error_string(error));\n    return -1;\n}\n\nprintf(\"TgCaller started successfully\\n\");\n</code></pre>"},{"location":"c-api/basic-methods/#stop-tgcaller","title":"Stop TgCaller","text":"<pre><code>// Stop the service\nTgCallerError error = tgcaller_stop(caller);\nif (error != TGCALLER_SUCCESS) {\n    fprintf(stderr, \"Failed to stop TgCaller: %s\\n\", tgcaller_error_string(error));\n}\n\n// Cleanup\ntgcaller_destroy(caller);\n</code></pre>"},{"location":"c-api/basic-methods/#call-management","title":"Call Management","text":""},{"location":"c-api/basic-methods/#join-call","title":"Join Call","text":"<pre><code>// Join a voice call\nint64_t chat_id = -1001234567890;\nTgCallerError error = tgcaller_join_call(caller, chat_id);\n\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Successfully joined call in chat %lld\\n\", chat_id);\n} else {\n    fprintf(stderr, \"Failed to join call: %s\\n\", tgcaller_error_string(error));\n}\n</code></pre>"},{"location":"c-api/basic-methods/#leave-call","title":"Leave Call","text":"<pre><code>// Leave the call\nTgCallerError error = tgcaller_leave_call(caller, chat_id);\n\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Successfully left call in chat %lld\\n\", chat_id);\n} else {\n    fprintf(stderr, \"Failed to leave call: %s\\n\", tgcaller_error_string(error));\n}\n</code></pre>"},{"location":"c-api/basic-methods/#check-connection-status","title":"Check Connection Status","text":"<pre><code>// Check if connected to a specific call\nbool is_connected = tgcaller_is_connected(caller, chat_id);\nif (is_connected) {\n    printf(\"Connected to call in chat %lld\\n\", chat_id);\n} else {\n    printf(\"Not connected to call in chat %lld\\n\", chat_id);\n}\n\n// Check if TgCaller service is running\nbool is_running = tgcaller_is_running(caller);\nif (is_running) {\n    printf(\"TgCaller service is running\\n\");\n} else {\n    printf(\"TgCaller service is not running\\n\");\n}\n</code></pre>"},{"location":"c-api/basic-methods/#configuration","title":"Configuration","text":""},{"location":"c-api/basic-methods/#audio-configuration","title":"Audio Configuration","text":"<pre><code>// Create audio configuration\nTgCallerAudioConfig audio_config = {\n    .bitrate = 128000,        // 128 kbps\n    .sample_rate = 48000,     // 48 kHz\n    .channels = 2,            // Stereo\n    .codec = TGCALLER_CODEC_OPUS,\n    .noise_suppression = true,\n    .echo_cancellation = true\n};\n\n// Apply configuration\nTgCallerError error = tgcaller_set_audio_config(caller, &amp;audio_config);\nif (error != TGCALLER_SUCCESS) {\n    fprintf(stderr, \"Failed to set audio config: %s\\n\", tgcaller_error_string(error));\n}\n</code></pre>"},{"location":"c-api/basic-methods/#video-configuration","title":"Video Configuration","text":"<pre><code>// Create video configuration\nTgCallerVideoConfig video_config = {\n    .width = 1280,\n    .height = 720,\n    .fps = 30,\n    .bitrate = 1500000,       // 1.5 Mbps\n    .codec = TGCALLER_CODEC_H264,\n    .hardware_acceleration = true\n};\n\n// Apply configuration\nTgCallerError error = tgcaller_set_video_config(caller, &amp;video_config);\nif (error != TGCALLER_SUCCESS) {\n    fprintf(stderr, \"Failed to set video config: %s\\n\", tgcaller_error_string(error));\n}\n</code></pre>"},{"location":"c-api/basic-methods/#error-handling","title":"Error Handling","text":""},{"location":"c-api/basic-methods/#error-codes","title":"Error Codes","text":"<pre><code>// Check specific error types\nTgCallerError error = tgcaller_join_call(caller, chat_id);\n\nswitch (error) {\n    case TGCALLER_SUCCESS:\n        printf(\"Operation successful\\n\");\n        break;\n    case TGCALLER_ERROR_NOT_CONNECTED:\n        fprintf(stderr, \"Not connected to Telegram\\n\");\n        break;\n    case TGCALLER_ERROR_INVALID_CHAT:\n        fprintf(stderr, \"Invalid chat ID\\n\");\n        break;\n    case TGCALLER_ERROR_ALREADY_IN_CALL:\n        fprintf(stderr, \"Already in call\\n\");\n        break;\n    default:\n        fprintf(stderr, \"Unknown error: %s\\n\", tgcaller_error_string(error));\n        break;\n}\n</code></pre>"},{"location":"c-api/basic-methods/#error-messages","title":"Error Messages","text":"<pre><code>// Get human-readable error message\nconst char* error_message = tgcaller_error_string(error);\nprintf(\"Error: %s\\n\", error_message);\n\n// Get last error\nTgCallerError last_error = tgcaller_get_last_error(caller);\nif (last_error != TGCALLER_SUCCESS) {\n    fprintf(stderr, \"Last error: %s\\n\", tgcaller_error_string(last_error));\n}\n</code></pre>"},{"location":"c-api/basic-methods/#utility-functions","title":"Utility Functions","text":""},{"location":"c-api/basic-methods/#get-active-calls","title":"Get Active Calls","text":"<pre><code>// Get list of active calls\nint64_t* active_calls = NULL;\nsize_t count = 0;\n\nTgCallerError error = tgcaller_get_active_calls(caller, &amp;active_calls, &amp;count);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Active calls (%zu):\\n\", count);\n    for (size_t i = 0; i &lt; count; i++) {\n        printf(\"  Chat ID: %lld\\n\", active_calls[i]);\n    }\n\n    // Free the allocated memory\n    free(active_calls);\n} else {\n    fprintf(stderr, \"Failed to get active calls: %s\\n\", tgcaller_error_string(error));\n}\n</code></pre>"},{"location":"c-api/basic-methods/#get-version","title":"Get Version","text":"<pre><code>// Get TgCaller version\nconst char* version = tgcaller_get_version();\nprintf(\"TgCaller version: %s\\n\", version);\n\n// Get build information\nconst char* build_info = tgcaller_get_build_info();\nprintf(\"Build info: %s\\n\", build_info);\n</code></pre>"},{"location":"c-api/basic-methods/#complete-example","title":"Complete Example","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#include \"tgcaller.h\"\n\nint main() {\n    // Create TgCaller instance\n    TgCaller* caller = tgcaller_create();\n    if (!caller) {\n        fprintf(stderr, \"Failed to create TgCaller\\n\");\n        return -1;\n    }\n\n    // Set credentials\n    int api_id = 12345;\n    const char* api_hash = \"your_api_hash\";\n\n    TgCallerError error = tgcaller_set_credentials(caller, api_id, api_hash);\n    if (error != TGCALLER_SUCCESS) {\n        fprintf(stderr, \"Failed to set credentials\\n\");\n        tgcaller_destroy(caller);\n        return -1;\n    }\n\n    // Start TgCaller\n    error = tgcaller_start(caller);\n    if (error != TGCALLER_SUCCESS) {\n        fprintf(stderr, \"Failed to start TgCaller\\n\");\n        tgcaller_destroy(caller);\n        return -1;\n    }\n\n    // Join call\n    int64_t chat_id = -1001234567890;\n    error = tgcaller_join_call(caller, chat_id);\n    if (error == TGCALLER_SUCCESS) {\n        printf(\"Joined call successfully\\n\");\n\n        // Wait for 10 seconds\n        sleep(10);\n\n        // Leave call\n        tgcaller_leave_call(caller, chat_id);\n        printf(\"Left call\\n\");\n    }\n\n    // Stop and cleanup\n    tgcaller_stop(caller);\n    tgcaller_destroy(caller);\n\n    return 0;\n}\n</code></pre>"},{"location":"c-api/enums/","title":"Available Enums","text":""},{"location":"c-api/enums/#error-codes","title":"Error Codes","text":""},{"location":"c-api/enums/#tgcallererror","title":"TgCallerError","text":"<pre><code>typedef enum {\n    TGCALLER_SUCCESS = 0,                    // Operation successful\n    TGCALLER_ERROR_INVALID_PARAMETER,       // Invalid parameter passed\n    TGCALLER_ERROR_NOT_INITIALIZED,         // TgCaller not initialized\n    TGCALLER_ERROR_NOT_CONNECTED,           // Not connected to Telegram\n    TGCALLER_ERROR_ALREADY_CONNECTED,       // Already connected\n    TGCALLER_ERROR_CONNECTION_FAILED,       // Connection failed\n    TGCALLER_ERROR_INVALID_CHAT,            // Invalid chat ID\n    TGCALLER_ERROR_ALREADY_IN_CALL,         // Already in call\n    TGCALLER_ERROR_NOT_IN_CALL,             // Not in call\n    TGCALLER_ERROR_CALL_FAILED,             // Call operation failed\n    TGCALLER_ERROR_STREAM_FAILED,           // Stream operation failed\n    TGCALLER_ERROR_FILE_NOT_FOUND,          // Media file not found\n    TGCALLER_ERROR_INVALID_FORMAT,          // Invalid media format\n    TGCALLER_ERROR_CODEC_ERROR,             // Codec error\n    TGCALLER_ERROR_DEVICE_ERROR,            // Audio/video device error\n    TGCALLER_ERROR_PERMISSION_DENIED,       // Permission denied\n    TGCALLER_ERROR_NETWORK_ERROR,           // Network error\n    TGCALLER_ERROR_TIMEOUT,                 // Operation timeout\n    TGCALLER_ERROR_OUT_OF_MEMORY,           // Out of memory\n    TGCALLER_ERROR_UNKNOWN                  // Unknown error\n} TgCallerError;\n\n// Get error string\nconst char* tgcaller_error_string(TgCallerError error);\n</code></pre>"},{"location":"c-api/enums/#stream-status","title":"Stream Status","text":""},{"location":"c-api/enums/#tgcallerstreamstatus","title":"TgCallerStreamStatus","text":"<pre><code>typedef enum {\n    TGCALLER_STREAM_IDLE,           // No active stream\n    TGCALLER_STREAM_LOADING,        // Loading stream\n    TGCALLER_STREAM_PLAYING,        // Stream is playing\n    TGCALLER_STREAM_PAUSED,         // Stream is paused\n    TGCALLER_STREAM_STOPPED,        // Stream is stopped\n    TGCALLER_STREAM_ERROR           // Stream error\n} TgCallerStreamStatus;\n\n// Get stream status\nTgCallerError tgcaller_get_stream_status(TgCaller* caller, int64_t chat_id, TgCallerStreamStatus* status);\n</code></pre>"},{"location":"c-api/enums/#call-status","title":"Call Status","text":""},{"location":"c-api/enums/#tgcallercallstatus","title":"TgCallerCallStatus","text":"<pre><code>typedef enum {\n    TGCALLER_CALL_IDLE,             // Not in call\n    TGCALLER_CALL_CONNECTING,       // Connecting to call\n    TGCALLER_CALL_CONNECTED,        // Connected to call\n    TGCALLER_CALL_DISCONNECTING,    // Disconnecting from call\n    TGCALLER_CALL_ERROR             // Call error\n} TgCallerCallStatus;\n\n// Get call status\nTgCallerError tgcaller_get_call_status(TgCaller* caller, int64_t chat_id, TgCallerCallStatus* status);\n</code></pre>"},{"location":"c-api/enums/#codecs","title":"Codecs","text":""},{"location":"c-api/enums/#tgcallercodec","title":"TgCallerCodec","text":"<pre><code>typedef enum {\n    // Audio codecs\n    TGCALLER_CODEC_OPUS,            // Opus codec (recommended for audio)\n    TGCALLER_CODEC_AAC,             // AAC codec\n    TGCALLER_CODEC_MP3,             // MP3 codec\n    TGCALLER_CODEC_PCM,             // Raw PCM\n\n    // Video codecs\n    TGCALLER_CODEC_H264,            // H.264 codec (recommended for video)\n    TGCALLER_CODEC_VP8,             // VP8 codec\n    TGCALLER_CODEC_VP9,             // VP9 codec\n    TGCALLER_CODEC_AV1              // AV1 codec\n} TgCallerCodec;\n</code></pre>"},{"location":"c-api/enums/#media-formats","title":"Media Formats","text":""},{"location":"c-api/enums/#tgcallerformat","title":"TgCallerFormat","text":"<pre><code>typedef enum {\n    TGCALLER_FORMAT_PCM,            // Raw PCM audio\n    TGCALLER_FORMAT_MP3,            // MP3 audio\n    TGCALLER_FORMAT_WAV,            // WAV audio\n    TGCALLER_FORMAT_OGG,            // OGG audio\n    TGCALLER_FORMAT_FLAC,           // FLAC audio\n    TGCALLER_FORMAT_AAC,            // AAC audio\n    TGCALLER_FORMAT_MP4,            // MP4 video\n    TGCALLER_FORMAT_AVI,            // AVI video\n    TGCALLER_FORMAT_MKV,            // MKV video\n    TGCALLER_FORMAT_WEBM,           // WebM video\n    TGCALLER_FORMAT_MOV             // MOV video\n} TgCallerFormat;\n</code></pre>"},{"location":"c-api/enums/#quality-presets","title":"Quality Presets","text":""},{"location":"c-api/enums/#tgcallerquality","title":"TgCallerQuality","text":"<pre><code>typedef enum {\n    TGCALLER_QUALITY_LOW,           // Low quality (bandwidth optimized)\n    TGCALLER_QUALITY_MEDIUM,        // Medium quality (balanced)\n    TGCALLER_QUALITY_HIGH,          // High quality (quality optimized)\n    TGCALLER_QUALITY_ULTRA,         // Ultra quality (maximum quality)\n    TGCALLER_QUALITY_CUSTOM         // Custom quality (use specific config)\n} TgCallerQuality;\n</code></pre>"},{"location":"c-api/enums/#repeat-modes","title":"Repeat Modes","text":""},{"location":"c-api/enums/#tgcallerrepeatmode","title":"TgCallerRepeatMode","text":"<pre><code>typedef enum {\n    TGCALLER_REPEAT_NONE,           // No repeat\n    TGCALLER_REPEAT_ONE,            // Repeat current track\n    TGCALLER_REPEAT_ALL             // Repeat all tracks in queue\n} TgCallerRepeatMode;\n\n// Set repeat mode\nTgCallerError tgcaller_set_repeat_mode(TgCaller* caller, int64_t chat_id, TgCallerRepeatMode mode);\n\n// Get repeat mode\nTgCallerError tgcaller_get_repeat_mode(TgCaller* caller, int64_t chat_id, TgCallerRepeatMode* mode);\n</code></pre>"},{"location":"c-api/enums/#event-types","title":"Event Types","text":""},{"location":"c-api/enums/#tgcallerstreameventtype","title":"TgCallerStreamEventType","text":"<pre><code>typedef enum {\n    TGCALLER_STREAM_STARTED,        // Stream started\n    TGCALLER_STREAM_ENDED,          // Stream ended\n    TGCALLER_STREAM_PAUSED,         // Stream paused\n    TGCALLER_STREAM_RESUMED,        // Stream resumed\n    TGCALLER_STREAM_POSITION,       // Position changed\n    TGCALLER_STREAM_ERROR           // Stream error\n} TgCallerStreamEventType;\n</code></pre>"},{"location":"c-api/enums/#tgcallercalleventtype","title":"TgCallerCallEventType","text":"<pre><code>typedef enum {\n    TGCALLER_CALL_JOINED,           // Joined call\n    TGCALLER_CALL_LEFT,             // Left call\n    TGCALLER_CALL_USER_JOINED,      // User joined call\n    TGCALLER_CALL_USER_LEFT,        // User left call\n    TGCALLER_CALL_KICKED,           // Kicked from call\n    TGCALLER_CALL_ERROR             // Call error\n} TgCallerCallEventType;\n</code></pre>"},{"location":"c-api/enums/#filter-types","title":"Filter Types","text":""},{"location":"c-api/enums/#tgcallerfiltertype","title":"TgCallerFilterType","text":"<pre><code>typedef enum {\n    // Audio filters\n    TGCALLER_FILTER_ECHO,           // Echo effect\n    TGCALLER_FILTER_REVERB,         // Reverb effect\n    TGCALLER_FILTER_PITCH_SHIFT,    // Pitch shifting\n    TGCALLER_FILTER_DISTORTION,     // Distortion effect\n    TGCALLER_FILTER_NOISE_GATE,     // Noise gate\n    TGCALLER_FILTER_COMPRESSOR,     // Audio compressor\n    TGCALLER_FILTER_EQUALIZER,      // Equalizer\n\n    // Video filters\n    TGCALLER_FILTER_BLUR,           // Blur effect\n    TGCALLER_FILTER_SHARPEN,        // Sharpen effect\n    TGCALLER_FILTER_SEPIA,          // Sepia effect\n    TGCALLER_FILTER_GRAYSCALE,      // Grayscale effect\n    TGCALLER_FILTER_COLOR_ADJUST,   // Color adjustment\n    TGCALLER_FILTER_COLOR_BALANCE,  // Color balance\n    TGCALLER_FILTER_EDGE_DETECT,    // Edge detection\n    TGCALLER_FILTER_CARTOON         // Cartoon effect\n} TgCallerFilterType;\n</code></pre>"},{"location":"c-api/enums/#whisper-models","title":"Whisper Models","text":""},{"location":"c-api/enums/#tgcallerwhispermodel","title":"TgCallerWhisperModel","text":"<pre><code>typedef enum {\n    TGCALLER_WHISPER_TINY,          // Tiny model (~39 MB)\n    TGCALLER_WHISPER_BASE,          // Base model (~74 MB)\n    TGCALLER_WHISPER_SMALL,         // Small model (~244 MB)\n    TGCALLER_WHISPER_MEDIUM,        // Medium model (~769 MB)\n    TGCALLER_WHISPER_LARGE,         // Large model (~1550 MB)\n    TGCALLER_WHISPER_LARGE_V2,      // Large v2 model (~1550 MB)\n    TGCALLER_WHISPER_LARGE_V3       // Large v3 model (~1550 MB)\n} TgCallerWhisperModel;\n</code></pre>"},{"location":"c-api/enums/#log-levels","title":"Log Levels","text":""},{"location":"c-api/enums/#tgcallerloglevel","title":"TgCallerLogLevel","text":"<pre><code>typedef enum {\n    TGCALLER_LOG_TRACE,             // Trace level (most verbose)\n    TGCALLER_LOG_DEBUG,             // Debug level\n    TGCALLER_LOG_INFO,              // Info level\n    TGCALLER_LOG_WARNING,           // Warning level\n    TGCALLER_LOG_ERROR,             // Error level\n    TGCALLER_LOG_CRITICAL,          // Critical level\n    TGCALLER_LOG_OFF                // Logging disabled\n} TgCallerLogLevel;\n\n// Set log level\nTgCallerError tgcaller_set_log_level(TgCallerLogLevel level);\n\n// Get current log level\nTgCallerLogLevel tgcaller_get_log_level(void);\n</code></pre>"},{"location":"c-api/enums/#device-types","title":"Device Types","text":""},{"location":"c-api/enums/#tgcallerdevicetype","title":"TgCallerDeviceType","text":"<pre><code>typedef enum {\n    TGCALLER_DEVICE_AUDIO_INPUT,    // Audio input device (microphone)\n    TGCALLER_DEVICE_AUDIO_OUTPUT,   // Audio output device (speakers)\n    TGCALLER_DEVICE_VIDEO_INPUT,    // Video input device (camera)\n    TGCALLER_DEVICE_MONITOR         // Monitor/display device\n} TgCallerDeviceType;\n</code></pre>"},{"location":"c-api/enums/#connection-types","title":"Connection Types","text":""},{"location":"c-api/enums/#tgcallerconnectiontype","title":"TgCallerConnectionType","text":"<pre><code>typedef enum {\n    TGCALLER_CONNECTION_UDP,        // UDP connection (default)\n    TGCALLER_CONNECTION_TCP,        // TCP connection\n    TGCALLER_CONNECTION_TLS         // TLS connection\n} TgCallerConnectionType;\n\n// Set connection type\nTgCallerError tgcaller_set_connection_type(TgCaller* caller, TgCallerConnectionType type);\n</code></pre>"},{"location":"c-api/enums/#stream-types","title":"Stream Types","text":""},{"location":"c-api/enums/#tgcallerstreamtype","title":"TgCallerStreamType","text":"<pre><code>typedef enum {\n    TGCALLER_STREAM_AUDIO,          // Audio only stream\n    TGCALLER_STREAM_VIDEO,          // Video stream (includes audio)\n    TGCALLER_STREAM_SCREEN,         // Screen sharing stream\n    TGCALLER_STREAM_MICROPHONE,     // Live microphone input\n    TGCALLER_STREAM_CAMERA,         // Live camera input\n    TGCALLER_STREAM_MIXED           // Mixed audio/video stream\n} TgCallerStreamType;\n</code></pre>"},{"location":"c-api/enums/#usage-examples","title":"Usage Examples","text":""},{"location":"c-api/enums/#error-handling","title":"Error Handling","text":"<pre><code>TgCallerError error = tgcaller_join_call(caller, chat_id);\n\nswitch (error) {\n    case TGCALLER_SUCCESS:\n        printf(\"Successfully joined call\\n\");\n        break;\n    case TGCALLER_ERROR_NOT_CONNECTED:\n        fprintf(stderr, \"Not connected to Telegram\\n\");\n        break;\n    case TGCALLER_ERROR_INVALID_CHAT:\n        fprintf(stderr, \"Invalid chat ID\\n\");\n        break;\n    case TGCALLER_ERROR_ALREADY_IN_CALL:\n        fprintf(stderr, \"Already in call\\n\");\n        break;\n    default:\n        fprintf(stderr, \"Error: %s\\n\", tgcaller_error_string(error));\n        break;\n}\n</code></pre>"},{"location":"c-api/enums/#status-checking","title":"Status Checking","text":"<pre><code>TgCallerStreamStatus status;\nTgCallerError error = tgcaller_get_stream_status(caller, chat_id, &amp;status);\n\nif (error == TGCALLER_SUCCESS) {\n    switch (status) {\n        case TGCALLER_STREAM_PLAYING:\n            printf(\"Stream is currently playing\\n\");\n            break;\n        case TGCALLER_STREAM_PAUSED:\n            printf(\"Stream is paused\\n\");\n            break;\n        case TGCALLER_STREAM_IDLE:\n            printf(\"No active stream\\n\");\n            break;\n        default:\n            printf(\"Stream status: %d\\n\", status);\n            break;\n    }\n}\n</code></pre>"},{"location":"c-api/enums/#quality-configuration","title":"Quality Configuration","text":"<pre><code>// Use quality preset\nTgCallerVideoConfig config = tgcaller_video_config_default();\nconfig.quality = TGCALLER_QUALITY_HIGH;\n\n// Or use specific codec\nconfig.codec = TGCALLER_CODEC_H264;\nconfig.quality = TGCALLER_QUALITY_CUSTOM;\nconfig.bitrate = 2000000;  // 2 Mbps\n\nTgCallerError error = tgcaller_set_video_config(caller, &amp;config);\n</code></pre> <p>All enums provide meaningful values that can be used for configuration, status checking, and error handling throughout the TgCaller C API.</p>"},{"location":"c-api/stream-methods/","title":"Stream Methods","text":""},{"location":"c-api/stream-methods/#audio-streaming","title":"Audio Streaming","text":""},{"location":"c-api/stream-methods/#play-audio-file","title":"Play Audio File","text":"<pre><code>#include \"tgcaller.h\"\n\n// Play audio file\nint64_t chat_id = -1001234567890;\nconst char* audio_file = \"song.mp3\";\n\nTgCallerError error = tgcaller_play(caller, chat_id, audio_file);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Started playing: %s\\n\", audio_file);\n} else {\n    fprintf(stderr, \"Failed to play audio: %s\\n\", tgcaller_error_string(error));\n}\n</code></pre>"},{"location":"c-api/stream-methods/#play-with-configuration","title":"Play with Configuration","text":"<pre><code>// Create audio configuration\nTgCallerAudioConfig audio_config = {\n    .bitrate = 128000,\n    .sample_rate = 48000,\n    .channels = 2,\n    .codec = TGCALLER_CODEC_OPUS,\n    .noise_suppression = true,\n    .echo_cancellation = true\n};\n\n// Play with specific configuration\nTgCallerError error = tgcaller_play_with_config(\n    caller, \n    chat_id, \n    \"high_quality_song.flac\",\n    &amp;audio_config,\n    NULL  // No video config\n);\n</code></pre>"},{"location":"c-api/stream-methods/#stream-from-url","title":"Stream from URL","text":"<pre><code>// Stream from HTTP URL\nconst char* stream_url = \"https://example.com/stream.mp3\";\n\nTgCallerError error = tgcaller_play(caller, chat_id, stream_url);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Started streaming from URL\\n\");\n} else {\n    fprintf(stderr, \"Failed to stream from URL: %s\\n\", tgcaller_error_string(error));\n}\n</code></pre>"},{"location":"c-api/stream-methods/#video-streaming","title":"Video Streaming","text":""},{"location":"c-api/stream-methods/#play-video-file","title":"Play Video File","text":"<pre><code>// Create video configuration\nTgCallerVideoConfig video_config = {\n    .width = 1280,\n    .height = 720,\n    .fps = 30,\n    .bitrate = 1500000,\n    .codec = TGCALLER_CODEC_H264,\n    .hardware_acceleration = true\n};\n\n// Create audio configuration for video\nTgCallerAudioConfig audio_config = {\n    .bitrate = 128000,\n    .sample_rate = 48000,\n    .channels = 2,\n    .codec = TGCALLER_CODEC_OPUS\n};\n\n// Play video file\nTgCallerError error = tgcaller_play_with_config(\n    caller,\n    chat_id,\n    \"video.mp4\",\n    &amp;audio_config,\n    &amp;video_config\n);\n\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Started playing video\\n\");\n} else {\n    fprintf(stderr, \"Failed to play video: %s\\n\", tgcaller_error_string(error));\n}\n</code></pre>"},{"location":"c-api/stream-methods/#stream-control","title":"Stream Control","text":""},{"location":"c-api/stream-methods/#pause-stream","title":"Pause Stream","text":"<pre><code>// Pause current stream\nTgCallerError error = tgcaller_pause(caller, chat_id);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Stream paused\\n\");\n} else {\n    fprintf(stderr, \"Failed to pause stream: %s\\n\", tgcaller_error_string(error));\n}\n</code></pre>"},{"location":"c-api/stream-methods/#resume-stream","title":"Resume Stream","text":"<pre><code>// Resume paused stream\nTgCallerError error = tgcaller_resume(caller, chat_id);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Stream resumed\\n\");\n} else {\n    fprintf(stderr, \"Failed to resume stream: %s\\n\", tgcaller_error_string(error));\n}\n</code></pre>"},{"location":"c-api/stream-methods/#stop-stream","title":"Stop Stream","text":"<pre><code>// Stop current stream\nTgCallerError error = tgcaller_stop_stream(caller, chat_id);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Stream stopped\\n\");\n} else {\n    fprintf(stderr, \"Failed to stop stream: %s\\n\", tgcaller_error_string(error));\n}\n</code></pre>"},{"location":"c-api/stream-methods/#volume-control","title":"Volume Control","text":"<pre><code>// Set volume (0.0 to 1.0)\nfloat volume = 0.8f;  // 80%\n\nTgCallerError error = tgcaller_set_volume(caller, chat_id, volume);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Volume set to %.0f%%\\n\", volume * 100);\n} else {\n    fprintf(stderr, \"Failed to set volume: %s\\n\", tgcaller_error_string(error));\n}\n\n// Get current volume\nfloat current_volume;\nerror = tgcaller_get_volume(caller, chat_id, &amp;current_volume);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Current volume: %.0f%%\\n\", current_volume * 100);\n}\n</code></pre>"},{"location":"c-api/stream-methods/#seek-control","title":"Seek Control","text":"<pre><code>// Seek to position (in seconds)\ndouble position = 60.0;  // 1 minute\n\nTgCallerError error = tgcaller_seek(caller, chat_id, position);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Seeked to %.1f seconds\\n\", position);\n} else {\n    fprintf(stderr, \"Failed to seek: %s\\n\", tgcaller_error_string(error));\n}\n\n// Get current position\ndouble current_position;\nerror = tgcaller_get_position(caller, chat_id, &amp;current_position);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Current position: %.1f seconds\\n\", current_position);\n}\n</code></pre>"},{"location":"c-api/stream-methods/#stream-information","title":"Stream Information","text":""},{"location":"c-api/stream-methods/#get-stream-status","title":"Get Stream Status","text":"<pre><code>// Get current stream status\nTgCallerStreamStatus status;\nTgCallerError error = tgcaller_get_stream_status(caller, chat_id, &amp;status);\n\nif (error == TGCALLER_SUCCESS) {\n    switch (status) {\n        case TGCALLER_STREAM_IDLE:\n            printf(\"No active stream\\n\");\n            break;\n        case TGCALLER_STREAM_PLAYING:\n            printf(\"Stream is playing\\n\");\n            break;\n        case TGCALLER_STREAM_PAUSED:\n            printf(\"Stream is paused\\n\");\n            break;\n        case TGCALLER_STREAM_STOPPED:\n            printf(\"Stream is stopped\\n\");\n            break;\n        default:\n            printf(\"Unknown stream status\\n\");\n            break;\n    }\n} else {\n    fprintf(stderr, \"Failed to get stream status: %s\\n\", tgcaller_error_string(error));\n}\n</code></pre>"},{"location":"c-api/stream-methods/#get-stream-information","title":"Get Stream Information","text":"<pre><code>// Get detailed stream information\nTgCallerStreamInfo stream_info;\nTgCallerError error = tgcaller_get_stream_info(caller, chat_id, &amp;stream_info);\n\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Stream Information:\\n\");\n    printf(\"  Source: %s\\n\", stream_info.source);\n    printf(\"  Duration: %.1f seconds\\n\", stream_info.duration);\n    printf(\"  Position: %.1f seconds\\n\", stream_info.position);\n    printf(\"  Volume: %.0f%%\\n\", stream_info.volume * 100);\n    printf(\"  Has Video: %s\\n\", stream_info.has_video ? \"Yes\" : \"No\");\n\n    if (stream_info.has_video) {\n        printf(\"  Video: %dx%d @ %d fps\\n\", \n               stream_info.video_width, \n               stream_info.video_height, \n               stream_info.video_fps);\n    }\n\n    printf(\"  Audio: %d Hz, %d channels, %d kbps\\n\",\n           stream_info.audio_sample_rate,\n           stream_info.audio_channels,\n           stream_info.audio_bitrate / 1000);\n} else {\n    fprintf(stderr, \"Failed to get stream info: %s\\n\", tgcaller_error_string(error));\n}\n</code></pre>"},{"location":"c-api/stream-methods/#advanced-streaming","title":"Advanced Streaming","text":""},{"location":"c-api/stream-methods/#queue-management","title":"Queue Management","text":"<pre><code>// Add to queue\nTgCallerError error = tgcaller_queue_add(caller, chat_id, \"song1.mp3\");\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Added to queue\\n\");\n}\n\n// Get queue size\nsize_t queue_size;\nerror = tgcaller_queue_size(caller, chat_id, &amp;queue_size);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Queue size: %zu\\n\", queue_size);\n}\n\n// Skip to next in queue\nerror = tgcaller_queue_next(caller, chat_id);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Skipped to next in queue\\n\");\n}\n\n// Clear queue\nerror = tgcaller_queue_clear(caller, chat_id);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Queue cleared\\n\");\n}\n</code></pre>"},{"location":"c-api/stream-methods/#repeat-mode","title":"Repeat Mode","text":"<pre><code>// Set repeat mode\nTgCallerRepeatMode repeat_mode = TGCALLER_REPEAT_ONE;\n\nTgCallerError error = tgcaller_set_repeat_mode(caller, chat_id, repeat_mode);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Repeat mode set\\n\");\n}\n\n// Available repeat modes:\n// TGCALLER_REPEAT_NONE - No repeat\n// TGCALLER_REPEAT_ONE  - Repeat current track\n// TGCALLER_REPEAT_ALL  - Repeat all tracks in queue\n</code></pre>"},{"location":"c-api/stream-methods/#stream-from-memory","title":"Stream from Memory","text":"<pre><code>// Stream from memory buffer\nconst uint8_t* audio_data = /* your audio data */;\nsize_t data_size = /* size of audio data */;\n\nTgCallerMemoryStream memory_stream = {\n    .data = audio_data,\n    .size = data_size,\n    .format = TGCALLER_FORMAT_PCM,\n    .sample_rate = 48000,\n    .channels = 2,\n    .bits_per_sample = 16\n};\n\nTgCallerError error = tgcaller_play_memory(caller, chat_id, &amp;memory_stream);\nif (error == TGCALLER_SUCCESS) {\n    printf(\"Started playing from memory\\n\");\n} else {\n    fprintf(stderr, \"Failed to play from memory: %s\\n\", tgcaller_error_string(error));\n}\n</code></pre>"},{"location":"c-api/stream-methods/#complete-streaming-example","title":"Complete Streaming Example","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#include \"tgcaller.h\"\n\nvoid stream_callback(TgCallerStreamEvent event, void* user_data) {\n    int64_t chat_id = *(int64_t*)user_data;\n\n    switch (event.type) {\n        case TGCALLER_STREAM_STARTED:\n            printf(\"Stream started in chat %lld\\n\", chat_id);\n            break;\n        case TGCALLER_STREAM_ENDED:\n            printf(\"Stream ended in chat %lld\\n\", chat_id);\n            break;\n        case TGCALLER_STREAM_ERROR:\n            printf(\"Stream error in chat %lld: %s\\n\", chat_id, event.error_message);\n            break;\n    }\n}\n\nint main() {\n    TgCaller* caller = tgcaller_create();\n    if (!caller) return -1;\n\n    // Setup credentials and start\n    tgcaller_set_credentials(caller, 12345, \"api_hash\");\n    tgcaller_start(caller);\n\n    int64_t chat_id = -1001234567890;\n\n    // Register stream callback\n    tgcaller_set_stream_callback(caller, stream_callback, &amp;chat_id);\n\n    // Join call\n    tgcaller_join_call(caller, chat_id);\n\n    // Play audio file\n    tgcaller_play(caller, chat_id, \"song.mp3\");\n\n    // Wait for stream to finish\n    sleep(30);\n\n    // Control stream\n    tgcaller_set_volume(caller, chat_id, 0.5f);  // 50% volume\n    tgcaller_pause(caller, chat_id);\n    sleep(2);\n    tgcaller_resume(caller, chat_id);\n\n    // Cleanup\n    tgcaller_leave_call(caller, chat_id);\n    tgcaller_stop(caller);\n    tgcaller_destroy(caller);\n\n    return 0;\n}\n</code></pre>"},{"location":"c-api/structs/","title":"Available Structs","text":""},{"location":"c-api/structs/#core-structures","title":"Core Structures","text":""},{"location":"c-api/structs/#tgcaller","title":"TgCaller","text":"<pre><code>// Opaque structure for TgCaller instance\ntypedef struct TgCaller TgCaller;\n\n// Create and destroy\nTgCaller* tgcaller_create(void);\nvoid tgcaller_destroy(TgCaller* caller);\n</code></pre>"},{"location":"c-api/structs/#tgcalleraudioconfig","title":"TgCallerAudioConfig","text":"<pre><code>typedef struct {\n    int bitrate;                    // Audio bitrate in bps (8000-320000)\n    int sample_rate;                // Sample rate in Hz (8000, 16000, 24000, 48000)\n    int channels;                   // Number of channels (1=mono, 2=stereo)\n    TgCallerCodec codec;            // Audio codec (OPUS, AAC)\n    bool noise_suppression;         // Enable noise suppression\n    bool echo_cancellation;         // Enable echo cancellation\n    bool auto_gain_control;         // Enable automatic gain control\n} TgCallerAudioConfig;\n\n// Default configurations\nTgCallerAudioConfig tgcaller_audio_config_default(void);\nTgCallerAudioConfig tgcaller_audio_config_high_quality(void);\nTgCallerAudioConfig tgcaller_audio_config_low_bandwidth(void);\n</code></pre>"},{"location":"c-api/structs/#tgcallervideoconfig","title":"TgCallerVideoConfig","text":"<pre><code>typedef struct {\n    int width;                      // Video width in pixels (320-1920)\n    int height;                     // Video height in pixels (240-1080)\n    int fps;                        // Frame rate (15, 24, 30, 60)\n    int bitrate;                    // Video bitrate in bps (100000-5000000)\n    TgCallerCodec codec;            // Video codec (H264, VP8)\n    bool hardware_acceleration;     // Enable hardware acceleration\n} TgCallerVideoConfig;\n\n// Default configurations\nTgCallerVideoConfig tgcaller_video_config_default(void);\nTgCallerVideoConfig tgcaller_video_config_hd_720p(void);\nTgCallerVideoConfig tgcaller_video_config_full_hd_1080p(void);\nTgCallerVideoConfig tgcaller_video_config_low_quality(void);\n</code></pre>"},{"location":"c-api/structs/#stream-information","title":"Stream Information","text":""},{"location":"c-api/structs/#tgcallerstreaminfo","title":"TgCallerStreamInfo","text":"<pre><code>typedef struct {\n    char* source;                   // Stream source (file path or URL)\n    double duration;                // Total duration in seconds\n    double position;                // Current position in seconds\n    float volume;                   // Current volume (0.0 to 1.0)\n    bool has_video;                 // Whether stream has video\n\n    // Audio information\n    int audio_sample_rate;          // Audio sample rate\n    int audio_channels;             // Number of audio channels\n    int audio_bitrate;              // Audio bitrate in bps\n\n    // Video information (if has_video is true)\n    int video_width;                // Video width\n    int video_height;               // Video height\n    int video_fps;                  // Video frame rate\n    int video_bitrate;              // Video bitrate in bps\n} TgCallerStreamInfo;\n\n// Get stream information\nTgCallerError tgcaller_get_stream_info(TgCaller* caller, int64_t chat_id, TgCallerStreamInfo* info);\n\n// Free allocated strings in stream info\nvoid tgcaller_stream_info_free(TgCallerStreamInfo* info);\n</code></pre>"},{"location":"c-api/structs/#tgcallermemorystream","title":"TgCallerMemoryStream","text":"<pre><code>typedef struct {\n    const uint8_t* data;            // Pointer to audio data\n    size_t size;                    // Size of data in bytes\n    TgCallerFormat format;          // Audio format (PCM, etc.)\n    int sample_rate;                // Sample rate in Hz\n    int channels;                   // Number of channels\n    int bits_per_sample;            // Bits per sample (8, 16, 24, 32)\n} TgCallerMemoryStream;\n\n// Play from memory\nTgCallerError tgcaller_play_memory(TgCaller* caller, int64_t chat_id, const TgCallerMemoryStream* stream);\n</code></pre>"},{"location":"c-api/structs/#device-information","title":"Device Information","text":""},{"location":"c-api/structs/#tgcallermonitorinfo","title":"TgCallerMonitorInfo","text":"<pre><code>typedef struct {\n    int index;                      // Monitor index\n    int x;                          // X position\n    int y;                          // Y position\n    int width;                      // Monitor width\n    int height;                     // Monitor height\n    bool is_primary;                // Whether this is the primary monitor\n    char* name;                     // Monitor name\n} TgCallerMonitorInfo;\n\n// Get available monitors\nTgCallerError tgcaller_get_monitors(TgCallerMonitorInfo** monitors, size_t* count);\n\n// Free monitor info array\nvoid tgcaller_monitors_free(TgCallerMonitorInfo* monitors, size_t count);\n</code></pre>"},{"location":"c-api/structs/#tgcalleraudiodevice","title":"TgCallerAudioDevice","text":"<pre><code>typedef struct {\n    int index;                      // Device index\n    char* name;                     // Device name\n    int max_channels;               // Maximum number of channels\n    double default_sample_rate;     // Default sample rate\n    bool is_default;                // Whether this is the default device\n} TgCallerAudioDevice;\n\n// Get available audio devices\nTgCallerError tgcaller_get_audio_devices(TgCallerAudioDevice** devices, size_t* count);\n\n// Free audio device array\nvoid tgcaller_audio_devices_free(TgCallerAudioDevice* devices, size_t count);\n</code></pre>"},{"location":"c-api/structs/#advanced-configurations","title":"Advanced Configurations","text":""},{"location":"c-api/structs/#tgcallerscreenconfig","title":"TgCallerScreenConfig","text":"<pre><code>typedef struct {\n    int monitor_index;              // Monitor to capture (-1 for all)\n    int x;                          // Capture region X (0 for full monitor)\n    int y;                          // Capture region Y (0 for full monitor)\n    int width;                      // Capture width (0 for full monitor)\n    int height;                     // Capture height (0 for full monitor)\n    int fps;                        // Frame rate (15, 24, 30, 60)\n    TgCallerQuality quality;        // Quality preset\n} TgCallerScreenConfig;\n\n// Default screen configuration\nTgCallerScreenConfig tgcaller_screen_config_default(void);\n</code></pre>"},{"location":"c-api/structs/#tgcallermicconfig","title":"TgCallerMicConfig","text":"<pre><code>typedef struct {\n    int device_index;               // Audio device index (-1 for default)\n    int sample_rate;                // Sample rate in Hz\n    int channels;                   // Number of channels\n    bool noise_suppression;         // Enable noise suppression\n    bool echo_cancellation;         // Enable echo cancellation\n    bool auto_gain_control;         // Enable automatic gain control\n    float gain;                     // Microphone gain (0.0 to 2.0)\n} TgCallerMicConfig;\n\n// Default microphone configuration\nTgCallerMicConfig tgcaller_mic_config_default(void);\n</code></pre>"},{"location":"c-api/structs/#tgcallertranscriptionconfig","title":"TgCallerTranscriptionConfig","text":"<pre><code>typedef struct {\n    TgCallerWhisperModel model;     // Whisper model to use\n    char* language;                 // Language code (NULL for auto-detect)\n    bool real_time;                 // Enable real-time transcription\n    float confidence_threshold;     // Minimum confidence (0.0 to 1.0)\n    bool translate;                 // Translate to English\n} TgCallerTranscriptionConfig;\n\n// Default transcription configuration\nTgCallerTranscriptionConfig tgcaller_transcription_config_default(void);\n</code></pre>"},{"location":"c-api/structs/#filter-structures","title":"Filter Structures","text":""},{"location":"c-api/structs/#tgcalleraudiofilter","title":"TgCallerAudioFilter","text":"<pre><code>typedef struct {\n    TgCallerFilterType type;        // Filter type\n    union {\n        struct {\n            float delay;            // Echo delay in seconds\n            float decay;            // Echo decay factor\n        } echo;\n\n        struct {\n            float room_size;        // Room size (0.0 to 1.0)\n            float damping;          // Damping factor (0.0 to 1.0)\n        } reverb;\n\n        struct {\n            float semitones;        // Pitch shift in semitones\n        } pitch_shift;\n\n        struct {\n            float gain;             // Distortion gain\n            float threshold;        // Distortion threshold\n        } distortion;\n\n        struct {\n            float threshold;        // Gate threshold\n            float ratio;            // Gate ratio\n        } noise_gate;\n    } parameters;\n} TgCallerAudioFilter;\n</code></pre>"},{"location":"c-api/structs/#tgcallervideofilter","title":"TgCallerVideoFilter","text":"<pre><code>typedef struct {\n    TgCallerFilterType type;        // Filter type\n    union {\n        struct {\n            int kernel_size;        // Blur kernel size (odd number)\n        } blur;\n\n        struct {\n            float brightness;       // Brightness adjustment (-1.0 to 1.0)\n            float contrast;         // Contrast adjustment (-1.0 to 1.0)\n            float saturation;       // Saturation adjustment (-1.0 to 1.0)\n        } color_adjust;\n\n        struct {\n            float red_gain;         // Red channel gain\n            float green_gain;       // Green channel gain\n            float blue_gain;        // Blue channel gain\n        } color_balance;\n    } parameters;\n} TgCallerVideoFilter;\n</code></pre>"},{"location":"c-api/structs/#event-structures","title":"Event Structures","text":""},{"location":"c-api/structs/#tgcallerstreamevent","title":"TgCallerStreamEvent","text":"<pre><code>typedef struct {\n    TgCallerStreamEventType type;   // Event type\n    int64_t chat_id;                // Chat ID where event occurred\n    char* source;                   // Stream source (for started events)\n    char* error_message;            // Error message (for error events)\n    double position;                // Current position (for position events)\n    double duration;                // Total duration (for started events)\n} TgCallerStreamEvent;\n\n// Stream event callback\ntypedef void (*TgCallerStreamCallback)(TgCallerStreamEvent event, void* user_data);\n\n// Set stream event callback\nTgCallerError tgcaller_set_stream_callback(TgCaller* caller, TgCallerStreamCallback callback, void* user_data);\n</code></pre>"},{"location":"c-api/structs/#tgcallercallevent","title":"TgCallerCallEvent","text":"<pre><code>typedef struct {\n    TgCallerCallEventType type;     // Event type\n    int64_t chat_id;                // Chat ID\n    int64_t user_id;                // User ID (for user events)\n    char* error_message;            // Error message (for error events)\n} TgCallerCallEvent;\n\n// Call event callback\ntypedef void (*TgCallerCallCallback)(TgCallerCallEvent event, void* user_data);\n\n// Set call event callback\nTgCallerError tgcaller_set_call_callback(TgCaller* caller, TgCallerCallCallback callback, void* user_data);\n</code></pre>"},{"location":"c-api/structs/#youtube-integration","title":"YouTube Integration","text":""},{"location":"c-api/structs/#tgcalleryoutubeinfo","title":"TgCallerYouTubeInfo","text":"<pre><code>typedef struct {\n    char* title;                    // Video title\n    char* uploader;                 // Uploader name\n    int duration;                   // Duration in seconds\n    int64_t view_count;             // View count\n    char* description;              // Video description\n    char* thumbnail_url;            // Thumbnail URL\n} TgCallerYouTubeInfo;\n\n// Get YouTube video information\nTgCallerError tgcaller_get_youtube_info(const char* url, TgCallerYouTubeInfo* info);\n\n// Free YouTube info\nvoid tgcaller_youtube_info_free(TgCallerYouTubeInfo* info);\n</code></pre>"},{"location":"c-api/structs/#transcription-results","title":"Transcription Results","text":""},{"location":"c-api/structs/#tgcallertranscriptionresult","title":"TgCallerTranscriptionResult","text":"<pre><code>typedef struct {\n    char* text;                     // Transcribed text\n    char* language;                 // Detected language\n    float confidence;               // Confidence score (0.0 to 1.0)\n    double duration;                // Audio duration in seconds\n    TgCallerTranscriptionSegment* segments;  // Detailed segments\n    size_t segment_count;           // Number of segments\n} TgCallerTranscriptionResult;\n\ntypedef struct {\n    double start;                   // Segment start time\n    double end;                     // Segment end time\n    char* text;                     // Segment text\n    float confidence;               // Segment confidence\n} TgCallerTranscriptionSegment;\n\n// Transcribe audio file\nTgCallerError tgcaller_transcribe_file(const char* file_path, const char* language, TgCallerTranscriptionResult* result);\n\n// Free transcription result\nvoid tgcaller_transcription_result_free(TgCallerTranscriptionResult* result);\n</code></pre>"},{"location":"c-api/structs/#memory-management","title":"Memory Management","text":"<p>All structures that contain allocated strings or arrays provide corresponding free functions:</p> <pre><code>// Free functions for structures with allocated memory\nvoid tgcaller_stream_info_free(TgCallerStreamInfo* info);\nvoid tgcaller_monitors_free(TgCallerMonitorInfo* monitors, size_t count);\nvoid tgcaller_audio_devices_free(TgCallerAudioDevice* devices, size_t count);\nvoid tgcaller_youtube_info_free(TgCallerYouTubeInfo* info);\nvoid tgcaller_transcription_result_free(TgCallerTranscriptionResult* result);\n</code></pre> <p>Always call the appropriate free function to avoid memory leaks when working with structures that contain allocated memory.</p>"}]}