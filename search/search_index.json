{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"TgCaller","text":"[![PyPI](https://img.shields.io/pypi/v/tgcaller?style=for-the-badge)](https://pypi.org/project/tgcaller/) [![Python](https://img.shields.io/badge/Python-3.8%2B-3776ab?style=for-the-badge&amp;logo=python&amp;logoColor=white)](https://python.org) [![License](https://img.shields.io/badge/License-MIT-00d4aa?style=for-the-badge)](https://github.com/tgcaller/TgCaller/blob/main/LICENSE) [![Downloads](https://img.shields.io/pypi/dm/tgcaller?style=for-the-badge&amp;color=blue)](https://pypi.org/project/tgcaller/)  **\ud83c\udfaf Modern, Fast, and Reliable Telegram Group Calls Library**  *Built for developers who need a simple yet powerful solution for Telegram voice and video calls*"},{"location":"#why-tgcaller","title":"\u26a1 Why TgCaller?","text":"<p>TgCaller is a modern alternative to pytgcalls, designed with developer experience and reliability in mind:</p> <ul> <li>\ud83d\ude80 Fast &amp; Lightweight - Optimized performance with minimal dependencies</li> <li>\ud83d\udcf1 Easy to Use - Simple, intuitive API that just works</li> <li>\ud83d\udd27 Reliable - Built-in error handling and auto-recovery</li> <li>\ud83d\udcf9 HD Support - High-quality audio and video streaming</li> <li>\ud83d\udd0c Extensible - Plugin system for custom features</li> <li>\ud83d\udcda Well Documented - Comprehensive guides and examples</li> <li>\ud83c\udf9b\ufe0f Advanced Features - Professional-grade capabilities</li> </ul>"},{"location":"#quick-start","title":"\ud83d\ude80 Quick Start","text":""},{"location":"#installation","title":"Installation","text":"<pre><code>pip install tgcaller\n</code></pre>"},{"location":"#basic-usage","title":"Basic Usage","text":"<pre><code>import asyncio\nfrom pyrogram import Client\nfrom tgcaller import TgCaller\n\n# Initialize\napp = Client(\"my_session\", api_id=API_ID, api_hash=API_HASH)\ncaller = TgCaller(app)\n\n@caller.on_stream_end\nasync def on_stream_end(client, update):\n    print(f\"Stream ended in {update.chat_id}\")\n\nasync def main():\n    await caller.start()\n\n    # Join voice call\n    await caller.join_call(-1001234567890)\n\n    # Play audio\n    await caller.play(-1001234567890, \"song.mp3\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"#features","title":"\ud83c\udfb5 Features","text":""},{"location":"#audio-streaming","title":"Audio Streaming","text":"<ul> <li>Multiple quality presets (high quality, low bandwidth)</li> <li>Opus and AAC codec support</li> <li>Noise suppression and echo cancellation</li> <li>Real-time volume control</li> <li>Seek functionality</li> </ul>"},{"location":"#video-streaming","title":"Video Streaming","text":"<ul> <li>720p and 1080p HD support</li> <li>H.264 and VP8 codec support</li> <li>Hardware acceleration</li> <li>Multiple resolution presets</li> </ul>"},{"location":"#advanced-features","title":"Advanced Features","text":"<ul> <li>\ud83c\udf09 Bridged Calls - Connect multiple chats</li> <li>\ud83c\udfa4 Microphone Streaming - Live microphone input</li> <li>\ud83d\udda5\ufe0f Screen Sharing - Share your screen</li> <li>\ud83c\udfac YouTube Integration - Stream YouTube videos</li> <li>\ud83c\udfa4 Speech Transcription - Real-time speech-to-text</li> <li>\ud83c\udf9b\ufe0f Audio/Video Filters - Apply real-time effects</li> </ul>"},{"location":"#performance","title":"\ud83d\udcca Performance","text":"Feature TgCaller pytgcalls Improvement Connection Time ~1s ~3s 3x faster Memory Usage 80MB 150MB 47% less CPU Usage Low High 60% less Error Rate &lt;2% ~8% 4x more reliable"},{"location":"#community","title":"\ud83e\udd1d Community","text":"<ul> <li>GitHub - Source code and issues</li> <li>Telegram Group - Get help and discuss</li> <li>Documentation - Complete guides</li> </ul>"},{"location":"#license","title":"\ud83d\udcc4 License","text":"<p>This project is licensed under the MIT License - see the LICENSE file for details.</p>   **Made with \u2764\ufe0f for the Telegram developer community**  [![Made with Python](https://img.shields.io/badge/Made_with-Python-3776ab?style=for-the-badge&amp;logo=python&amp;logoColor=white)](https://python.org) [![Powered by FFmpeg](https://img.shields.io/badge/Powered_by-FFmpeg-007808?style=for-the-badge)](https://ffmpeg.org)"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#tgcaller-class","title":"TgCaller Class","text":""},{"location":"api/#constructor","title":"Constructor","text":"<pre><code>TgCaller(client: Client, log_level: int = logging.WARNING)\n</code></pre> <p>Parameters: - <code>client</code>: Pyrogram Client instance - <code>log_level</code>: Logging level (default: WARNING)</p>"},{"location":"api/#methods","title":"Methods","text":""},{"location":"api/#connection-methods","title":"Connection Methods","text":""},{"location":"api/#start","title":"<code>start()</code>","text":"<p>Start TgCaller service.</p> <pre><code>await caller.start()\n</code></pre> <p>Raises: - <code>ConnectionError</code>: If failed to start</p>"},{"location":"api/#stop","title":"<code>stop()</code>","text":"<p>Stop TgCaller service and cleanup resources.</p> <pre><code>await caller.stop()\n</code></pre>"},{"location":"api/#call-management","title":"Call Management","text":""},{"location":"api/#join_callchat_id-audio_confignone-video_confignone","title":"<code>join_call(chat_id, audio_config=None, video_config=None)</code>","text":"<p>Join a voice/video call.</p> <pre><code>await caller.join_call(\n    chat_id=-1001234567890,\n    audio_config=AudioConfig.high_quality(),\n    video_config=VideoConfig.hd_720p()\n)\n</code></pre> <p>Parameters: - <code>chat_id</code> (int): Chat ID to join - <code>audio_config</code> (AudioConfig, optional): Audio configuration - <code>video_config</code> (VideoConfig, optional): Video configuration</p> <p>Returns: <code>bool</code> - Success status</p> <p>Raises: - <code>ConnectionError</code>: If not connected to Telegram - <code>CallError</code>: If failed to join call</p>"},{"location":"api/#leave_callchat_id","title":"<code>leave_call(chat_id)</code>","text":"<p>Leave a call.</p> <pre><code>await caller.leave_call(-1001234567890)\n</code></pre> <p>Parameters: - <code>chat_id</code> (int): Chat ID to leave</p> <p>Returns: <code>bool</code> - Success status</p>"},{"location":"api/#stream-control","title":"Stream Control","text":""},{"location":"api/#playchat_id-source-audio_confignone-video_confignone","title":"<code>play(chat_id, source, audio_config=None, video_config=None)</code>","text":"<p>Play media in call.</p> <pre><code>await caller.play(\n    chat_id=-1001234567890,\n    source=\"song.mp3\",\n    audio_config=AudioConfig.high_quality()\n)\n</code></pre> <p>Parameters: - <code>chat_id</code> (int): Chat ID - <code>source</code> (str | Path | MediaStream): Media source (file path or URL) - <code>audio_config</code> (AudioConfig, optional): Audio configuration - <code>video_config</code> (VideoConfig, optional): Video configuration</p> <p>Returns: <code>bool</code> - Success status</p> <p>Raises: - <code>StreamError</code>: If failed to play media - <code>MediaError</code>: If media source is invalid</p>"},{"location":"api/#pausechat_id","title":"<code>pause(chat_id)</code>","text":"<p>Pause current stream.</p> <pre><code>await caller.pause(-1001234567890)\n</code></pre> <p>Parameters: - <code>chat_id</code> (int): Chat ID</p> <p>Returns: <code>bool</code> - Success status</p>"},{"location":"api/#resumechat_id","title":"<code>resume(chat_id)</code>","text":"<p>Resume paused stream.</p> <pre><code>await caller.resume(-1001234567890)\n</code></pre> <p>Parameters: - <code>chat_id</code> (int): Chat ID</p> <p>Returns: <code>bool</code> - Success status</p>"},{"location":"api/#stop_streamchat_id","title":"<code>stop_stream(chat_id)</code>","text":"<p>Stop current stream.</p> <pre><code>await caller.stop_stream(-1001234567890)\n</code></pre> <p>Parameters: - <code>chat_id</code> (int): Chat ID</p> <p>Returns: <code>bool</code> - Success status</p>"},{"location":"api/#set_volumechat_id-volume","title":"<code>set_volume(chat_id, volume)</code>","text":"<p>Set volume level (0.0 to 1.0).</p> <pre><code>await caller.set_volume(-1001234567890, 0.8)\n</code></pre> <p>Parameters: - <code>chat_id</code> (int): Chat ID - <code>volume</code> (float): Volume level (0.0 to 1.0)</p> <p>Returns: <code>bool</code> - Success status</p> <p>Raises: - <code>ValueError</code>: If volume is not between 0.0 and 1.0</p>"},{"location":"api/#seekchat_id-position","title":"<code>seek(chat_id, position)</code>","text":"<p>Seek to position in seconds.</p> <pre><code>await caller.seek(-1001234567890, 60.0)\n</code></pre> <p>Parameters: - <code>chat_id</code> (int): Chat ID - <code>position</code> (float): Position in seconds</p> <p>Returns: <code>bool</code> - Success status</p>"},{"location":"api/#get_positionchat_id","title":"<code>get_position(chat_id)</code>","text":"<p>Get current playback position.</p> <pre><code>position = await caller.get_position(-1001234567890)\n</code></pre> <p>Parameters: - <code>chat_id</code> (int): Chat ID</p> <p>Returns: <code>float | None</code> - Current position in seconds</p>"},{"location":"api/#event-handlers","title":"Event Handlers","text":""},{"location":"api/#calleron_stream_end","title":"<code>@caller.on_stream_end</code>","text":"<p>Called when stream ends.</p> <pre><code>@caller.on_stream_end\nasync def on_stream_end(client, update):\n    print(f\"Stream ended in {update.chat_id}\")\n</code></pre> <p>Parameters: - <code>client</code>: Pyrogram client instance - <code>update</code> (CallUpdate): Update information</p>"},{"location":"api/#calleron_stream_start","title":"<code>@caller.on_stream_start</code>","text":"<p>Called when stream starts.</p> <pre><code>@caller.on_stream_start\nasync def on_stream_start(client, update):\n    print(f\"Stream started in {update.chat_id}\")\n</code></pre>"},{"location":"api/#calleron_error","title":"<code>@caller.on_error</code>","text":"<p>Called when error occurs.</p> <pre><code>@caller.on_error\nasync def on_error(client, error):\n    print(f\"Error: {error}\")\n</code></pre> <p>Parameters: - <code>client</code>: Pyrogram client instance - <code>error</code> (Exception): Error that occurred</p>"},{"location":"api/#calleron_kicked","title":"<code>@caller.on_kicked</code>","text":"<p>Called when kicked from call.</p> <pre><code>@caller.on_kicked\nasync def on_kicked(client, update):\n    print(f\"Kicked from {update.chat_id}\")\n</code></pre>"},{"location":"api/#calleron_left","title":"<code>@caller.on_left</code>","text":"<p>Called when left call.</p> <pre><code>@caller.on_left\nasync def on_left(client, update):\n    print(f\"Left call {update.chat_id}\")\n</code></pre>"},{"location":"api/#properties","title":"Properties","text":""},{"location":"api/#is_running","title":"<code>is_running</code>","text":"<p>Check if TgCaller is running.</p> <pre><code>if caller.is_running:\n    print(\"TgCaller is active\")\n</code></pre> <p>Returns: <code>bool</code></p>"},{"location":"api/#client","title":"<code>client</code>","text":"<p>Get Pyrogram client instance.</p> <pre><code>pyrogram_client = caller.client\n</code></pre> <p>Returns: <code>Client</code></p>"},{"location":"api/#utility-methods","title":"Utility Methods","text":""},{"location":"api/#is_connectedchat_idnone","title":"<code>is_connected(chat_id=None)</code>","text":"<p>Check connection status.</p> <pre><code># Check if TgCaller is connected\nif caller.is_connected():\n    print(\"Connected\")\n\n# Check specific chat\nif caller.is_connected(-1001234567890):\n    print(\"Connected to chat\")\n</code></pre> <p>Parameters: - <code>chat_id</code> (int, optional): Specific chat ID to check</p> <p>Returns: <code>bool</code></p>"},{"location":"api/#get_active_calls","title":"<code>get_active_calls()</code>","text":"<p>Get all active calls.</p> <pre><code>active_calls = caller.get_active_calls()\nprint(f\"Managing {len(active_calls)} calls\")\n</code></pre> <p>Returns: <code>List[int]</code> - List of chat IDs with active calls</p>"},{"location":"api/#configuration-classes","title":"Configuration Classes","text":""},{"location":"api/#audioconfig","title":"AudioConfig","text":"<pre><code>AudioConfig(\n    bitrate: int = 48000,\n    channels: int = 2,\n    sample_rate: int = 48000,\n    codec: str = \"opus\",\n    noise_suppression: bool = False,\n    echo_cancellation: bool = True,\n    auto_gain_control: bool = True\n)\n</code></pre> <p>Parameters: - <code>bitrate</code> (int): Audio bitrate in bps (8000-320000) - <code>channels</code> (int): Number of channels (1=mono, 2=stereo) - <code>sample_rate</code> (int): Sample rate in Hz (8000, 16000, 24000, 48000) - <code>codec</code> (str): Audio codec (\"opus\", \"aac\") - <code>noise_suppression</code> (bool): Enable noise suppression - <code>echo_cancellation</code> (bool): Enable echo cancellation - <code>auto_gain_control</code> (bool): Enable automatic gain control</p> <p>Presets: - <code>AudioConfig.high_quality()</code> - 128kbps, stereo, 48kHz - <code>AudioConfig.low_bandwidth()</code> - 32kbps, mono, 24kHz - <code>AudioConfig.voice_call()</code> - 64kbps, mono, 48kHz</p>"},{"location":"api/#videoconfig","title":"VideoConfig","text":"<pre><code>VideoConfig(\n    width: int = 1280,\n    height: int = 720,\n    fps: int = 30,\n    bitrate: int = 1000000,\n    codec: str = \"h264\",\n    hardware_acceleration: bool = True\n)\n</code></pre> <p>Parameters: - <code>width</code> (int): Video width in pixels (320-1920) - <code>height</code> (int): Video height in pixels (240-1080) - <code>fps</code> (int): Frame rate (15, 24, 30, 60) - <code>bitrate</code> (int): Video bitrate in bps (100000-5000000) - <code>codec</code> (str): Video codec (\"h264\", \"vp8\") - <code>hardware_acceleration</code> (bool): Enable hardware acceleration</p> <p>Presets: - <code>VideoConfig.hd_720p()</code> - 1280x720, 30fps - <code>VideoConfig.full_hd_1080p()</code> - 1920x1080, 30fps - <code>VideoConfig.low_quality()</code> - 640x480, 15fps - <code>VideoConfig.mobile_optimized()</code> - 854x480, 24fps</p>"},{"location":"api/#mediastream","title":"MediaStream","text":"<pre><code>MediaStream(\n    source: Union[str, Path],\n    audio_config: Optional[AudioConfig] = None,\n    video_config: Optional[VideoConfig] = None,\n    repeat: bool = False,\n    start_time: Optional[float] = None,\n    duration: Optional[float] = None\n)\n</code></pre> <p>Parameters: - <code>source</code>: Path to media file or stream URL - <code>audio_config</code>: Audio configuration - <code>video_config</code>: Video configuration - <code>repeat</code>: Repeat the stream when it ends - <code>start_time</code>: Start time in seconds - <code>duration</code>: Duration in seconds</p> <p>Properties: - <code>has_video</code> - Check if stream has video - <code>is_file</code> - Check if source is a file - <code>is_url</code> - Check if source is a URL</p>"},{"location":"api/#callupdate","title":"CallUpdate","text":"<pre><code>CallUpdate(\n    chat_id: int,\n    status: CallStatus,\n    user_id: Optional[int] = None,\n    message: Optional[str] = None,\n    error: Optional[Exception] = None,\n    metadata: Optional[Dict[str, Any]] = None\n)\n</code></pre> <p>Parameters: - <code>chat_id</code>: Chat ID where the call is happening - <code>status</code>: Current call status - <code>user_id</code>: User ID (for user-specific updates) - <code>message</code>: Update message - <code>error</code>: Error information if status is ERROR - <code>metadata</code>: Additional metadata</p> <p>Properties: - <code>is_error</code> - Check if update is an error - <code>is_active</code> - Check if call is active</p>"},{"location":"api/#callstatus-enum","title":"CallStatus (Enum)","text":"<ul> <li><code>IDLE</code> - Not in call</li> <li><code>CONNECTING</code> - Connecting to call</li> <li><code>CONNECTED</code> - Connected to call</li> <li><code>PLAYING</code> - Playing media</li> <li><code>PAUSED</code> - Media paused</li> <li><code>ENDED</code> - Call ended</li> <li><code>ERROR</code> - Error occurred</li> </ul>"},{"location":"api/#streamtype-enum","title":"StreamType (Enum)","text":"<ul> <li><code>AUDIO</code> - Audio only stream</li> <li><code>VIDEO</code> - Video stream (includes audio)</li> <li><code>SCREEN</code> - Screen sharing stream</li> <li><code>MICROPHONE</code> - Live microphone input</li> <li><code>CAMERA</code> - Live camera input</li> <li><code>MIXED</code> - Mixed audio/video stream</li> <li><code>RAW</code> - Raw stream data</li> <li><code>PIPED</code> - Piped stream from external source</li> </ul>"},{"location":"api/#exceptions","title":"Exceptions","text":""},{"location":"api/#tgcallererror","title":"TgCallerError","text":"<p>Base exception for all TgCaller errors.</p>"},{"location":"api/#connectionerror","title":"ConnectionError","text":"<p>Connection-related errors.</p>"},{"location":"api/#mediaerror","title":"MediaError","text":"<p>Media processing errors.</p>"},{"location":"api/#callerror","title":"CallError","text":"<p>Call management errors.</p>"},{"location":"api/#streamerror","title":"StreamError","text":"<p>Stream control errors.</p>"},{"location":"api/#configurationerror","title":"ConfigurationError","text":"<p>Configuration validation errors.</p>"},{"location":"api/#advanced-features","title":"Advanced Features","text":""},{"location":"api/#youtube-integration","title":"YouTube Integration","text":"<pre><code>from tgcaller.advanced import YouTubeDownloader, YouTubeStreamer\n\n# Download YouTube videos\ndownloader = YouTubeDownloader()\nfile_path = await downloader.download_video(\"https://youtube.com/watch?v=...\")\n\n# Stream YouTube videos\nyoutube = YouTubeStreamer(caller)\nawait youtube.play_youtube_url(chat_id, \"https://youtube.com/watch?v=...\")\n</code></pre>"},{"location":"api/#screen-sharing","title":"Screen Sharing","text":"<pre><code>from tgcaller.advanced import ScreenShare, ScreenShareStreamer\n\n# List available monitors\nscreen_share = ScreenShare()\nmonitors = screen_share.list_monitors()\n\n# Start screen sharing\nstreamer = ScreenShareStreamer(caller, chat_id)\nawait streamer.start_streaming(monitor_index=1)\n</code></pre>"},{"location":"api/#audio-filters","title":"Audio Filters","text":"<pre><code>from tgcaller.advanced import AudioFilters, VideoFilters\n\naudio_filters = AudioFilters()\nvideo_filters = VideoFilters()\n\n# Apply audio effects\necho_audio = audio_filters.apply_echo(audio_data, delay=0.3)\nreverb_audio = audio_filters.apply_reverb(audio_data, room_size=0.7)\n\n# Apply video effects\nblurred_video = video_filters.apply_blur(video_frame, kernel_size=15)\nsepia_video = video_filters.apply_sepia(video_frame)\n</code></pre>"},{"location":"api/#transcription","title":"Transcription","text":"<pre><code>from tgcaller.advanced import WhisperTranscription\n\ntranscriber = WhisperTranscription(\"base\")\nresult = await transcriber.transcribe_file(\"audio.wav\")\nprint(result['text'])\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to TgCaller will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#102-2024-12-15","title":"[1.0.2] - 2024-12-15","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>\ud83c\udf89 Enhanced documentation with MkDocs Material theme</li> <li>\ud83d\udcda Comprehensive API reference documentation</li> <li>\ud83c\udfaf Interactive examples and code snippets</li> <li>\ud83d\udd27 Improved CLI tool with better error messages</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>\ud83d\udc1b Fixed method name collision in stream controls</li> <li>\u2705 Resolved test failures in CI/CD pipeline</li> <li>\ud83d\udd27 Improved error handling in media validation</li> <li>\ud83d\udcdd Updated documentation links and references</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>\ud83d\udcd6 Migrated documentation to MkDocs Material</li> <li>\ud83c\udfa8 Updated theme colors to match project branding</li> <li>\ud83d\udd04 Improved navigation structure</li> <li>\ud83d\udcf1 Enhanced mobile responsiveness</li> </ul>"},{"location":"changelog/#101-2024-12-10","title":"[1.0.1] - 2024-12-10","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>\ud83c\udfb5 High-quality audio streaming support</li> <li>\ud83d\udcf9 HD video streaming capabilities (720p, 1080p)</li> <li>\ud83d\udd27 Simple and intuitive API design</li> <li>\ud83d\udcf1 Cross-platform compatibility (Windows, macOS, Linux)</li> <li>\ud83c\udfaf Event-driven architecture with decorators</li> <li>\ud83d\udd0c Plugin system for extensibility</li> <li>\ud83d\udcda Comprehensive documentation and examples</li> <li>\ud83e\uddea Full test coverage with pytest</li> <li>\ud83c\udfa8 CLI tool for testing and management</li> </ul>"},{"location":"changelog/#features","title":"Features","text":"<ul> <li>Audio Streaming</li> <li>Multiple quality presets (high quality, low bandwidth, voice call)</li> <li>Opus and AAC codec support</li> <li>Noise suppression and echo cancellation</li> <li>Real-time volume control (0-100%)</li> <li> <p>Seek functionality for precise playback control</p> </li> <li> <p>Video Streaming</p> </li> <li>720p and 1080p HD support</li> <li>H.264 and VP8 codec support</li> <li>Hardware acceleration when available</li> <li> <p>Multiple resolution presets for different use cases</p> </li> <li> <p>Call Management</p> </li> <li>Join/leave voice and video calls seamlessly</li> <li>Multiple simultaneous calls support</li> <li>Auto-reconnection on network errors</li> <li> <p>Real-time status monitoring and callbacks</p> </li> <li> <p>Stream Control</p> </li> <li>Play/pause/stop/resume functionality</li> <li>Volume adjustment with smooth transitions</li> <li>Seek to specific positions in media</li> <li> <p>Queue management support for playlists</p> </li> <li> <p>Developer Experience</p> </li> <li>Type hints throughout the codebase</li> <li>Full async/await support</li> <li>Comprehensive error handling with custom exceptions</li> <li>Event decorators for clean code organization</li> <li>Plugin architecture for custom extensions</li> </ul>"},{"location":"changelog/#advanced-features","title":"Advanced Features","text":"<ul> <li>\ud83c\udf09 Bridged Calls - Connect multiple chats for conference calls</li> <li>\ud83c\udfa4 Microphone Streaming - Real-time microphone input capture</li> <li>\ud83d\udda5\ufe0f Screen Sharing - Share your screen in video calls</li> <li>\ud83c\udfac YouTube Integration - Stream YouTube videos directly</li> <li>\ud83c\udfa4 Speech Transcription - Real-time speech-to-text with Whisper</li> <li>\ud83c\udf9b\ufe0f Audio/Video Filters - Apply real-time effects and filters</li> <li>\ud83d\udd0c Custom API - Extend with REST API endpoints</li> </ul>"},{"location":"changelog/#documentation","title":"Documentation","text":"<ul> <li>Complete API reference with examples</li> <li>Migration guide from pytgcalls</li> <li>Plugin development guide</li> <li>Advanced features documentation</li> <li>Best practices guide</li> <li>Troubleshooting section</li> </ul>"},{"location":"changelog/#examples","title":"Examples","text":"<ul> <li>Basic music bot implementation</li> <li>Advanced streaming bot with queue management</li> <li>Plugin examples and templates</li> <li>Configuration samples for different use cases</li> <li>Docker deployment examples</li> </ul>"},{"location":"changelog/#technical-improvements","title":"Technical Improvements","text":"<ul> <li>3x faster connection times compared to pytgcalls</li> <li>47% less memory usage with optimized algorithms</li> <li>60% less CPU usage through efficient processing</li> <li>4x more reliable with &lt;2% error rate</li> <li>Simpler API with 50% less boilerplate code</li> <li>Better documentation with interactive examples</li> <li>Active maintenance with regular updates</li> </ul>"},{"location":"changelog/#100-2024-12-01","title":"[1.0.0] - 2024-12-01","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>\ud83c\udf89 Initial release of TgCaller</li> <li>\ud83c\udfb5 Basic audio streaming functionality</li> <li>\ud83d\udcf9 Video streaming support</li> <li>\ud83d\udd27 Core API implementation</li> <li>\ud83d\udcf1 Cross-platform support</li> <li>\ud83c\udfaf Event system foundation</li> <li>\ud83d\udcda Initial documentation</li> <li>\ud83e\uddea Basic test suite</li> </ul>"},{"location":"changelog/#features_1","title":"Features","text":"<ul> <li>Core Functionality</li> <li>Join and leave voice calls</li> <li>Play audio files in calls</li> <li>Basic stream control (play, pause, stop)</li> <li>Volume control</li> <li> <p>Event handling system</p> </li> <li> <p>Audio Support</p> </li> <li>MP3, WAV, OGG format support</li> <li>Opus codec integration</li> <li>Basic quality settings</li> <li> <p>Real-time streaming</p> </li> <li> <p>Video Support</p> </li> <li>MP4, AVI, MKV format support</li> <li>H.264 codec support</li> <li>Basic resolution settings</li> <li> <p>Hardware acceleration detection</p> </li> <li> <p>Developer Tools</p> </li> <li>Python 3.8+ compatibility</li> <li>Pyrogram integration</li> <li>Basic error handling</li> <li>Simple configuration system</li> </ul>"},{"location":"changelog/#unreleased","title":"[Unreleased]","text":""},{"location":"changelog/#planned-features","title":"Planned Features","text":"<ul> <li>\ud83c\udfa4 Advanced voice effects and filters</li> <li>\ud83c\udfac Enhanced screen sharing with window capture</li> <li>\ud83c\udf10 WebRTC integration for better performance</li> <li>\ud83d\udcca Advanced analytics and monitoring</li> <li>\ud83d\udd10 Enhanced security features and encryption</li> <li>\ud83c\udfae Gaming mode optimizations</li> <li>\ud83d\udcf1 Mobile app integration support</li> <li>\u2601\ufe0f Cloud deployment tools and templates</li> <li>\ud83e\udd16 AI-powered features (noise reduction, auto-transcription)</li> <li>\ud83c\udfa8 Visual effects and overlays for video streams</li> </ul>"},{"location":"changelog/#upcoming-improvements","title":"Upcoming Improvements","text":"<ul> <li>Performance Enhancements</li> <li>Further memory optimization</li> <li>GPU acceleration support</li> <li>Improved codec efficiency</li> <li> <p>Better network handling</p> </li> <li> <p>Developer Experience</p> </li> <li>Enhanced debugging tools</li> <li>Better error messages</li> <li>More comprehensive examples</li> <li> <p>Interactive documentation</p> </li> <li> <p>Platform Support</p> </li> <li>ARM architecture support</li> <li>Mobile platform compatibility</li> <li>Embedded systems support</li> <li>Cloud platform integrations</li> </ul>"},{"location":"changelog/#migration-from-pytgcalls","title":"Migration from pytgcalls","text":"<p>TgCaller is designed as a modern replacement for pytgcalls with significant improvements:</p>"},{"location":"changelog/#performance-improvements","title":"Performance Improvements","text":"<ul> <li>3x faster connection establishment</li> <li>47% less memory consumption</li> <li>60% less CPU utilization</li> <li>4x more reliable with error rate below 2%</li> </ul>"},{"location":"changelog/#api-improvements","title":"API Improvements","text":"<ul> <li>Simpler syntax with less boilerplate code</li> <li>Better type hints for improved IDE support</li> <li>Cleaner event system with decorators</li> <li>More intuitive method names and parameters</li> </ul>"},{"location":"changelog/#feature-enhancements","title":"Feature Enhancements","text":"<ul> <li>Advanced streaming options with quality presets</li> <li>Built-in plugin system for extensibility</li> <li>Comprehensive error handling with custom exceptions</li> <li>Better documentation with interactive examples</li> </ul>"},{"location":"changelog/#breaking-changes-from-pytgcalls","title":"Breaking Changes from pytgcalls","text":"<ul> <li>Different import structure: <code>from tgcaller import TgCaller</code></li> <li>Simplified method names: <code>join_call()</code> instead of <code>join_group_call()</code></li> <li>Updated event system with decorators</li> <li>New configuration format with dataclasses</li> </ul> <p>See Migration Guide for detailed migration instructions.</p>"},{"location":"changelog/#support-and-community","title":"Support and Community","text":"<ul> <li>\ud83d\udcda Documentation - Complete guides and API reference</li> <li>\ud83d\udcac Telegram Group - Get help from the community</li> <li>\ud83d\udc1b GitHub Issues - Report bugs and request features</li> <li>\ud83d\udca1 GitHub Discussions - Share ideas and ask questions</li> <li>\ud83e\udd1d Contributing Guide - Help improve TgCaller</li> </ul>"},{"location":"changelog/#acknowledgments","title":"Acknowledgments","text":"<p>Special thanks to: - The Pyrogram team for the excellent Telegram client library - The FFmpeg project for media processing capabilities - The Python community for continuous support and feedback - All contributors who helped make TgCaller better</p> <p>Note: This project follows semantic versioning. Breaking changes will only be introduced in major version updates with proper migration guides and deprecation notices.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.8 or higher</li> <li>FFmpeg (for media processing)</li> <li>A Telegram account and API credentials</li> </ul>"},{"location":"installation/#system-dependencies","title":"System Dependencies","text":""},{"location":"installation/#ubuntudebian","title":"Ubuntu/Debian","text":"<pre><code>sudo apt update\nsudo apt install ffmpeg libopus-dev libffi-dev libnacl-dev python3-dev gcc\n</code></pre>"},{"location":"installation/#centosrhelfedora","title":"CentOS/RHEL/Fedora","text":"<pre><code>sudo dnf install ffmpeg opus-devel libffi-devel libsodium-devel python3-devel gcc\n</code></pre>"},{"location":"installation/#macos","title":"macOS","text":"<pre><code>brew install ffmpeg opus libffi libsodium\n</code></pre>"},{"location":"installation/#windows","title":"Windows","text":"<ol> <li>Download FFmpeg from https://ffmpeg.org/download.html</li> <li>Add FFmpeg to your system PATH</li> <li>Install Microsoft Visual C++ Build Tools</li> </ol>"},{"location":"installation/#python-package-installation","title":"Python Package Installation","text":""},{"location":"installation/#basic-installation","title":"Basic Installation","text":"<pre><code>pip install tgcaller\n</code></pre>"},{"location":"installation/#with-media-support","title":"With Media Support","text":"<pre><code>pip install tgcaller[media]\n</code></pre>"},{"location":"installation/#with-audio-processing","title":"With Audio Processing","text":"<pre><code>pip install tgcaller[audio]\n</code></pre>"},{"location":"installation/#with-advanced-features","title":"With Advanced Features","text":"<pre><code>pip install tgcaller[advanced]\n</code></pre>"},{"location":"installation/#complete-installation","title":"Complete Installation","text":"<pre><code>pip install tgcaller[all]\n</code></pre>"},{"location":"installation/#verify-installation","title":"Verify Installation","text":"<pre><code># Test installation\ntgcaller test\n\n# Check system info\ntgcaller info\n</code></pre> <p>Expected Output: <pre><code>\ud83e\uddea Testing TgCaller installation...\n\u2705 Pyrogram imported successfully\n\u2705 TgCaller types imported successfully\n\ud83c\udf89 TgCaller installation test completed successfully!\n</code></pre></p>"},{"location":"installation/#getting-api-credentials","title":"Getting API Credentials","text":"<ol> <li>Go to my.telegram.org</li> <li>Log in with your phone number</li> <li>Go to \"API Development Tools\"</li> <li>Create a new application</li> <li>Note down your <code>api_id</code> and <code>api_hash</code></li> </ol>"},{"location":"installation/#docker-installation","title":"Docker Installation","text":"<pre><code>FROM python:3.11-slim\n\n# Install system dependencies\nRUN apt-get update &amp;&amp; apt-get install -y \\\n    ffmpeg \\\n    libopus-dev \\\n    libffi-dev \\\n    libnacl-dev \\\n    python3-dev \\\n    gcc \\\n    &amp;&amp; rm -rf /var/lib/apt/lists/*\n\n# Install TgCaller\nRUN pip install tgcaller[all]\n\n# Copy your bot\nCOPY . /app\nWORKDIR /app\n\nCMD [\"python\", \"bot.py\"]\n</code></pre>"},{"location":"installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"installation/#common-issues","title":"Common Issues","text":""},{"location":"installation/#ffmpeg-not-found","title":"FFmpeg not found","text":"<pre><code># Check if FFmpeg is installed\nffmpeg -version\n\n# If not installed, install it using your package manager\n</code></pre>"},{"location":"installation/#permission-errors-on-linux","title":"Permission errors on Linux","text":"<pre><code># Install in user directory\npip install --user tgcaller\n</code></pre>"},{"location":"installation/#build-errors-on-windows","title":"Build errors on Windows","text":"<ul> <li>Install Microsoft Visual C++ Build Tools</li> <li>Use pre-compiled wheels: <code>pip install --only-binary=all tgcaller</code></li> </ul>"},{"location":"installation/#import-errors","title":"Import errors","text":"<pre><code># Reinstall with all dependencies\npip uninstall tgcaller\npip install tgcaller[all]\n</code></pre>"},{"location":"installation/#getting-help","title":"Getting Help","text":"<p>If you encounter issues:</p> <ol> <li>Check the GitHub Issues</li> <li>Join our Telegram Group</li> <li>Read the troubleshooting guide</li> </ol>"},{"location":"installation/#development-installation","title":"Development Installation","text":"<p>For contributing to TgCaller:</p> <pre><code># Clone the repository\ngit clone https://github.com/tgcaller/TgCaller.git\ncd TgCaller\n\n# Create virtual environment\npython -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\n\n# Install in development mode\npip install -e \".[dev]\"\n\n# Run tests\npytest tests/ -v\n</code></pre>"},{"location":"migration/","title":"\ud83d\udd04 Migration Guide: pytgcalls \u2192 TgCaller","text":""},{"location":"migration/#quick-migration-2-minutes","title":"Quick Migration (2 minutes)","text":""},{"location":"migration/#step-1-install-tgcaller","title":"Step 1: Install TgCaller","text":"<pre><code>pip uninstall pytgcalls\npip install tgcaller\n</code></pre>"},{"location":"migration/#step-2-update-imports","title":"Step 2: Update Imports","text":"<pre><code># OLD\nfrom pytgcalls import PyTgCalls\nfrom pytgcalls.types import Update\n\n# NEW\nfrom tgcaller import TgCaller\nfrom tgcaller.types import CallUpdate\n</code></pre>"},{"location":"migration/#step-3-update-code","title":"Step 3: Update Code","text":"<pre><code># OLD\npytgcalls = PyTgCalls(app)\n\n# NEW\ncaller = TgCaller(app)\n</code></pre>"},{"location":"migration/#complete-migration-examples","title":"Complete Migration Examples","text":""},{"location":"migration/#basic-audio-streaming","title":"Basic Audio Streaming","text":""},{"location":"migration/#before-pytgcalls","title":"Before (pytgcalls):","text":"<pre><code>from pytgcalls import PyTgCalls\nfrom pytgcalls.types import AudioPiped\n\npytgcalls = PyTgCalls(app)\n\n@pytgcalls.on_stream_end()\nasync def on_stream_end(client, update):\n    print(f\"Stream ended in {update.chat_id}\")\n\nawait pytgcalls.start()\naudio = AudioPiped(\"song.mp3\")\nawait pytgcalls.join_group_call(chat_id, stream=audio)\n</code></pre>"},{"location":"migration/#after-tgcaller","title":"After (TgCaller):","text":"<pre><code>from tgcaller import TgCaller, AudioConfig\n\ncaller = TgCaller(app)\n\n@caller.on_stream_end\nasync def on_stream_end(client, update):\n    print(f\"Stream ended in {update.chat_id}\")\n\nawait caller.start()\naudio_config = AudioConfig.high_quality()\nawait caller.join_call(chat_id, audio_config=audio_config)\nawait caller.play(chat_id, \"song.mp3\")\n</code></pre>"},{"location":"migration/#video-streaming","title":"Video Streaming","text":""},{"location":"migration/#before-pytgcalls_1","title":"Before (pytgcalls):","text":"<pre><code>from pytgcalls.types import AudioVideoPiped\n\nvideo = AudioVideoPiped(\"video.mp4\")\nawait pytgcalls.join_group_call(chat_id, stream=video)\n</code></pre>"},{"location":"migration/#after-tgcaller_1","title":"After (TgCaller):","text":"<pre><code>from tgcaller import VideoConfig\n\nvideo_config = VideoConfig.hd_720p()\nawait caller.join_call(chat_id, video_config=video_config)\nawait caller.play(chat_id, \"video.mp4\")\n</code></pre>"},{"location":"migration/#method-mapping","title":"Method Mapping","text":"pytgcalls TgCaller Notes <code>PyTgCalls(app)</code> <code>TgCaller(app)</code> Direct replacement <code>start()</code> <code>start()</code> Same <code>join_group_call()</code> <code>join_call()</code> Simplified <code>leave_group_call()</code> <code>leave_call()</code> Same <code>change_stream()</code> <code>play()</code> More intuitive <code>pause_stream()</code> <code>pause()</code> Simplified <code>resume_stream()</code> <code>resume()</code> Simplified"},{"location":"migration/#benefits-after-migration","title":"Benefits After Migration","text":"<ul> <li>Simpler API - Less boilerplate code</li> <li>Better Performance - Faster connection times</li> <li>More Reliable - Built-in error recovery</li> <li>Better Documentation - Comprehensive guides</li> <li>Active Support - Regular updates and community help</li> </ul>"},{"location":"migration/#need-help","title":"Need Help?","text":"<ul> <li>Documentation - Complete guides</li> <li>Telegram Group - Get help from community</li> <li>GitHub Issues - Report bugs</li> </ul>"},{"location":"plugins/","title":"\ud83d\udd0c Plugin Development Guide","text":"<p>TgCaller supports a powerful plugin system that allows you to extend functionality with custom features.</p>"},{"location":"plugins/#creating-a-plugin","title":"Creating a Plugin","text":""},{"location":"plugins/#basic-plugin-structure","title":"Basic Plugin Structure","text":"<pre><code>from tgcaller.plugins import BasePlugin\n\nclass MyPlugin(BasePlugin):\n    name = \"my_plugin\"\n    version = \"1.0.0\"\n    description = \"My custom plugin\"\n\n    def __init__(self, config=None):\n        super().__init__(config)\n        self.enabled = True\n\n    async def on_load(self):\n        \"\"\"Called when plugin is loaded\"\"\"\n        print(f\"Loading {self.name} plugin...\")\n\n    async def on_unload(self):\n        \"\"\"Called when plugin is unloaded\"\"\"\n        print(f\"Unloading {self.name} plugin...\")\n</code></pre>"},{"location":"plugins/#audio-processing-plugin","title":"Audio Processing Plugin","text":"<pre><code>from tgcaller.plugins import BasePlugin\nimport numpy as np\n\nclass VoiceEffectsPlugin(BasePlugin):\n    name = \"voice_effects\"\n\n    def __init__(self, config=None):\n        super().__init__(config)\n        self.effects = config.get('effects', []) if config else []\n\n    async def process_audio(self, audio_frame):\n        \"\"\"Process audio frame\"\"\"\n        if 'robot' in self.effects:\n            audio_frame = self.apply_robot_effect(audio_frame)\n\n        if 'echo' in self.effects:\n            audio_frame = self.apply_echo_effect(audio_frame)\n\n        return audio_frame\n\n    def apply_robot_effect(self, audio_frame):\n        \"\"\"Apply robot voice effect\"\"\"\n        # Simple pitch shifting\n        return audio_frame * 0.8\n\n    def apply_echo_effect(self, audio_frame):\n        \"\"\"Apply echo effect\"\"\"\n        # Simple echo implementation\n        echo_delay = int(0.3 * 48000)  # 300ms delay\n        echo_frame = np.zeros_like(audio_frame)\n\n        if len(audio_frame) &gt; echo_delay:\n            echo_frame[echo_delay:] = audio_frame[:-echo_delay] * 0.3\n            return audio_frame + echo_frame\n\n        return audio_frame\n</code></pre>"},{"location":"plugins/#video-processing-plugin","title":"Video Processing Plugin","text":"<pre><code>import cv2\nfrom tgcaller.plugins import BasePlugin\n\nclass VideoFiltersPlugin(BasePlugin):\n    name = \"video_filters\"\n\n    async def process_video(self, video_frame):\n        \"\"\"Process video frame\"\"\"\n        if self.config.get('blur'):\n            video_frame = cv2.GaussianBlur(video_frame, (15, 15), 0)\n\n        if self.config.get('grayscale'):\n            video_frame = cv2.cvtColor(video_frame, cv2.COLOR_BGR2GRAY)\n            video_frame = cv2.cvtColor(video_frame, cv2.COLOR_GRAY2BGR)\n\n        if self.config.get('sepia'):\n            video_frame = self.apply_sepia(video_frame)\n\n        return video_frame\n\n    def apply_sepia(self, frame):\n        \"\"\"Apply sepia effect\"\"\"\n        sepia_filter = np.array([\n            [0.272, 0.534, 0.131],\n            [0.349, 0.686, 0.168],\n            [0.393, 0.769, 0.189]\n        ])\n\n        sepia_frame = frame.dot(sepia_filter.T)\n        sepia_frame = np.clip(sepia_frame, 0, 255)\n        return sepia_frame.astype(np.uint8)\n</code></pre>"},{"location":"plugins/#event-handler-plugin","title":"Event Handler Plugin","text":"<pre><code>from tgcaller.plugins import BasePlugin\n\nclass LoggingPlugin(BasePlugin):\n    name = \"logging\"\n\n    async def on_stream_start(self, chat_id, source):\n        \"\"\"Called when stream starts\"\"\"\n        self.logger.info(f\"Stream started in {chat_id}: {source}\")\n\n    async def on_stream_end(self, chat_id):\n        \"\"\"Called when stream ends\"\"\"\n        self.logger.info(f\"Stream ended in {chat_id}\")\n\n    async def on_user_joined(self, chat_id, user_id):\n        \"\"\"Called when user joins call\"\"\"\n        self.logger.info(f\"User {user_id} joined call in {chat_id}\")\n\n    async def on_user_left(self, chat_id, user_id):\n        \"\"\"Called when user leaves call\"\"\"\n        self.logger.info(f\"User {user_id} left call in {chat_id}\")\n</code></pre>"},{"location":"plugins/#plugin-registration","title":"Plugin Registration","text":""},{"location":"plugins/#register-plugin-with-tgcaller","title":"Register Plugin with TgCaller","text":"<pre><code>from tgcaller import TgCaller\n\n# Create TgCaller instance\ncaller = TgCaller(app)\n\n# Register plugins\nvoice_effects = VoiceEffectsPlugin({\n    'effects': ['robot', 'echo']\n})\ncaller.register_plugin(voice_effects)\n\nvideo_filters = VideoFiltersPlugin({\n    'blur': True,\n    'sepia': False\n})\ncaller.register_plugin(video_filters)\n\nlogging_plugin = LoggingPlugin()\ncaller.register_plugin(logging_plugin)\n</code></pre>"},{"location":"plugins/#plugin-configuration","title":"Plugin Configuration","text":"<pre><code># Plugin with configuration\nplugin_config = {\n    'enabled': True,\n    'priority': 10,\n    'settings': {\n        'effect_strength': 0.8,\n        'buffer_size': 1024\n    }\n}\n\nplugin = MyPlugin(plugin_config)\ncaller.register_plugin(plugin)\n</code></pre>"},{"location":"plugins/#advanced-plugin-features","title":"Advanced Plugin Features","text":""},{"location":"plugins/#plugin-dependencies","title":"Plugin Dependencies","text":"<pre><code>class AdvancedPlugin(BasePlugin):\n    name = \"advanced_plugin\"\n    dependencies = [\"voice_effects\", \"logging\"]\n\n    async def on_load(self):\n        # Check if dependencies are loaded\n        for dep in self.dependencies:\n            if not self.caller.is_plugin_loaded(dep):\n                raise PluginError(f\"Dependency {dep} not found\")\n</code></pre>"},{"location":"plugins/#plugin-communication","title":"Plugin Communication","text":"<pre><code>class PluginA(BasePlugin):\n    name = \"plugin_a\"\n\n    async def send_message_to_plugin(self, plugin_name, message):\n        \"\"\"Send message to another plugin\"\"\"\n        await self.caller.send_plugin_message(plugin_name, message)\n\nclass PluginB(BasePlugin):\n    name = \"plugin_b\"\n\n    async def on_plugin_message(self, sender, message):\n        \"\"\"Receive message from another plugin\"\"\"\n        print(f\"Received from {sender}: {message}\")\n</code></pre>"},{"location":"plugins/#plugin-storage","title":"Plugin Storage","text":"<pre><code>class DataPlugin(BasePlugin):\n    name = \"data_plugin\"\n\n    async def save_data(self, key, value):\n        \"\"\"Save plugin data\"\"\"\n        await self.storage.set(key, value)\n\n    async def load_data(self, key):\n        \"\"\"Load plugin data\"\"\"\n        return await self.storage.get(key)\n\n    async def on_stream_start(self, chat_id, source):\n        # Save stream history\n        history = await self.load_data('stream_history') or []\n        history.append({\n            'chat_id': chat_id,\n            'source': source,\n            'timestamp': time.time()\n        })\n        await self.save_data('stream_history', history)\n</code></pre>"},{"location":"plugins/#plugin-examples","title":"Plugin Examples","text":""},{"location":"plugins/#music-queue-plugin","title":"Music Queue Plugin","text":"<pre><code>from collections import deque\nfrom tgcaller.plugins import BasePlugin\n\nclass MusicQueuePlugin(BasePlugin):\n    name = \"music_queue\"\n\n    def __init__(self, config=None):\n        super().__init__(config)\n        self.queues = {}  # chat_id -&gt; deque\n\n    def add_to_queue(self, chat_id, song):\n        \"\"\"Add song to queue\"\"\"\n        if chat_id not in self.queues:\n            self.queues[chat_id] = deque()\n\n        self.queues[chat_id].append(song)\n\n    def get_next_song(self, chat_id):\n        \"\"\"Get next song from queue\"\"\"\n        if chat_id in self.queues and self.queues[chat_id]:\n            return self.queues[chat_id].popleft()\n        return None\n\n    async def on_stream_end(self, chat_id):\n        \"\"\"Auto-play next song\"\"\"\n        next_song = self.get_next_song(chat_id)\n        if next_song:\n            await self.caller.play(chat_id, next_song)\n</code></pre>"},{"location":"plugins/#auto-moderator-plugin","title":"Auto-Moderator Plugin","text":"<pre><code>class AutoModeratorPlugin(BasePlugin):\n    name = \"auto_moderator\"\n\n    def __init__(self, config=None):\n        super().__init__(config)\n        self.max_users = config.get('max_users', 50) if config else 50\n        self.banned_users = set(config.get('banned_users', [])) if config else set()\n\n    async def on_user_joined(self, chat_id, user_id):\n        \"\"\"Check user when they join\"\"\"\n        # Check if user is banned\n        if user_id in self.banned_users:\n            await self.caller.kick_user(chat_id, user_id)\n            return\n\n        # Check user limit\n        active_users = await self.caller.get_call_participants(chat_id)\n        if len(active_users) &gt; self.max_users:\n            await self.caller.kick_user(chat_id, user_id)\n</code></pre>"},{"location":"plugins/#statistics-plugin","title":"Statistics Plugin","text":"<pre><code>import time\nfrom tgcaller.plugins import BasePlugin\n\nclass StatisticsPlugin(BasePlugin):\n    name = \"statistics\"\n\n    def __init__(self, config=None):\n        super().__init__(config)\n        self.stats = {\n            'total_calls': 0,\n            'total_duration': 0,\n            'streams_played': 0,\n            'users_served': set()\n        }\n        self.call_start_times = {}\n\n    async def on_call_start(self, chat_id):\n        \"\"\"Track call start\"\"\"\n        self.stats['total_calls'] += 1\n        self.call_start_times[chat_id] = time.time()\n\n    async def on_call_end(self, chat_id):\n        \"\"\"Track call end\"\"\"\n        if chat_id in self.call_start_times:\n            duration = time.time() - self.call_start_times[chat_id]\n            self.stats['total_duration'] += duration\n            del self.call_start_times[chat_id]\n\n    async def on_stream_start(self, chat_id, source):\n        \"\"\"Track stream\"\"\"\n        self.stats['streams_played'] += 1\n\n    async def on_user_joined(self, chat_id, user_id):\n        \"\"\"Track unique users\"\"\"\n        self.stats['users_served'].add(user_id)\n\n    def get_statistics(self):\n        \"\"\"Get current statistics\"\"\"\n        stats = self.stats.copy()\n        stats['unique_users'] = len(self.stats['users_served'])\n        stats['average_call_duration'] = (\n            self.stats['total_duration'] / max(self.stats['total_calls'], 1)\n        )\n        return stats\n</code></pre>"},{"location":"plugins/#plugin-best-practices","title":"Plugin Best Practices","text":""},{"location":"plugins/#1-error-handling","title":"1. Error Handling","text":"<pre><code>class SafePlugin(BasePlugin):\n    async def process_audio(self, audio_frame):\n        try:\n            # Your processing code\n            return processed_frame\n        except Exception as e:\n            self.logger.error(f\"Audio processing error: {e}\")\n            return audio_frame  # Return original on error\n</code></pre>"},{"location":"plugins/#2-performance-optimization","title":"2. Performance Optimization","text":"<pre><code>class OptimizedPlugin(BasePlugin):\n    def __init__(self, config=None):\n        super().__init__(config)\n        self.buffer_pool = []  # Reuse buffers\n        self.cache = {}  # Cache expensive operations\n\n    async def process_audio(self, audio_frame):\n        # Use object pooling for better performance\n        buffer = self.get_buffer()\n        try:\n            # Process audio\n            return processed_frame\n        finally:\n            self.return_buffer(buffer)\n</code></pre>"},{"location":"plugins/#3-configuration-validation","title":"3. Configuration Validation","text":"<pre><code>class ConfigurablePlugin(BasePlugin):\n    def __init__(self, config=None):\n        super().__init__(config)\n        self.validate_config()\n\n    def validate_config(self):\n        \"\"\"Validate plugin configuration\"\"\"\n        if self.config:\n            if 'required_setting' not in self.config:\n                raise ValueError(\"required_setting is missing\")\n\n            if not isinstance(self.config['required_setting'], int):\n                raise TypeError(\"required_setting must be an integer\")\n</code></pre>"},{"location":"plugins/#4-resource-cleanup","title":"4. Resource Cleanup","text":"<pre><code>class ResourcePlugin(BasePlugin):\n    def __init__(self, config=None):\n        super().__init__(config)\n        self.resources = []\n\n    async def on_load(self):\n        # Initialize resources\n        self.resources.append(SomeResource())\n\n    async def on_unload(self):\n        # Cleanup resources\n        for resource in self.resources:\n            await resource.cleanup()\n        self.resources.clear()\n</code></pre>"},{"location":"plugins/#plugin-testing","title":"Plugin Testing","text":"<pre><code>import pytest\nfrom unittest.mock import Mock\nfrom tgcaller.plugins import BasePlugin\n\nclass TestMyPlugin:\n    @pytest.fixture\n    def plugin(self):\n        config = {'test_setting': True}\n        return MyPlugin(config)\n\n    @pytest.mark.asyncio\n    async def test_audio_processing(self, plugin):\n        # Test audio processing\n        input_frame = np.random.random(1024)\n        output_frame = await plugin.process_audio(input_frame)\n\n        assert output_frame is not None\n        assert len(output_frame) == len(input_frame)\n\n    def test_configuration(self, plugin):\n        # Test configuration\n        assert plugin.config['test_setting'] is True\n</code></pre> <p>This plugin system allows you to extend TgCaller with custom functionality while maintaining clean separation of concerns and easy testing.</p>"},{"location":"usage/","title":"Usage Guide","text":""},{"location":"usage/#basic-usage","title":"Basic Usage","text":""},{"location":"usage/#setting-up-your-first-bot","title":"Setting Up Your First Bot","text":"<pre><code>import asyncio\nfrom pyrogram import Client\nfrom tgcaller import TgCaller\n\n# Your API credentials\nAPI_ID = 12345\nAPI_HASH = \"your_api_hash\"\nBOT_TOKEN = \"your_bot_token\"\n\n# Initialize Pyrogram client\napp = Client(\"my_bot\", api_id=API_ID, api_hash=API_HASH, bot_token=BOT_TOKEN)\n\n# Initialize TgCaller\ncaller = TgCaller(app)\n\nasync def main():\n    # Start TgCaller\n    await caller.start()\n\n    # Your bot logic here\n    chat_id = -1001234567890  # Your group chat ID\n\n    # Join voice call\n    await caller.join_call(chat_id)\n\n    # Play audio file\n    await caller.play(chat_id, \"song.mp3\")\n\n    # Keep running\n    await asyncio.Event().wait()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"usage/#audio-configuration","title":"Audio Configuration","text":""},{"location":"usage/#quality-presets","title":"Quality Presets","text":"<pre><code>from tgcaller import AudioConfig\n\n# High quality audio (128kbps, stereo, 48kHz)\naudio_config = AudioConfig.high_quality()\n\n# Low bandwidth audio (32kbps, mono, 24kHz)\naudio_config = AudioConfig.low_bandwidth()\n\n# Voice call optimized\naudio_config = AudioConfig.voice_call()\n</code></pre>"},{"location":"usage/#custom-audio-configuration","title":"Custom Audio Configuration","text":"<pre><code>audio_config = AudioConfig(\n    bitrate=128000,           # 128 kbps\n    sample_rate=48000,        # 48 kHz\n    channels=2,               # Stereo\n    noise_suppression=True,   # Clean audio\n    echo_cancellation=True    # No echo\n)\n\nawait caller.play(chat_id, \"song.mp3\", audio_config=audio_config)\n</code></pre>"},{"location":"usage/#video-configuration","title":"Video Configuration","text":""},{"location":"usage/#video-presets","title":"Video Presets","text":"<pre><code>from tgcaller import VideoConfig\n\n# HD 720p video\nvideo_config = VideoConfig.hd_720p()\n\n# Full HD 1080p video\nvideo_config = VideoConfig.full_hd_1080p()\n\n# Low quality for poor connections\nvideo_config = VideoConfig.low_quality()\n</code></pre>"},{"location":"usage/#custom-video-configuration","title":"Custom Video Configuration","text":"<pre><code>video_config = VideoConfig(\n    width=1920,\n    height=1080,\n    fps=30,\n    bitrate=2000000,          # 2 Mbps\n    codec=\"h264\"\n)\n\nawait caller.play(chat_id, \"video.mp4\", video_config=video_config)\n</code></pre>"},{"location":"usage/#event-handling","title":"Event Handling","text":""},{"location":"usage/#stream-events","title":"Stream Events","text":"<pre><code>@caller.on_stream_end\nasync def on_stream_end(client, update):\n    print(f\"Stream ended in {update.chat_id}\")\n    # Auto-play next song\n    await caller.play(update.chat_id, \"next_song.mp3\")\n\n@caller.on_stream_start\nasync def on_stream_start(client, update):\n    print(f\"Stream started in {update.chat_id}\")\n\n@caller.on_error\nasync def on_error(client, error):\n    print(f\"Error occurred: {error}\")\n</code></pre>"},{"location":"usage/#call-events","title":"Call Events","text":"<pre><code>@caller.on_kicked\nasync def on_kicked(client, update):\n    print(f\"Kicked from {update.chat_id}\")\n\n@caller.on_left\nasync def on_left(client, update):\n    print(f\"Left call {update.chat_id}\")\n</code></pre>"},{"location":"usage/#stream-control","title":"Stream Control","text":""},{"location":"usage/#basic-controls","title":"Basic Controls","text":"<pre><code># Pause stream\nawait caller.pause(chat_id)\n\n# Resume stream\nawait caller.resume(chat_id)\n\n# Stop stream\nawait caller.stop_stream(chat_id)\n\n# Set volume (0.0 to 1.0)\nawait caller.set_volume(chat_id, 0.8)\n\n# Seek to position (in seconds)\nawait caller.seek(chat_id, 60.0)\n\n# Get current position\nposition = await caller.get_position(chat_id)\n</code></pre>"},{"location":"usage/#music-bot-example","title":"Music Bot Example","text":"<pre><code>from pyrogram import Client, filters\nfrom tgcaller import TgCaller, AudioConfig\n\napp = Client(\"music_bot\")\ncaller = TgCaller(app)\n\n@app.on_message(filters.command(\"play\"))\nasync def play_music(client, message):\n    if len(message.command) &lt; 2:\n        return await message.reply(\"Usage: /play &lt;song_name&gt;\")\n\n    song = message.command[1]\n    chat_id = message.chat.id\n\n    # Join call if not already joined\n    if not caller.is_connected(chat_id):\n        await caller.join_call(chat_id)\n        await message.reply(\"\ud83d\udcde Joined voice chat!\")\n\n    # Play song\n    audio_config = AudioConfig.high_quality()\n    await caller.play(chat_id, f\"music/{song}.mp3\", audio_config=audio_config)\n    await message.reply(f\"\ud83c\udfb5 Playing: {song}\")\n\n@app.on_message(filters.command(\"pause\"))\nasync def pause_music(client, message):\n    if await caller.pause(message.chat.id):\n        await message.reply(\"\u23f8\ufe0f Music paused\")\n\n@app.on_message(filters.command(\"resume\"))\nasync def resume_music(client, message):\n    if await caller.resume(message.chat.id):\n        await message.reply(\"\u25b6\ufe0f Music resumed\")\n\n@app.on_message(filters.command(\"stop\"))\nasync def stop_music(client, message):\n    if await caller.stop_stream(message.chat.id):\n        await message.reply(\"\u23f9\ufe0f Music stopped\")\n\n@app.on_message(filters.command(\"leave\"))\nasync def leave_call(client, message):\n    if await caller.leave_call(message.chat.id):\n        await message.reply(\"\ud83d\udc4b Left voice chat\")\n\n@caller.on_stream_end\nasync def on_stream_end(client, update):\n    print(f\"Stream ended in {update.chat_id}\")\n\napp.run()\n</code></pre>"},{"location":"usage/#advanced-features","title":"Advanced Features","text":""},{"location":"usage/#youtube-streaming","title":"YouTube Streaming","text":"<pre><code>from tgcaller.advanced import YouTubeStreamer\n\nyoutube = YouTubeStreamer(caller)\n\n# Play YouTube video directly\nawait youtube.play_youtube_url(chat_id, \"https://youtube.com/watch?v=...\")\n\n# Search and play\nawait youtube.search_and_play(chat_id, \"relaxing music\", index=0)\n</code></pre>"},{"location":"usage/#screen-sharing","title":"Screen Sharing","text":"<pre><code>from tgcaller.advanced import ScreenShareStreamer\n\nscreen_streamer = ScreenShareStreamer(caller, chat_id)\n\n# Start screen sharing\nawait screen_streamer.start_streaming(monitor_index=1)\n\n# Stop screen sharing\nawait screen_streamer.stop_streaming()\n</code></pre>"},{"location":"usage/#microphone-streaming","title":"Microphone Streaming","text":"<pre><code>from tgcaller.advanced import MicrophoneStreamer\n\nmic_streamer = MicrophoneStreamer(caller, chat_id)\n\n# Start microphone streaming\nawait mic_streamer.start_streaming()\n\n# Stop microphone streaming\nawait mic_streamer.stop_streaming()\n</code></pre>"},{"location":"usage/#audio-filters","title":"Audio Filters","text":"<pre><code>from tgcaller.advanced import AudioFilters, FilterChain\n\n# Create filter chain\nfilter_chain = FilterChain()\naudio_filters = AudioFilters()\n\n# Add echo effect\nfilter_chain.add_audio_filter(\n    audio_filters.apply_echo,\n    delay=0.3,\n    decay=0.5\n)\n\n# Add reverb effect\nfilter_chain.add_audio_filter(\n    audio_filters.apply_reverb,\n    room_size=0.7,\n    damping=0.4\n)\n\n# Process audio through filters\nfiltered_audio = filter_chain.process_audio(audio_data)\n</code></pre>"},{"location":"usage/#error-handling","title":"Error Handling","text":"<pre><code>from tgcaller.exceptions import TgCallerError, ConnectionError, MediaError\n\ntry:\n    await caller.play(chat_id, \"song.mp3\")\nexcept MediaError as e:\n    print(f\"Media error: {e}\")\nexcept ConnectionError as e:\n    print(f\"Connection error: {e}\")\nexcept TgCallerError as e:\n    print(f\"TgCaller error: {e}\")\n</code></pre>"},{"location":"usage/#best-practices","title":"Best Practices","text":""},{"location":"usage/#1-always-handle-errors","title":"1. Always Handle Errors","text":"<pre><code>try:\n    await caller.join_call(chat_id)\nexcept Exception as e:\n    print(f\"Failed to join call: {e}\")\n</code></pre>"},{"location":"usage/#2-check-connection-status","title":"2. Check Connection Status","text":"<pre><code>if not caller.is_connected(chat_id):\n    await caller.join_call(chat_id)\n</code></pre>"},{"location":"usage/#3-cleanup-resources","title":"3. Cleanup Resources","text":"<pre><code>async def cleanup():\n    # Leave all calls\n    for chat_id in caller.get_active_calls():\n        await caller.leave_call(chat_id)\n\n    # Stop TgCaller\n    await caller.stop()\n</code></pre>"},{"location":"usage/#4-use-appropriate-quality-settings","title":"4. Use Appropriate Quality Settings","text":"<pre><code># For music streaming\naudio_config = AudioConfig.high_quality()\n\n# For voice calls\naudio_config = AudioConfig.voice_call()\n\n# For poor connections\naudio_config = AudioConfig.low_bandwidth()\n</code></pre>"}]}